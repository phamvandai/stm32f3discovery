
STM32F3DISCO_RTOS_2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000784c  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000240  080079dc  080079dc  000179dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08007c1c  08007c1c  00017c1c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08007c20  08007c20  00017c20  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000001d4  20000000  08007c24  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  000201d4  2**0
                  CONTENTS
  7 .bss          00003170  200001d4  200001d4  000201d4  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20003344  20003344  000201d4  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  000201d4  2**0
                  CONTENTS, READONLY
 10 .debug_info   0003b354  00000000  00000000  00020204  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007238  00000000  00000000  0005b558  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00012866  00000000  00000000  00062790  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001800  00000000  00000000  00074ff8  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002048  00000000  00000000  000767f8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000fc7d  00000000  00000000  00078840  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00008181  00000000  00000000  000884bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  0009063e  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00004894  00000000  00000000  000906bc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	200001d4 	.word	0x200001d4
 80001ac:	00000000 	.word	0x00000000
 80001b0:	080079c4 	.word	0x080079c4

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	200001d8 	.word	0x200001d8
 80001cc:	080079c4 	.word	0x080079c4

080001d0 <memchr>:
 80001d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001d4:	2a10      	cmp	r2, #16
 80001d6:	db2b      	blt.n	8000230 <memchr+0x60>
 80001d8:	f010 0f07 	tst.w	r0, #7
 80001dc:	d008      	beq.n	80001f0 <memchr+0x20>
 80001de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001e2:	3a01      	subs	r2, #1
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d02d      	beq.n	8000244 <memchr+0x74>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	b342      	cbz	r2, 8000240 <memchr+0x70>
 80001ee:	d1f6      	bne.n	80001de <memchr+0xe>
 80001f0:	b4f0      	push	{r4, r5, r6, r7}
 80001f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001fa:	f022 0407 	bic.w	r4, r2, #7
 80001fe:	f07f 0700 	mvns.w	r7, #0
 8000202:	2300      	movs	r3, #0
 8000204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000208:	3c08      	subs	r4, #8
 800020a:	ea85 0501 	eor.w	r5, r5, r1
 800020e:	ea86 0601 	eor.w	r6, r6, r1
 8000212:	fa85 f547 	uadd8	r5, r5, r7
 8000216:	faa3 f587 	sel	r5, r3, r7
 800021a:	fa86 f647 	uadd8	r6, r6, r7
 800021e:	faa5 f687 	sel	r6, r5, r7
 8000222:	b98e      	cbnz	r6, 8000248 <memchr+0x78>
 8000224:	d1ee      	bne.n	8000204 <memchr+0x34>
 8000226:	bcf0      	pop	{r4, r5, r6, r7}
 8000228:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800022c:	f002 0207 	and.w	r2, r2, #7
 8000230:	b132      	cbz	r2, 8000240 <memchr+0x70>
 8000232:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000236:	3a01      	subs	r2, #1
 8000238:	ea83 0301 	eor.w	r3, r3, r1
 800023c:	b113      	cbz	r3, 8000244 <memchr+0x74>
 800023e:	d1f8      	bne.n	8000232 <memchr+0x62>
 8000240:	2000      	movs	r0, #0
 8000242:	4770      	bx	lr
 8000244:	3801      	subs	r0, #1
 8000246:	4770      	bx	lr
 8000248:	2d00      	cmp	r5, #0
 800024a:	bf06      	itte	eq
 800024c:	4635      	moveq	r5, r6
 800024e:	3803      	subeq	r0, #3
 8000250:	3807      	subne	r0, #7
 8000252:	f015 0f01 	tst.w	r5, #1
 8000256:	d107      	bne.n	8000268 <memchr+0x98>
 8000258:	3001      	adds	r0, #1
 800025a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800025e:	bf02      	ittt	eq
 8000260:	3001      	addeq	r0, #1
 8000262:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000266:	3001      	addeq	r0, #1
 8000268:	bcf0      	pop	{r4, r5, r6, r7}
 800026a:	3801      	subs	r0, #1
 800026c:	4770      	bx	lr
 800026e:	bf00      	nop

08000270 <HAL_InitTick>:
  *         implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000270:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock / 1000U);
 8000272:	4b08      	ldr	r3, [pc, #32]	; (8000294 <HAL_InitTick+0x24>)
{
 8000274:	4604      	mov	r4, r0
  HAL_SYSTICK_Config(SystemCoreClock / 1000U);
 8000276:	6818      	ldr	r0, [r3, #0]
 8000278:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800027c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000280:	f000 fe72 	bl	8000f68 <HAL_SYSTICK_Config>
 
  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8000284:	2200      	movs	r2, #0
 8000286:	4621      	mov	r1, r4
 8000288:	f04f 30ff 	mov.w	r0, #4294967295
 800028c:	f000 fe2c 	bl	8000ee8 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8000290:	2000      	movs	r0, #0
 8000292:	bd10      	pop	{r4, pc}
 8000294:	20000120 	.word	0x20000120

08000298 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000298:	4a07      	ldr	r2, [pc, #28]	; (80002b8 <HAL_Init+0x20>)
{
 800029a:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800029c:	6813      	ldr	r3, [r2, #0]
 800029e:	f043 0310 	orr.w	r3, r3, #16
 80002a2:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80002a4:	2003      	movs	r0, #3
 80002a6:	f000 fe0d 	bl	8000ec4 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80002aa:	200f      	movs	r0, #15
 80002ac:	f7ff ffe0 	bl	8000270 <HAL_InitTick>
  HAL_MspInit();
 80002b0:	f006 fa0a 	bl	80066c8 <HAL_MspInit>
}
 80002b4:	2000      	movs	r0, #0
 80002b6:	bd08      	pop	{r3, pc}
 80002b8:	40022000 	.word	0x40022000

080002bc <HAL_IncTick>:
  *         implementations  in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80002bc:	4a02      	ldr	r2, [pc, #8]	; (80002c8 <HAL_IncTick+0xc>)
 80002be:	6813      	ldr	r3, [r2, #0]
 80002c0:	3301      	adds	r3, #1
 80002c2:	6013      	str	r3, [r2, #0]
 80002c4:	4770      	bx	lr
 80002c6:	bf00      	nop
 80002c8:	20002110 	.word	0x20002110

080002cc <HAL_GetTick>:
  *         implementations  in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;  
 80002cc:	4b01      	ldr	r3, [pc, #4]	; (80002d4 <HAL_GetTick+0x8>)
 80002ce:	6818      	ldr	r0, [r3, #0]
}
 80002d0:	4770      	bx	lr
 80002d2:	bf00      	nop
 80002d4:	20002110 	.word	0x20002110

080002d8 <HAL_ADC_ConvHalfCpltCallback>:
 80002d8:	4770      	bx	lr

080002da <HAL_ADC_LevelOutOfWindowCallback>:
 80002da:	4770      	bx	lr

080002dc <HAL_ADC_ErrorCallback>:
  *        (ADC conversion with interruption or transfer by DMA)
  * @param  hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 80002dc:	4770      	bx	lr

080002de <ADC_Disable>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef* hadc)
{
 80002de:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;
  
  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /* disabled.                                                                */
  if (ADC_IS_ENABLE(hadc) != RESET )
 80002e0:	6803      	ldr	r3, [r0, #0]
{
 80002e2:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) != RESET )
 80002e4:	6898      	ldr	r0, [r3, #8]
 80002e6:	f000 0003 	and.w	r0, r0, #3
 80002ea:	2801      	cmp	r0, #1
 80002ec:	d001      	beq.n	80002f2 <ADC_Disable+0x14>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 80002ee:	2000      	movs	r0, #0
 80002f0:	bd38      	pop	{r3, r4, r5, pc}
  if (ADC_IS_ENABLE(hadc) != RESET )
 80002f2:	681a      	ldr	r2, [r3, #0]
 80002f4:	07d2      	lsls	r2, r2, #31
 80002f6:	d5fa      	bpl.n	80002ee <ADC_Disable+0x10>
    if (ADC_DISABLING_CONDITIONS(hadc) != RESET)
 80002f8:	689a      	ldr	r2, [r3, #8]
 80002fa:	f002 020d 	and.w	r2, r2, #13
 80002fe:	2a01      	cmp	r2, #1
 8000300:	d11b      	bne.n	800033a <ADC_Disable+0x5c>
      __HAL_ADC_DISABLE(hadc);
 8000302:	689a      	ldr	r2, [r3, #8]
 8000304:	f042 0202 	orr.w	r2, r2, #2
 8000308:	609a      	str	r2, [r3, #8]
 800030a:	2203      	movs	r2, #3
 800030c:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800030e:	f7ff ffdd 	bl	80002cc <HAL_GetTick>
 8000312:	4605      	mov	r5, r0
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADEN))
 8000314:	6823      	ldr	r3, [r4, #0]
 8000316:	689b      	ldr	r3, [r3, #8]
 8000318:	07db      	lsls	r3, r3, #31
 800031a:	d5e8      	bpl.n	80002ee <ADC_Disable+0x10>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800031c:	f7ff ffd6 	bl	80002cc <HAL_GetTick>
 8000320:	1b40      	subs	r0, r0, r5
 8000322:	2802      	cmp	r0, #2
 8000324:	d9f6      	bls.n	8000314 <ADC_Disable+0x36>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000326:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000328:	f043 0310 	orr.w	r3, r3, #16
 800032c:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800032e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000330:	f043 0301 	orr.w	r3, r3, #1
 8000334:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 8000336:	2001      	movs	r0, #1
 8000338:	bd38      	pop	{r3, r4, r5, pc}
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800033a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800033c:	f043 0310 	orr.w	r3, r3, #16
 8000340:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000342:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000344:	f043 0301 	orr.w	r3, r3, #1
 8000348:	64a3      	str	r3, [r4, #72]	; 0x48
      return HAL_ERROR;
 800034a:	bd38      	pop	{r3, r4, r5, pc}

0800034c <ADC_Enable>:
{
 800034c:	b538      	push	{r3, r4, r5, lr}
  if (ADC_IS_ENABLE(hadc) == RESET)
 800034e:	6803      	ldr	r3, [r0, #0]
 8000350:	689a      	ldr	r2, [r3, #8]
 8000352:	f002 0203 	and.w	r2, r2, #3
 8000356:	2a01      	cmp	r2, #1
{
 8000358:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 800035a:	d104      	bne.n	8000366 <ADC_Enable+0x1a>
 800035c:	681a      	ldr	r2, [r3, #0]
 800035e:	07d2      	lsls	r2, r2, #31
 8000360:	d501      	bpl.n	8000366 <ADC_Enable+0x1a>
  return HAL_OK;
 8000362:	2000      	movs	r0, #0
 8000364:	bd38      	pop	{r3, r4, r5, pc}
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8000366:	6899      	ldr	r1, [r3, #8]
 8000368:	4a0e      	ldr	r2, [pc, #56]	; (80003a4 <ADC_Enable+0x58>)
 800036a:	4211      	tst	r1, r2
 800036c:	d10f      	bne.n	800038e <ADC_Enable+0x42>
    __HAL_ADC_ENABLE(hadc);
 800036e:	689a      	ldr	r2, [r3, #8]
 8000370:	f042 0201 	orr.w	r2, r2, #1
 8000374:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();  
 8000376:	f7ff ffa9 	bl	80002cc <HAL_GetTick>
 800037a:	4605      	mov	r5, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 800037c:	6823      	ldr	r3, [r4, #0]
 800037e:	681b      	ldr	r3, [r3, #0]
 8000380:	07db      	lsls	r3, r3, #31
 8000382:	d4ee      	bmi.n	8000362 <ADC_Enable+0x16>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8000384:	f7ff ffa2 	bl	80002cc <HAL_GetTick>
 8000388:	1b40      	subs	r0, r0, r5
 800038a:	2802      	cmp	r0, #2
 800038c:	d9f6      	bls.n	800037c <ADC_Enable+0x30>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800038e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000390:	f043 0310 	orr.w	r3, r3, #16
 8000394:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000396:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000398:	f043 0301 	orr.w	r3, r3, #1
 800039c:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 800039e:	2001      	movs	r0, #1
 80003a0:	bd38      	pop	{r3, r4, r5, pc}
 80003a2:	bf00      	nop
 80003a4:	8000003f 	.word	0x8000003f

080003a8 <ADC_DMAError>:
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80003a8:	6a40      	ldr	r0, [r0, #36]	; 0x24
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 80003aa:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80003ac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80003b0:	6443      	str	r3, [r0, #68]	; 0x44
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 80003b2:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80003b4:	f043 0304 	orr.w	r3, r3, #4
 80003b8:	6483      	str	r3, [r0, #72]	; 0x48
  HAL_ADC_ErrorCallback(hadc); 
 80003ba:	f7ff bf8f 	b.w	80002dc <HAL_ADC_ErrorCallback>

080003be <ADC_DMAHalfConvCplt>:
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 80003be:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80003c0:	f7ff bf8a 	b.w	80002d8 <HAL_ADC_ConvHalfCpltCallback>

080003c4 <ADC_DMAConvCplt>:
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80003c4:	6a43      	ldr	r3, [r0, #36]	; 0x24
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80003c6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80003c8:	f012 0f50 	tst.w	r2, #80	; 0x50
 80003cc:	d118      	bne.n	8000400 <ADC_DMAConvCplt+0x3c>
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80003ce:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80003d0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80003d4:	645a      	str	r2, [r3, #68]	; 0x44
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80003d6:	681a      	ldr	r2, [r3, #0]
 80003d8:	68d2      	ldr	r2, [r2, #12]
 80003da:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 80003de:	d10c      	bne.n	80003fa <ADC_DMAConvCplt+0x36>
 80003e0:	69da      	ldr	r2, [r3, #28]
 80003e2:	b952      	cbnz	r2, 80003fa <ADC_DMAConvCplt+0x36>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 80003e4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80003e6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80003ea:	645a      	str	r2, [r3, #68]	; 0x44
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80003ec:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80003ee:	04d2      	lsls	r2, r2, #19
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80003f0:	bf5e      	ittt	pl
 80003f2:	6c5a      	ldrpl	r2, [r3, #68]	; 0x44
 80003f4:	f042 0201 	orrpl.w	r2, r2, #1
 80003f8:	645a      	strpl	r2, [r3, #68]	; 0x44
    HAL_ADC_ConvCpltCallback(hadc); 
 80003fa:	4618      	mov	r0, r3
 80003fc:	f006 baaa 	b.w	8006954 <HAL_ADC_ConvCpltCallback>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 8000400:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000402:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000404:	4718      	bx	r3
	...

08000408 <HAL_ADC_Init>:
{
 8000408:	b570      	push	{r4, r5, r6, lr}
 800040a:	b096      	sub	sp, #88	; 0x58
  __IO uint32_t wait_loop_index = 0U;
 800040c:	2300      	movs	r3, #0
 800040e:	9300      	str	r3, [sp, #0]
  if(hadc == NULL)
 8000410:	4604      	mov	r4, r0
 8000412:	2800      	cmp	r0, #0
 8000414:	f000 8084 	beq.w	8000520 <HAL_ADC_Init+0x118>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8000418:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800041a:	06d2      	lsls	r2, r2, #27
 800041c:	d462      	bmi.n	80004e4 <HAL_ADC_Init+0xdc>
    if (hadc->State == HAL_ADC_STATE_RESET)
 800041e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8000420:	2b00      	cmp	r3, #0
 8000422:	d02d      	beq.n	8000480 <HAL_ADC_Init+0x78>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000424:	2000      	movs	r0, #0
    if (HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADVREGEN_0) ||
 8000426:	6823      	ldr	r3, [r4, #0]
 8000428:	689a      	ldr	r2, [r3, #8]
 800042a:	00d1      	lsls	r1, r2, #3
 800042c:	d502      	bpl.n	8000434 <HAL_ADC_Init+0x2c>
        HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADVREGEN_1)   )
 800042e:	689b      	ldr	r3, [r3, #8]
    if (HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADVREGEN_0) ||
 8000430:	009a      	lsls	r2, r3, #2
 8000432:	d50a      	bpl.n	800044a <HAL_ADC_Init+0x42>
      ADC_STATE_CLR_SET(hadc->State,
 8000434:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000436:	f023 0312 	bic.w	r3, r3, #18
 800043a:	f043 0310 	orr.w	r3, r3, #16
 800043e:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000440:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000442:	f043 0301 	orr.w	r3, r3, #1
 8000446:	64a3      	str	r3, [r4, #72]	; 0x48
      tmp_hal_status = HAL_ERROR;
 8000448:	2001      	movs	r0, #1
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 800044a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800044c:	06db      	lsls	r3, r3, #27
 800044e:	d461      	bmi.n	8000514 <HAL_ADC_Init+0x10c>
 8000450:	2800      	cmp	r0, #0
 8000452:	d15f      	bne.n	8000514 <HAL_ADC_Init+0x10c>
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8000454:	6823      	ldr	r3, [r4, #0]
 8000456:	689d      	ldr	r5, [r3, #8]
      (tmp_hal_status == HAL_OK)                                &&
 8000458:	f015 0504 	ands.w	r5, r5, #4
 800045c:	d15a      	bne.n	8000514 <HAL_ADC_Init+0x10c>
    ADC_STATE_CLR_SET(hadc->State,
 800045e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8000460:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8000464:	f042 0202 	orr.w	r2, r2, #2
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000468:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
    ADC_STATE_CLR_SET(hadc->State,
 800046c:	6462      	str	r2, [r4, #68]	; 0x44
 800046e:	4a6b      	ldr	r2, [pc, #428]	; (800061c <HAL_ADC_Init+0x214>)
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000470:	d003      	beq.n	800047a <HAL_ADC_Init+0x72>
 8000472:	4293      	cmp	r3, r2
 8000474:	d156      	bne.n	8000524 <HAL_ADC_Init+0x11c>
    ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 8000476:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 800047a:	9201      	str	r2, [sp, #4]
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 800047c:	4968      	ldr	r1, [pc, #416]	; (8000620 <HAL_ADC_Init+0x218>)
 800047e:	e057      	b.n	8000530 <HAL_ADC_Init+0x128>
      ADC_CLEAR_ERRORCODE(hadc);
 8000480:	6483      	str	r3, [r0, #72]	; 0x48
      hadc->InjectionConfig.ChannelCount = 0U;
 8000482:	6503      	str	r3, [r0, #80]	; 0x50
      hadc->InjectionConfig.ContextQueue = 0U;
 8000484:	64c3      	str	r3, [r0, #76]	; 0x4c
      hadc->Lock = HAL_UNLOCKED;
 8000486:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
      HAL_ADC_MspInit(hadc);
 800048a:	f006 f95b 	bl	8006744 <HAL_ADC_MspInit>
      if (HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADVREGEN_0))
 800048e:	6823      	ldr	r3, [r4, #0]
 8000490:	689b      	ldr	r3, [r3, #8]
 8000492:	00de      	lsls	r6, r3, #3
 8000494:	d4c6      	bmi.n	8000424 <HAL_ADC_Init+0x1c>
        tmp_hal_status = ADC_Disable(hadc);
 8000496:	4620      	mov	r0, r4
 8000498:	f7ff ff21 	bl	80002de <ADC_Disable>
        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 800049c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800049e:	06d5      	lsls	r5, r2, #27
 80004a0:	d4c1      	bmi.n	8000426 <HAL_ADC_Init+0x1e>
 80004a2:	2800      	cmp	r0, #0
 80004a4:	d1bf      	bne.n	8000426 <HAL_ADC_Init+0x1e>
          ADC_STATE_CLR_SET(hadc->State,
 80004a6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80004a8:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80004ac:	f023 0302 	bic.w	r3, r3, #2
 80004b0:	f043 0302 	orr.w	r3, r3, #2
 80004b4:	6463      	str	r3, [r4, #68]	; 0x44
          CLEAR_BIT(hadc->Instance->CR, (ADC_CR_ADVREGEN_1 | ADC_CR_ADVREGEN_0));
 80004b6:	6823      	ldr	r3, [r4, #0]
 80004b8:	689a      	ldr	r2, [r3, #8]
 80004ba:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80004be:	609a      	str	r2, [r3, #8]
          SET_BIT(hadc->Instance->CR, ADC_CR_ADVREGEN_0);
 80004c0:	689a      	ldr	r2, [r3, #8]
 80004c2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80004c6:	609a      	str	r2, [r3, #8]
          wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80004c8:	4b56      	ldr	r3, [pc, #344]	; (8000624 <HAL_ADC_Init+0x21c>)
 80004ca:	4a57      	ldr	r2, [pc, #348]	; (8000628 <HAL_ADC_Init+0x220>)
 80004cc:	681b      	ldr	r3, [r3, #0]
 80004ce:	fbb3 f2f2 	udiv	r2, r3, r2
 80004d2:	230a      	movs	r3, #10
 80004d4:	4353      	muls	r3, r2
            wait_loop_index--;
 80004d6:	9300      	str	r3, [sp, #0]
          while(wait_loop_index != 0U)
 80004d8:	9b00      	ldr	r3, [sp, #0]
 80004da:	2b00      	cmp	r3, #0
 80004dc:	d0a2      	beq.n	8000424 <HAL_ADC_Init+0x1c>
            wait_loop_index--;
 80004de:	9b00      	ldr	r3, [sp, #0]
 80004e0:	3b01      	subs	r3, #1
 80004e2:	e7f8      	b.n	80004d6 <HAL_ADC_Init+0xce>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80004e4:	4618      	mov	r0, r3
 80004e6:	e7b0      	b.n	800044a <HAL_ADC_Init+0x42>
    ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 80004e8:	4293      	cmp	r3, r2
 80004ea:	bf0c      	ite	eq
 80004ec:	9101      	streq	r1, [sp, #4]
 80004ee:	9001      	strne	r0, [sp, #4]
 80004f0:	e01d      	b.n	800052e <HAL_ADC_Init+0x126>
        ADC_STATE_CLR_SET(hadc->State,
 80004f2:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80004f4:	f021 0122 	bic.w	r1, r1, #34	; 0x22
 80004f8:	f041 0120 	orr.w	r1, r1, #32
 80004fc:	6461      	str	r1, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80004fe:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8000500:	f041 0101 	orr.w	r1, r1, #1
 8000504:	64a1      	str	r1, [r4, #72]	; 0x48
 8000506:	e043      	b.n	8000590 <HAL_ADC_Init+0x188>
      SET_BIT(tmpCFGR, ADC_CFGR_EXTSEL_SET(hadc, hadc->Init.ExternalTrigConv) |
 8000508:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
 800050c:	e055      	b.n	80005ba <HAL_ADC_Init+0x1b2>
 800050e:	f44f 7130 	mov.w	r1, #704	; 0x2c0
 8000512:	e052      	b.n	80005ba <HAL_ADC_Init+0x1b2>
    ADC_STATE_CLR_SET(hadc->State,
 8000514:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000516:	f023 0312 	bic.w	r3, r3, #18
 800051a:	f043 0310 	orr.w	r3, r3, #16
 800051e:	6463      	str	r3, [r4, #68]	; 0x44
    return HAL_ERROR;
 8000520:	2001      	movs	r0, #1
 8000522:	e079      	b.n	8000618 <HAL_ADC_Init+0x210>
    ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 8000524:	4941      	ldr	r1, [pc, #260]	; (800062c <HAL_ADC_Init+0x224>)
 8000526:	4a42      	ldr	r2, [pc, #264]	; (8000630 <HAL_ADC_Init+0x228>)
 8000528:	428b      	cmp	r3, r1
 800052a:	d1dd      	bne.n	80004e8 <HAL_ADC_Init+0xe0>
 800052c:	9201      	str	r2, [sp, #4]
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 800052e:	4941      	ldr	r1, [pc, #260]	; (8000634 <HAL_ADC_Init+0x22c>)
    if ((ADC_IS_ENABLE(hadc) == RESET)                                   &&
 8000530:	689a      	ldr	r2, [r3, #8]
 8000532:	f002 0203 	and.w	r2, r2, #3
 8000536:	2a01      	cmp	r2, #1
 8000538:	d102      	bne.n	8000540 <HAL_ADC_Init+0x138>
 800053a:	681a      	ldr	r2, [r3, #0]
 800053c:	07d6      	lsls	r6, r2, #31
 800053e:	d40f      	bmi.n	8000560 <HAL_ADC_Init+0x158>
        ((tmphadcSharingSameCommonRegister.Instance == NULL)         ||
 8000540:	9a01      	ldr	r2, [sp, #4]
    if ((ADC_IS_ENABLE(hadc) == RESET)                                   &&
 8000542:	b13a      	cbz	r2, 8000554 <HAL_ADC_Init+0x14c>
         (ADC_IS_ENABLE(&tmphadcSharingSameCommonRegister) == RESET)   )   )
 8000544:	6896      	ldr	r6, [r2, #8]
 8000546:	f006 0603 	and.w	r6, r6, #3
 800054a:	2e01      	cmp	r6, #1
 800054c:	d102      	bne.n	8000554 <HAL_ADC_Init+0x14c>
 800054e:	6812      	ldr	r2, [r2, #0]
 8000550:	07d2      	lsls	r2, r2, #31
 8000552:	d405      	bmi.n	8000560 <HAL_ADC_Init+0x158>
      MODIFY_REG(tmpADC_Common->CCR       ,
 8000554:	688a      	ldr	r2, [r1, #8]
 8000556:	6866      	ldr	r6, [r4, #4]
 8000558:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800055c:	4332      	orrs	r2, r6
 800055e:	608a      	str	r2, [r1, #8]
    SET_BIT(tmpCFGR, ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode) |
 8000560:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000562:	68a6      	ldr	r6, [r4, #8]
 8000564:	69e1      	ldr	r1, [r4, #28]
 8000566:	2a01      	cmp	r2, #1
 8000568:	68e2      	ldr	r2, [r4, #12]
 800056a:	ea42 0206 	orr.w	r2, r2, r6
 800056e:	bf18      	it	ne
 8000570:	f44f 5580 	movne.w	r5, #4096	; 0x1000
 8000574:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 8000578:	432a      	orrs	r2, r5
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800057a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800057c:	2d01      	cmp	r5, #1
 800057e:	d107      	bne.n	8000590 <HAL_ADC_Init+0x188>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8000580:	2900      	cmp	r1, #0
 8000582:	d1b6      	bne.n	80004f2 <HAL_ADC_Init+0xea>
        SET_BIT(tmpCFGR, ADC_CFGR_DISCEN                                            |
 8000584:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000586:	3901      	subs	r1, #1
 8000588:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
 800058c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000590:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000592:	2901      	cmp	r1, #1
 8000594:	d014      	beq.n	80005c0 <HAL_ADC_Init+0x1b8>
      SET_BIT(tmpCFGR, ADC_CFGR_EXTSEL_SET(hadc, hadc->Init.ExternalTrigConv) |
 8000596:	4d25      	ldr	r5, [pc, #148]	; (800062c <HAL_ADC_Init+0x224>)
 8000598:	42ab      	cmp	r3, r5
 800059a:	d003      	beq.n	80005a4 <HAL_ADC_Init+0x19c>
 800059c:	f505 7580 	add.w	r5, r5, #256	; 0x100
 80005a0:	42ab      	cmp	r3, r5
 80005a2:	d10a      	bne.n	80005ba <HAL_ADC_Init+0x1b2>
 80005a4:	f5b1 7f30 	cmp.w	r1, #704	; 0x2c0
 80005a8:	d0ae      	beq.n	8000508 <HAL_ADC_Init+0x100>
 80005aa:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 80005ae:	d0ae      	beq.n	800050e <HAL_ADC_Init+0x106>
 80005b0:	f5b1 7fe0 	cmp.w	r1, #448	; 0x1c0
 80005b4:	bf08      	it	eq
 80005b6:	f44f 7180 	moveq.w	r1, #256	; 0x100
 80005ba:	6b25      	ldr	r5, [r4, #48]	; 0x30
 80005bc:	432a      	orrs	r2, r5
 80005be:	430a      	orrs	r2, r1
    if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 80005c0:	6899      	ldr	r1, [r3, #8]
 80005c2:	f011 0f0c 	tst.w	r1, #12
 80005c6:	d10b      	bne.n	80005e0 <HAL_ADC_Init+0x1d8>
      CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_AUTDLY |
 80005c8:	68d9      	ldr	r1, [r3, #12]
      SET_BIT(tmpCFGR, ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
 80005ca:	69a5      	ldr	r5, [r4, #24]
      CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_AUTDLY |
 80005cc:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 80005d0:	f021 0102 	bic.w	r1, r1, #2
 80005d4:	60d9      	str	r1, [r3, #12]
      SET_BIT(tmpCFGR, ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
 80005d6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80005d8:	0049      	lsls	r1, r1, #1
 80005da:	ea41 3185 	orr.w	r1, r1, r5, lsl #14
 80005de:	430a      	orrs	r2, r1
    MODIFY_REG(hadc->Instance->CFGR,
 80005e0:	68dd      	ldr	r5, [r3, #12]
 80005e2:	4915      	ldr	r1, [pc, #84]	; (8000638 <HAL_ADC_Init+0x230>)
 80005e4:	4029      	ands	r1, r5
 80005e6:	430a      	orrs	r2, r1
 80005e8:	60da      	str	r2, [r3, #12]
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 80005ea:	6922      	ldr	r2, [r4, #16]
 80005ec:	2a01      	cmp	r2, #1
      MODIFY_REG(hadc->Instance->SQR1                     ,
 80005ee:	bf05      	ittet	eq
 80005f0:	6b19      	ldreq	r1, [r3, #48]	; 0x30
 80005f2:	6a22      	ldreq	r2, [r4, #32]
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 80005f4:	6b1a      	ldrne	r2, [r3, #48]	; 0x30
      MODIFY_REG(hadc->Instance->SQR1                     ,
 80005f6:	f102 32ff 	addeq.w	r2, r2, #4294967295
 80005fa:	bf06      	itte	eq
 80005fc:	f021 010f 	biceq.w	r1, r1, #15
 8000600:	430a      	orreq	r2, r1
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8000602:	f022 020f 	bicne.w	r2, r2, #15
 8000606:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_CLEAR_ERRORCODE(hadc);
 8000608:	2300      	movs	r3, #0
 800060a:	64a3      	str	r3, [r4, #72]	; 0x48
    ADC_STATE_CLR_SET(hadc->State,
 800060c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800060e:	f023 0303 	bic.w	r3, r3, #3
 8000612:	f043 0301 	orr.w	r3, r3, #1
 8000616:	6463      	str	r3, [r4, #68]	; 0x44
}
 8000618:	b016      	add	sp, #88	; 0x58
 800061a:	bd70      	pop	{r4, r5, r6, pc}
 800061c:	50000100 	.word	0x50000100
 8000620:	50000300 	.word	0x50000300
 8000624:	20000120 	.word	0x20000120
 8000628:	000f4240 	.word	0x000f4240
 800062c:	50000400 	.word	0x50000400
 8000630:	50000500 	.word	0x50000500
 8000634:	50000700 	.word	0x50000700
 8000638:	fff0c007 	.word	0xfff0c007

0800063c <HAL_ADC_Start_DMA>:
{
 800063c:	e92d 41d8 	stmdb	sp!, {r3, r4, r6, r7, r8, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000640:	6803      	ldr	r3, [r0, #0]
{
 8000642:	4690      	mov	r8, r2
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000644:	689a      	ldr	r2, [r3, #8]
 8000646:	0756      	lsls	r6, r2, #29
{
 8000648:	4604      	mov	r4, r0
 800064a:	460f      	mov	r7, r1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800064c:	f100 8092 	bmi.w	8000774 <HAL_ADC_Start_DMA+0x138>
    __HAL_LOCK(hadc);
 8000650:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8000654:	2a01      	cmp	r2, #1
 8000656:	f000 808d 	beq.w	8000774 <HAL_ADC_Start_DMA+0x138>
 800065a:	2201      	movs	r2, #1
    if(ADC_COMMON_CCR_MULTI(hadc) == RESET)
 800065c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
    __HAL_LOCK(hadc);
 8000660:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    if(ADC_COMMON_CCR_MULTI(hadc) == RESET)
 8000664:	d002      	beq.n	800066c <HAL_ADC_Start_DMA+0x30>
 8000666:	4a44      	ldr	r2, [pc, #272]	; (8000778 <HAL_ADC_Start_DMA+0x13c>)
 8000668:	4293      	cmp	r3, r2
 800066a:	d135      	bne.n	80006d8 <HAL_ADC_Start_DMA+0x9c>
 800066c:	4b43      	ldr	r3, [pc, #268]	; (800077c <HAL_ADC_Start_DMA+0x140>)
 800066e:	689b      	ldr	r3, [r3, #8]
 8000670:	f013 0f1f 	tst.w	r3, #31
 8000674:	bf0c      	ite	eq
 8000676:	2301      	moveq	r3, #1
 8000678:	2300      	movne	r3, #0
 800067a:	2b00      	cmp	r3, #0
 800067c:	d076      	beq.n	800076c <HAL_ADC_Start_DMA+0x130>
      tmp_hal_status = ADC_Enable(hadc);
 800067e:	4620      	mov	r0, r4
 8000680:	f7ff fe64 	bl	800034c <ADC_Enable>
      if (tmp_hal_status == HAL_OK)
 8000684:	4606      	mov	r6, r0
 8000686:	2800      	cmp	r0, #0
 8000688:	d16c      	bne.n	8000764 <HAL_ADC_Start_DMA+0x128>
        ADC_STATE_CLR_SET(hadc->State,
 800068a:	6c60      	ldr	r0, [r4, #68]	; 0x44
        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800068c:	6821      	ldr	r1, [r4, #0]
        ADC_STATE_CLR_SET(hadc->State,
 800068e:	f420 6070 	bic.w	r0, r0, #3840	; 0xf00
 8000692:	f020 0001 	bic.w	r0, r0, #1
 8000696:	f440 7080 	orr.w	r0, r0, #256	; 0x100
        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800069a:	f1b1 4fa0 	cmp.w	r1, #1342177280	; 0x50000000
        ADC_STATE_CLR_SET(hadc->State,
 800069e:	6460      	str	r0, [r4, #68]	; 0x44
        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 80006a0:	d002      	beq.n	80006a8 <HAL_ADC_Start_DMA+0x6c>
 80006a2:	4b35      	ldr	r3, [pc, #212]	; (8000778 <HAL_ADC_Start_DMA+0x13c>)
 80006a4:	4299      	cmp	r1, r3
 80006a6:	d119      	bne.n	80006dc <HAL_ADC_Start_DMA+0xa0>
 80006a8:	4b34      	ldr	r3, [pc, #208]	; (800077c <HAL_ADC_Start_DMA+0x140>)
 80006aa:	689b      	ldr	r3, [r3, #8]
 80006ac:	06d8      	lsls	r0, r3, #27
 80006ae:	d005      	beq.n	80006bc <HAL_ADC_Start_DMA+0x80>
 80006b0:	f1b1 4fa0 	cmp.w	r1, #1342177280	; 0x50000000
 80006b4:	d002      	beq.n	80006bc <HAL_ADC_Start_DMA+0x80>
 80006b6:	4b32      	ldr	r3, [pc, #200]	; (8000780 <HAL_ADC_Start_DMA+0x144>)
 80006b8:	4299      	cmp	r1, r3
 80006ba:	d11c      	bne.n	80006f6 <HAL_ADC_Start_DMA+0xba>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80006bc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80006be:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80006c2:	6463      	str	r3, [r4, #68]	; 0x44
          if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != RESET)
 80006c4:	68cb      	ldr	r3, [r1, #12]
 80006c6:	019b      	lsls	r3, r3, #6
 80006c8:	d523      	bpl.n	8000712 <HAL_ADC_Start_DMA+0xd6>
            ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 80006ca:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80006cc:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80006d0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80006d4:	6463      	str	r3, [r4, #68]	; 0x44
 80006d6:	e01c      	b.n	8000712 <HAL_ADC_Start_DMA+0xd6>
    if(ADC_COMMON_CCR_MULTI(hadc) == RESET)
 80006d8:	4b2a      	ldr	r3, [pc, #168]	; (8000784 <HAL_ADC_Start_DMA+0x148>)
 80006da:	e7c8      	b.n	800066e <HAL_ADC_Start_DMA+0x32>
        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 80006dc:	4b29      	ldr	r3, [pc, #164]	; (8000784 <HAL_ADC_Start_DMA+0x148>)
 80006de:	689b      	ldr	r3, [r3, #8]
 80006e0:	06da      	lsls	r2, r3, #27
 80006e2:	d0eb      	beq.n	80006bc <HAL_ADC_Start_DMA+0x80>
 80006e4:	4b26      	ldr	r3, [pc, #152]	; (8000780 <HAL_ADC_Start_DMA+0x144>)
 80006e6:	4299      	cmp	r1, r3
 80006e8:	d0e8      	beq.n	80006bc <HAL_ADC_Start_DMA+0x80>
          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80006ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80006ec:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006f0:	6463      	str	r3, [r4, #68]	; 0x44
          if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 80006f2:	4b23      	ldr	r3, [pc, #140]	; (8000780 <HAL_ADC_Start_DMA+0x144>)
 80006f4:	e008      	b.n	8000708 <HAL_ADC_Start_DMA+0xcc>
          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80006f6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80006f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006fc:	6463      	str	r3, [r4, #68]	; 0x44
          if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 80006fe:	4b1e      	ldr	r3, [pc, #120]	; (8000778 <HAL_ADC_Start_DMA+0x13c>)
 8000700:	4299      	cmp	r1, r3
 8000702:	d1f6      	bne.n	80006f2 <HAL_ADC_Start_DMA+0xb6>
 8000704:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 8000708:	68d8      	ldr	r0, [r3, #12]
 800070a:	f3c0 6040 	ubfx	r0, r0, #25, #1
 800070e:	2800      	cmp	r0, #0
 8000710:	d1db      	bne.n	80006ca <HAL_ADC_Start_DMA+0x8e>
        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8000712:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000714:	6be0      	ldr	r0, [r4, #60]	; 0x3c
        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8000716:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 800071a:	bf1c      	itt	ne
 800071c:	6ca3      	ldrne	r3, [r4, #72]	; 0x48
 800071e:	f023 0306 	bicne.w	r3, r3, #6
          ADC_CLEAR_ERRORCODE(hadc);
 8000722:	64a3      	str	r3, [r4, #72]	; 0x48
        __HAL_UNLOCK(hadc);
 8000724:	2300      	movs	r3, #0
 8000726:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800072a:	4b17      	ldr	r3, [pc, #92]	; (8000788 <HAL_ADC_Start_DMA+0x14c>)
 800072c:	6283      	str	r3, [r0, #40]	; 0x28
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800072e:	4b17      	ldr	r3, [pc, #92]	; (800078c <HAL_ADC_Start_DMA+0x150>)
 8000730:	62c3      	str	r3, [r0, #44]	; 0x2c
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000732:	4b17      	ldr	r3, [pc, #92]	; (8000790 <HAL_ADC_Start_DMA+0x154>)
 8000734:	6303      	str	r3, [r0, #48]	; 0x30
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8000736:	231c      	movs	r3, #28
 8000738:	600b      	str	r3, [r1, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 800073a:	684b      	ldr	r3, [r1, #4]
 800073c:	f043 0310 	orr.w	r3, r3, #16
 8000740:	604b      	str	r3, [r1, #4]
        SET_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN);
 8000742:	68cb      	ldr	r3, [r1, #12]
 8000744:	f043 0301 	orr.w	r3, r3, #1
 8000748:	60cb      	str	r3, [r1, #12]
        HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 800074a:	463a      	mov	r2, r7
 800074c:	4643      	mov	r3, r8
 800074e:	3140      	adds	r1, #64	; 0x40
 8000750:	f000 fcdb 	bl	800110a <HAL_DMA_Start_IT>
        SET_BIT(hadc->Instance->CR, ADC_CR_ADSTART);
 8000754:	6822      	ldr	r2, [r4, #0]
 8000756:	6893      	ldr	r3, [r2, #8]
 8000758:	f043 0304 	orr.w	r3, r3, #4
 800075c:	6093      	str	r3, [r2, #8]
}
 800075e:	4630      	mov	r0, r6
 8000760:	e8bd 81d8 	ldmia.w	sp!, {r3, r4, r6, r7, r8, pc}
        __HAL_UNLOCK(hadc);
 8000764:	2300      	movs	r3, #0
 8000766:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 800076a:	e7f8      	b.n	800075e <HAL_ADC_Start_DMA+0x122>
      __HAL_UNLOCK(hadc);
 800076c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      tmp_hal_status = HAL_ERROR;
 8000770:	2601      	movs	r6, #1
 8000772:	e7f4      	b.n	800075e <HAL_ADC_Start_DMA+0x122>
    tmp_hal_status = HAL_BUSY;
 8000774:	2602      	movs	r6, #2
 8000776:	e7f2      	b.n	800075e <HAL_ADC_Start_DMA+0x122>
 8000778:	50000100 	.word	0x50000100
 800077c:	50000300 	.word	0x50000300
 8000780:	50000400 	.word	0x50000400
 8000784:	50000700 	.word	0x50000700
 8000788:	080003c5 	.word	0x080003c5
 800078c:	080003bf 	.word	0x080003bf
 8000790:	080003a9 	.word	0x080003a9

08000794 <HAL_ADCEx_InjectedQueueOverflowCallback>:
 8000794:	4770      	bx	lr

08000796 <HAL_ADCEx_LevelOutOfWindow2Callback>:
 8000796:	4770      	bx	lr

08000798 <HAL_ADCEx_LevelOutOfWindow3Callback>:
{
 8000798:	4770      	bx	lr
	...

0800079c <HAL_ADC_IRQHandler>:
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
 800079c:	6803      	ldr	r3, [r0, #0]
 800079e:	681a      	ldr	r2, [r3, #0]
 80007a0:	0752      	lsls	r2, r2, #29
{
 80007a2:	b510      	push	{r4, lr}
 80007a4:	4604      	mov	r4, r0
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
 80007a6:	d502      	bpl.n	80007ae <HAL_ADC_IRQHandler+0x12>
 80007a8:	685a      	ldr	r2, [r3, #4]
 80007aa:	0750      	lsls	r0, r2, #29
 80007ac:	d405      	bmi.n	80007ba <HAL_ADC_IRQHandler+0x1e>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )
 80007ae:	681a      	ldr	r2, [r3, #0]
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC)) || 
 80007b0:	0711      	lsls	r1, r2, #28
 80007b2:	d544      	bpl.n	800083e <HAL_ADC_IRQHandler+0xa2>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOS))   )
 80007b4:	685a      	ldr	r2, [r3, #4]
 80007b6:	0712      	lsls	r2, r2, #28
 80007b8:	d541      	bpl.n	800083e <HAL_ADC_IRQHandler+0xa2>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80007ba:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80007bc:	06d0      	lsls	r0, r2, #27
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80007be:	bf5e      	ittt	pl
 80007c0:	6c62      	ldrpl	r2, [r4, #68]	; 0x44
 80007c2:	f442 7200 	orrpl.w	r2, r2, #512	; 0x200
 80007c6:	6462      	strpl	r2, [r4, #68]	; 0x44
    if (ADC_NONMULTIMODE_REG_OR_MULTIMODEMASTER(hadc))
 80007c8:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80007cc:	d003      	beq.n	80007d6 <HAL_ADC_IRQHandler+0x3a>
 80007ce:	4aa3      	ldr	r2, [pc, #652]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 80007d0:	4293      	cmp	r3, r2
 80007d2:	f040 810f 	bne.w	80009f4 <HAL_ADC_IRQHandler+0x258>
 80007d6:	4aa2      	ldr	r2, [pc, #648]	; (8000a60 <HAL_ADC_IRQHandler+0x2c4>)
 80007d8:	6891      	ldr	r1, [r2, #8]
 80007da:	06c9      	lsls	r1, r1, #27
 80007dc:	d00c      	beq.n	80007f8 <HAL_ADC_IRQHandler+0x5c>
 80007de:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80007e2:	d003      	beq.n	80007ec <HAL_ADC_IRQHandler+0x50>
 80007e4:	499d      	ldr	r1, [pc, #628]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 80007e6:	428b      	cmp	r3, r1
 80007e8:	f040 8109 	bne.w	80009fe <HAL_ADC_IRQHandler+0x262>
 80007ec:	6892      	ldr	r2, [r2, #8]
 80007ee:	f002 021f 	and.w	r2, r2, #31
 80007f2:	2a05      	cmp	r2, #5
 80007f4:	f040 8115 	bne.w	8000a22 <HAL_ADC_IRQHandler+0x286>
      tmp_cfgr = READ_REG(hadc->Instance->CFGR); 
 80007f8:	68da      	ldr	r2, [r3, #12]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)         && 
 80007fa:	68d9      	ldr	r1, [r3, #12]
 80007fc:	f411 6f40 	tst.w	r1, #3072	; 0xc00
 8000800:	d117      	bne.n	8000832 <HAL_ADC_IRQHandler+0x96>
 8000802:	0490      	lsls	r0, r2, #18
 8000804:	d415      	bmi.n	8000832 <HAL_ADC_IRQHandler+0x96>
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8000806:	681a      	ldr	r2, [r3, #0]
 8000808:	0711      	lsls	r1, r2, #28
 800080a:	d512      	bpl.n	8000832 <HAL_ADC_IRQHandler+0x96>
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800080c:	689a      	ldr	r2, [r3, #8]
 800080e:	0752      	lsls	r2, r2, #29
 8000810:	f100 812c 	bmi.w	8000a6c <HAL_ADC_IRQHandler+0x2d0>
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8000814:	685a      	ldr	r2, [r3, #4]
 8000816:	f022 020c 	bic.w	r2, r2, #12
 800081a:	605a      	str	r2, [r3, #4]
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 800081c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800081e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000822:	6463      	str	r3, [r4, #68]	; 0x44
          if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8000824:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000826:	04db      	lsls	r3, r3, #19
 8000828:	d403      	bmi.n	8000832 <HAL_ADC_IRQHandler+0x96>
            SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 800082a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800082c:	f043 0301 	orr.w	r3, r3, #1
 8000830:	6463      	str	r3, [r4, #68]	; 0x44
      HAL_ADC_ConvCpltCallback(hadc);
 8000832:	4620      	mov	r0, r4
 8000834:	f006 f88e 	bl	8006954 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS) );
 8000838:	6823      	ldr	r3, [r4, #0]
 800083a:	220c      	movs	r2, #12
 800083c:	601a      	str	r2, [r3, #0]
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC)) ||   
 800083e:	6823      	ldr	r3, [r4, #0]
 8000840:	681a      	ldr	r2, [r3, #0]
 8000842:	0690      	lsls	r0, r2, #26
 8000844:	d502      	bpl.n	800084c <HAL_ADC_IRQHandler+0xb0>
 8000846:	685a      	ldr	r2, [r3, #4]
 8000848:	0691      	lsls	r1, r2, #26
 800084a:	d405      	bmi.n	8000858 <HAL_ADC_IRQHandler+0xbc>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOS))   )
 800084c:	681a      	ldr	r2, [r3, #0]
  if( (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC)) ||   
 800084e:	0652      	lsls	r2, r2, #25
 8000850:	d562      	bpl.n	8000918 <HAL_ADC_IRQHandler+0x17c>
      (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOS))   )
 8000852:	685a      	ldr	r2, [r3, #4]
 8000854:	0650      	lsls	r0, r2, #25
 8000856:	d55f      	bpl.n	8000918 <HAL_ADC_IRQHandler+0x17c>
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8000858:	6c62      	ldr	r2, [r4, #68]	; 0x44
    if (ADC_NONMULTIMODE_REG_OR_MULTIMODEMASTER(hadc))
 800085a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 800085e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000862:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_NONMULTIMODE_REG_OR_MULTIMODEMASTER(hadc))
 8000864:	d003      	beq.n	800086e <HAL_ADC_IRQHandler+0xd2>
 8000866:	4a7d      	ldr	r2, [pc, #500]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 8000868:	4293      	cmp	r3, r2
 800086a:	f040 8108 	bne.w	8000a7e <HAL_ADC_IRQHandler+0x2e2>
 800086e:	4a7c      	ldr	r2, [pc, #496]	; (8000a60 <HAL_ADC_IRQHandler+0x2c4>)
 8000870:	6891      	ldr	r1, [r2, #8]
 8000872:	06c9      	lsls	r1, r1, #27
 8000874:	d00c      	beq.n	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000876:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800087a:	d003      	beq.n	8000884 <HAL_ADC_IRQHandler+0xe8>
 800087c:	4977      	ldr	r1, [pc, #476]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 800087e:	428b      	cmp	r3, r1
 8000880:	f040 8102 	bne.w	8000a88 <HAL_ADC_IRQHandler+0x2ec>
 8000884:	6892      	ldr	r2, [r2, #8]
 8000886:	f002 021f 	and.w	r2, r2, #31
 800088a:	2a05      	cmp	r2, #5
 800088c:	f040 810e 	bne.w	8000aac <HAL_ADC_IRQHandler+0x310>
      tmp_cfgr = READ_REG(hadc->Instance->CFGR); 
 8000890:	68da      	ldr	r2, [r3, #12]
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                   ||
 8000892:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8000894:	f011 0fc0 	tst.w	r1, #192	; 0xc0
 8000898:	d007      	beq.n	80008aa <HAL_ADC_IRQHandler+0x10e>
 800089a:	0190      	lsls	r0, r2, #6
 800089c:	d436      	bmi.n	800090c <HAL_ADC_IRQHandler+0x170>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)          &&
 800089e:	68d9      	ldr	r1, [r3, #12]
       ((READ_BIT (tmp_cfgr, ADC_CFGR_JAUTO) == RESET)    &&
 80008a0:	f411 6f40 	tst.w	r1, #3072	; 0xc00
 80008a4:	d132      	bne.n	800090c <HAL_ADC_IRQHandler+0x170>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)          &&
 80008a6:	0491      	lsls	r1, r2, #18
 80008a8:	d430      	bmi.n	800090c <HAL_ADC_IRQHandler+0x170>
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 80008aa:	681a      	ldr	r2, [r3, #0]
 80008ac:	0652      	lsls	r2, r2, #25
 80008ae:	d52d      	bpl.n	800090c <HAL_ADC_IRQHandler+0x170>
        if (ADC_NONMULTIMODE_INJ_OR_MULTIMODEMASTER(hadc))
 80008b0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80008b4:	d003      	beq.n	80008be <HAL_ADC_IRQHandler+0x122>
 80008b6:	4a69      	ldr	r2, [pc, #420]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 80008b8:	4293      	cmp	r3, r2
 80008ba:	f040 8113 	bne.w	8000ae4 <HAL_ADC_IRQHandler+0x348>
 80008be:	4a68      	ldr	r2, [pc, #416]	; (8000a60 <HAL_ADC_IRQHandler+0x2c4>)
 80008c0:	6891      	ldr	r1, [r2, #8]
 80008c2:	06c8      	lsls	r0, r1, #27
 80008c4:	d00c      	beq.n	80008e0 <HAL_ADC_IRQHandler+0x144>
 80008c6:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80008ca:	d003      	beq.n	80008d4 <HAL_ADC_IRQHandler+0x138>
 80008cc:	4963      	ldr	r1, [pc, #396]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 80008ce:	428b      	cmp	r3, r1
 80008d0:	f040 810d 	bne.w	8000aee <HAL_ADC_IRQHandler+0x352>
 80008d4:	6892      	ldr	r2, [r2, #8]
 80008d6:	f002 021f 	and.w	r2, r2, #31
 80008da:	2a06      	cmp	r2, #6
 80008dc:	f040 8119 	bne.w	8000b12 <HAL_ADC_IRQHandler+0x376>
          tmp_cfgr_jqm = READ_REG(hadc->Instance->CFGR); 
 80008e0:	68da      	ldr	r2, [r3, #12]
        if(READ_BIT(tmp_cfgr_jqm, ADC_CFGR_JQM) == RESET)
 80008e2:	0292      	lsls	r2, r2, #10
 80008e4:	d412      	bmi.n	800090c <HAL_ADC_IRQHandler+0x170>
          if (ADC_IS_CONVERSION_ONGOING_INJECTED(hadc) == RESET)
 80008e6:	689a      	ldr	r2, [r3, #8]
 80008e8:	0710      	lsls	r0, r2, #28
 80008ea:	f100 812e 	bmi.w	8000b4a <HAL_ADC_IRQHandler+0x3ae>
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
 80008ee:	685a      	ldr	r2, [r3, #4]
 80008f0:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 80008f4:	605a      	str	r2, [r3, #4]
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 80008f6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80008f8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80008fc:	6463      	str	r3, [r4, #68]	; 0x44
            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 80008fe:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000900:	05d9      	lsls	r1, r3, #23
 8000902:	d403      	bmi.n	800090c <HAL_ADC_IRQHandler+0x170>
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000904:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000906:	f043 0301 	orr.w	r3, r3, #1
 800090a:	6463      	str	r3, [r4, #68]	; 0x44
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 800090c:	4620      	mov	r0, r4
 800090e:	f006 f82d 	bl	800696c <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
 8000912:	6823      	ldr	r3, [r4, #0]
 8000914:	2260      	movs	r2, #96	; 0x60
 8000916:	601a      	str	r2, [r3, #0]
  if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD1) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD1))
 8000918:	6823      	ldr	r3, [r4, #0]
 800091a:	681a      	ldr	r2, [r3, #0]
 800091c:	0612      	lsls	r2, r2, #24
 800091e:	d50c      	bpl.n	800093a <HAL_ADC_IRQHandler+0x19e>
 8000920:	685b      	ldr	r3, [r3, #4]
 8000922:	061b      	lsls	r3, r3, #24
 8000924:	d509      	bpl.n	800093a <HAL_ADC_IRQHandler+0x19e>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8000926:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000928:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800092c:	6463      	str	r3, [r4, #68]	; 0x44
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 800092e:	4620      	mov	r0, r4
 8000930:	f7ff fcd3 	bl	80002da <HAL_ADC_LevelOutOfWindowCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8000934:	6823      	ldr	r3, [r4, #0]
 8000936:	2280      	movs	r2, #128	; 0x80
 8000938:	601a      	str	r2, [r3, #0]
  if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD2) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD2))
 800093a:	6823      	ldr	r3, [r4, #0]
 800093c:	681a      	ldr	r2, [r3, #0]
 800093e:	05d0      	lsls	r0, r2, #23
 8000940:	d50d      	bpl.n	800095e <HAL_ADC_IRQHandler+0x1c2>
 8000942:	685b      	ldr	r3, [r3, #4]
 8000944:	05d9      	lsls	r1, r3, #23
 8000946:	d50a      	bpl.n	800095e <HAL_ADC_IRQHandler+0x1c2>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8000948:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800094a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800094e:	6463      	str	r3, [r4, #68]	; 0x44
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8000950:	4620      	mov	r0, r4
 8000952:	f7ff ff20 	bl	8000796 <HAL_ADCEx_LevelOutOfWindow2Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8000956:	6823      	ldr	r3, [r4, #0]
 8000958:	f44f 7280 	mov.w	r2, #256	; 0x100
 800095c:	601a      	str	r2, [r3, #0]
  if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD3) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD3)) 
 800095e:	6823      	ldr	r3, [r4, #0]
 8000960:	681a      	ldr	r2, [r3, #0]
 8000962:	0592      	lsls	r2, r2, #22
 8000964:	d50d      	bpl.n	8000982 <HAL_ADC_IRQHandler+0x1e6>
 8000966:	685b      	ldr	r3, [r3, #4]
 8000968:	0598      	lsls	r0, r3, #22
 800096a:	d50a      	bpl.n	8000982 <HAL_ADC_IRQHandler+0x1e6>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 800096c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800096e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000972:	6463      	str	r3, [r4, #68]	; 0x44
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8000974:	4620      	mov	r0, r4
 8000976:	f7ff ff0f 	bl	8000798 <HAL_ADCEx_LevelOutOfWindow3Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 800097a:	6823      	ldr	r3, [r4, #0]
 800097c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000980:	601a      	str	r2, [r3, #0]
  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR))
 8000982:	6822      	ldr	r2, [r4, #0]
 8000984:	6813      	ldr	r3, [r2, #0]
 8000986:	06d9      	lsls	r1, r3, #27
 8000988:	d51c      	bpl.n	80009c4 <HAL_ADC_IRQHandler+0x228>
 800098a:	6853      	ldr	r3, [r2, #4]
 800098c:	06db      	lsls	r3, r3, #27
 800098e:	d519      	bpl.n	80009c4 <HAL_ADC_IRQHandler+0x228>
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8000990:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000992:	2b01      	cmp	r3, #1
 8000994:	f000 80e8 	beq.w	8000b68 <HAL_ADC_IRQHandler+0x3cc>
      tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000998:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 800099c:	f000 80de 	beq.w	8000b5c <HAL_ADC_IRQHandler+0x3c0>
 80009a0:	492f      	ldr	r1, [pc, #188]	; (8000a60 <HAL_ADC_IRQHandler+0x2c4>)
 80009a2:	4b30      	ldr	r3, [pc, #192]	; (8000a64 <HAL_ADC_IRQHandler+0x2c8>)
 80009a4:	482d      	ldr	r0, [pc, #180]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 80009a6:	4282      	cmp	r2, r0
 80009a8:	bf08      	it	eq
 80009aa:	460b      	moveq	r3, r1
      if (READ_BIT(tmpADC_Common->CCR, ADC_CCR_MULTI) == ADC_MODE_INDEPENDENT)
 80009ac:	6899      	ldr	r1, [r3, #8]
 80009ae:	06c8      	lsls	r0, r1, #27
 80009b0:	f040 80d6 	bne.w	8000b60 <HAL_ADC_IRQHandler+0x3c4>
        if (HAL_IS_BIT_SET(hadc->Instance->CFGR, ADC_CFGR_DMAEN))
 80009b4:	68d3      	ldr	r3, [r2, #12]
 80009b6:	f013 0f01 	tst.w	r3, #1
        if (READ_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA) != RESET)
 80009ba:	f040 80d5 	bne.w	8000b68 <HAL_ADC_IRQHandler+0x3cc>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 80009be:	6823      	ldr	r3, [r4, #0]
 80009c0:	2210      	movs	r2, #16
 80009c2:	601a      	str	r2, [r3, #0]
  if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JQOVF) && __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JQOVF))
 80009c4:	6823      	ldr	r3, [r4, #0]
 80009c6:	681a      	ldr	r2, [r3, #0]
 80009c8:	0551      	lsls	r1, r2, #21
 80009ca:	f140 80d9 	bpl.w	8000b80 <HAL_ADC_IRQHandler+0x3e4>
 80009ce:	685a      	ldr	r2, [r3, #4]
 80009d0:	0552      	lsls	r2, r2, #21
 80009d2:	f140 80d5 	bpl.w	8000b80 <HAL_ADC_IRQHandler+0x3e4>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 80009d6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80009d8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80009dc:	6462      	str	r2, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 80009de:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80009e0:	f042 0208 	orr.w	r2, r2, #8
 80009e4:	64a2      	str	r2, [r4, #72]	; 0x48
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 80009e6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80009ea:	601a      	str	r2, [r3, #0]
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 80009ec:	4620      	mov	r0, r4
 80009ee:	f7ff fed1 	bl	8000794 <HAL_ADCEx_InjectedQueueOverflowCallback>
}
 80009f2:	bd10      	pop	{r4, pc}
    if (ADC_NONMULTIMODE_REG_OR_MULTIMODEMASTER(hadc))
 80009f4:	4a1b      	ldr	r2, [pc, #108]	; (8000a64 <HAL_ADC_IRQHandler+0x2c8>)
 80009f6:	6892      	ldr	r2, [r2, #8]
 80009f8:	06d2      	lsls	r2, r2, #27
 80009fa:	f43f aefd 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
 80009fe:	4a19      	ldr	r2, [pc, #100]	; (8000a64 <HAL_ADC_IRQHandler+0x2c8>)
 8000a00:	6892      	ldr	r2, [r2, #8]
 8000a02:	f002 021f 	and.w	r2, r2, #31
 8000a06:	2a05      	cmp	r2, #5
 8000a08:	f43f aef6 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
 8000a0c:	4a15      	ldr	r2, [pc, #84]	; (8000a64 <HAL_ADC_IRQHandler+0x2c8>)
 8000a0e:	6892      	ldr	r2, [r2, #8]
 8000a10:	f002 021f 	and.w	r2, r2, #31
 8000a14:	2a09      	cmp	r2, #9
 8000a16:	f43f aeef 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
 8000a1a:	4a13      	ldr	r2, [pc, #76]	; (8000a68 <HAL_ADC_IRQHandler+0x2cc>)
 8000a1c:	4293      	cmp	r3, r2
 8000a1e:	d11a      	bne.n	8000a56 <HAL_ADC_IRQHandler+0x2ba>
 8000a20:	e6ea      	b.n	80007f8 <HAL_ADC_IRQHandler+0x5c>
 8000a22:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000a26:	d002      	beq.n	8000a2e <HAL_ADC_IRQHandler+0x292>
 8000a28:	4a0c      	ldr	r2, [pc, #48]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 8000a2a:	4293      	cmp	r3, r2
 8000a2c:	d1ee      	bne.n	8000a0c <HAL_ADC_IRQHandler+0x270>
 8000a2e:	4a0c      	ldr	r2, [pc, #48]	; (8000a60 <HAL_ADC_IRQHandler+0x2c4>)
 8000a30:	6892      	ldr	r2, [r2, #8]
 8000a32:	f002 021f 	and.w	r2, r2, #31
 8000a36:	2a09      	cmp	r2, #9
 8000a38:	f43f aede 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
 8000a3c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000a40:	f43f aeda 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
 8000a44:	4a08      	ldr	r2, [pc, #32]	; (8000a68 <HAL_ADC_IRQHandler+0x2cc>)
 8000a46:	4293      	cmp	r3, r2
 8000a48:	f43f aed6 	beq.w	80007f8 <HAL_ADC_IRQHandler+0x5c>
      tmp_cfgr = READ_REG(ADC_MASTER_INSTANCE(hadc)->CFGR);
 8000a4c:	4903      	ldr	r1, [pc, #12]	; (8000a5c <HAL_ADC_IRQHandler+0x2c0>)
 8000a4e:	428b      	cmp	r3, r1
 8000a50:	bf08      	it	eq
 8000a52:	f04f 42a0 	moveq.w	r2, #1342177280	; 0x50000000
 8000a56:	68d2      	ldr	r2, [r2, #12]
 8000a58:	e6cf      	b.n	80007fa <HAL_ADC_IRQHandler+0x5e>
 8000a5a:	bf00      	nop
 8000a5c:	50000100 	.word	0x50000100
 8000a60:	50000300 	.word	0x50000300
 8000a64:	50000700 	.word	0x50000700
 8000a68:	50000400 	.word	0x50000400
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000a6c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000a6e:	f043 0310 	orr.w	r3, r3, #16
 8000a72:	6463      	str	r3, [r4, #68]	; 0x44
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000a74:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000a76:	f043 0301 	orr.w	r3, r3, #1
 8000a7a:	64a3      	str	r3, [r4, #72]	; 0x48
 8000a7c:	e6d9      	b.n	8000832 <HAL_ADC_IRQHandler+0x96>
    if (ADC_NONMULTIMODE_REG_OR_MULTIMODEMASTER(hadc))
 8000a7e:	4a41      	ldr	r2, [pc, #260]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000a80:	6892      	ldr	r2, [r2, #8]
 8000a82:	06d2      	lsls	r2, r2, #27
 8000a84:	f43f af04 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000a88:	4a3e      	ldr	r2, [pc, #248]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000a8a:	6892      	ldr	r2, [r2, #8]
 8000a8c:	f002 021f 	and.w	r2, r2, #31
 8000a90:	2a05      	cmp	r2, #5
 8000a92:	f43f aefd 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000a96:	4a3b      	ldr	r2, [pc, #236]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000a98:	6892      	ldr	r2, [r2, #8]
 8000a9a:	f002 021f 	and.w	r2, r2, #31
 8000a9e:	2a09      	cmp	r2, #9
 8000aa0:	f43f aef6 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000aa4:	4a38      	ldr	r2, [pc, #224]	; (8000b88 <HAL_ADC_IRQHandler+0x3ec>)
 8000aa6:	4293      	cmp	r3, r2
 8000aa8:	d11a      	bne.n	8000ae0 <HAL_ADC_IRQHandler+0x344>
 8000aaa:	e6f1      	b.n	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000aac:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000ab0:	d002      	beq.n	8000ab8 <HAL_ADC_IRQHandler+0x31c>
 8000ab2:	4a36      	ldr	r2, [pc, #216]	; (8000b8c <HAL_ADC_IRQHandler+0x3f0>)
 8000ab4:	4293      	cmp	r3, r2
 8000ab6:	d1ee      	bne.n	8000a96 <HAL_ADC_IRQHandler+0x2fa>
 8000ab8:	4a35      	ldr	r2, [pc, #212]	; (8000b90 <HAL_ADC_IRQHandler+0x3f4>)
 8000aba:	6892      	ldr	r2, [r2, #8]
 8000abc:	f002 021f 	and.w	r2, r2, #31
 8000ac0:	2a09      	cmp	r2, #9
 8000ac2:	f43f aee5 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000ac6:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000aca:	f43f aee1 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
 8000ace:	4a2e      	ldr	r2, [pc, #184]	; (8000b88 <HAL_ADC_IRQHandler+0x3ec>)
 8000ad0:	4293      	cmp	r3, r2
 8000ad2:	f43f aedd 	beq.w	8000890 <HAL_ADC_IRQHandler+0xf4>
      tmp_cfgr = READ_REG(ADC_MASTER_INSTANCE(hadc)->CFGR);
 8000ad6:	492d      	ldr	r1, [pc, #180]	; (8000b8c <HAL_ADC_IRQHandler+0x3f0>)
 8000ad8:	428b      	cmp	r3, r1
 8000ada:	bf08      	it	eq
 8000adc:	f04f 42a0 	moveq.w	r2, #1342177280	; 0x50000000
 8000ae0:	68d2      	ldr	r2, [r2, #12]
 8000ae2:	e6d6      	b.n	8000892 <HAL_ADC_IRQHandler+0xf6>
        if (ADC_NONMULTIMODE_INJ_OR_MULTIMODEMASTER(hadc))
 8000ae4:	4a27      	ldr	r2, [pc, #156]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000ae6:	6892      	ldr	r2, [r2, #8]
 8000ae8:	06d1      	lsls	r1, r2, #27
 8000aea:	f43f aef9 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000aee:	4a25      	ldr	r2, [pc, #148]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000af0:	6892      	ldr	r2, [r2, #8]
 8000af2:	f002 021f 	and.w	r2, r2, #31
 8000af6:	2a06      	cmp	r2, #6
 8000af8:	f43f aef2 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000afc:	4a21      	ldr	r2, [pc, #132]	; (8000b84 <HAL_ADC_IRQHandler+0x3e8>)
 8000afe:	6892      	ldr	r2, [r2, #8]
 8000b00:	f002 021f 	and.w	r2, r2, #31
 8000b04:	2a07      	cmp	r2, #7
 8000b06:	f43f aeeb 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000b0a:	4a1f      	ldr	r2, [pc, #124]	; (8000b88 <HAL_ADC_IRQHandler+0x3ec>)
 8000b0c:	4293      	cmp	r3, r2
 8000b0e:	d11a      	bne.n	8000b46 <HAL_ADC_IRQHandler+0x3aa>
 8000b10:	e6e6      	b.n	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000b12:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000b16:	d002      	beq.n	8000b1e <HAL_ADC_IRQHandler+0x382>
 8000b18:	4a1c      	ldr	r2, [pc, #112]	; (8000b8c <HAL_ADC_IRQHandler+0x3f0>)
 8000b1a:	4293      	cmp	r3, r2
 8000b1c:	d1ee      	bne.n	8000afc <HAL_ADC_IRQHandler+0x360>
 8000b1e:	4a1c      	ldr	r2, [pc, #112]	; (8000b90 <HAL_ADC_IRQHandler+0x3f4>)
 8000b20:	6892      	ldr	r2, [r2, #8]
 8000b22:	f002 021f 	and.w	r2, r2, #31
 8000b26:	2a07      	cmp	r2, #7
 8000b28:	f43f aeda 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000b2c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000b30:	f43f aed6 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
 8000b34:	4a14      	ldr	r2, [pc, #80]	; (8000b88 <HAL_ADC_IRQHandler+0x3ec>)
 8000b36:	4293      	cmp	r3, r2
 8000b38:	f43f aed2 	beq.w	80008e0 <HAL_ADC_IRQHandler+0x144>
          tmp_cfgr_jqm = READ_REG(ADC_MASTER_INSTANCE(hadc)->CFGR);
 8000b3c:	4913      	ldr	r1, [pc, #76]	; (8000b8c <HAL_ADC_IRQHandler+0x3f0>)
 8000b3e:	428b      	cmp	r3, r1
 8000b40:	bf08      	it	eq
 8000b42:	f04f 42a0 	moveq.w	r2, #1342177280	; 0x50000000
 8000b46:	68d2      	ldr	r2, [r2, #12]
 8000b48:	e6cb      	b.n	80008e2 <HAL_ADC_IRQHandler+0x146>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000b4a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000b4c:	f043 0310 	orr.w	r3, r3, #16
 8000b50:	6463      	str	r3, [r4, #68]	; 0x44
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000b52:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000b54:	f043 0301 	orr.w	r3, r3, #1
 8000b58:	64a3      	str	r3, [r4, #72]	; 0x48
 8000b5a:	e6d7      	b.n	800090c <HAL_ADC_IRQHandler+0x170>
      tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000b5c:	4b0c      	ldr	r3, [pc, #48]	; (8000b90 <HAL_ADC_IRQHandler+0x3f4>)
 8000b5e:	e725      	b.n	80009ac <HAL_ADC_IRQHandler+0x210>
        if (READ_BIT(tmpADC_Common->CCR, ADC_CCR_MDMA) != RESET)
 8000b60:	689b      	ldr	r3, [r3, #8]
 8000b62:	f413 4f40 	tst.w	r3, #49152	; 0xc000
 8000b66:	e728      	b.n	80009ba <HAL_ADC_IRQHandler+0x21e>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8000b68:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000b6a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000b6e:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8000b70:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000b72:	f043 0302 	orr.w	r3, r3, #2
 8000b76:	64a3      	str	r3, [r4, #72]	; 0x48
      HAL_ADC_ErrorCallback(hadc);
 8000b78:	4620      	mov	r0, r4
 8000b7a:	f7ff fbaf 	bl	80002dc <HAL_ADC_ErrorCallback>
 8000b7e:	e71e      	b.n	80009be <HAL_ADC_IRQHandler+0x222>
 8000b80:	bd10      	pop	{r4, pc}
 8000b82:	bf00      	nop
 8000b84:	50000700 	.word	0x50000700
 8000b88:	50000400 	.word	0x50000400
 8000b8c:	50000100 	.word	0x50000100
 8000b90:	50000300 	.word	0x50000300

08000b94 <HAL_ADC_ConfigChannel>:
{
 8000b94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b96:	b097      	sub	sp, #92	; 0x5c
  __IO uint32_t wait_loop_index = 0U;
 8000b98:	2300      	movs	r3, #0
 8000b9a:	9300      	str	r3, [sp, #0]
  __HAL_LOCK(hadc);
 8000b9c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8000ba0:	2b01      	cmp	r3, #1
{
 8000ba2:	4605      	mov	r5, r0
  __HAL_LOCK(hadc);
 8000ba4:	f000 8163 	beq.w	8000e6e <HAL_ADC_ConfigChannel+0x2da>
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000ba8:	682b      	ldr	r3, [r5, #0]
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8000baa:	68ce      	ldr	r6, [r1, #12]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000bac:	689a      	ldr	r2, [r3, #8]
  __HAL_LOCK(hadc);
 8000bae:	2001      	movs	r0, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000bb0:	0752      	lsls	r2, r2, #29
  __HAL_LOCK(hadc);
 8000bb2:	f885 0040 	strb.w	r0, [r5, #64]	; 0x40
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000bb6:	f100 8155 	bmi.w	8000e64 <HAL_ADC_ConfigChannel+0x2d0>
    if (sConfig->Rank < 5U)
 8000bba:	6848      	ldr	r0, [r1, #4]
 8000bbc:	680c      	ldr	r4, [r1, #0]
 8000bbe:	2804      	cmp	r0, #4
 8000bc0:	f04f 0206 	mov.w	r2, #6
 8000bc4:	d831      	bhi.n	8000c2a <HAL_ADC_ConfigChannel+0x96>
      MODIFY_REG(hadc->Instance->SQR1,
 8000bc6:	4342      	muls	r2, r0
 8000bc8:	6b1f      	ldr	r7, [r3, #48]	; 0x30
 8000bca:	201f      	movs	r0, #31
 8000bcc:	4090      	lsls	r0, r2
 8000bce:	ea27 0000 	bic.w	r0, r7, r0
 8000bd2:	fa04 f202 	lsl.w	r2, r4, r2
 8000bd6:	4302      	orrs	r2, r0
 8000bd8:	631a      	str	r2, [r3, #48]	; 0x30
  if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 8000bda:	689a      	ldr	r2, [r3, #8]
 8000bdc:	f012 0f0c 	tst.w	r2, #12
 8000be0:	d162      	bne.n	8000ca8 <HAL_ADC_ConfigChannel+0x114>
    if (sConfig->Channel >= ADC_CHANNEL_10)
 8000be2:	2c09      	cmp	r4, #9
 8000be4:	ea4f 0244 	mov.w	r2, r4, lsl #1
 8000be8:	688f      	ldr	r7, [r1, #8]
 8000bea:	d946      	bls.n	8000c7a <HAL_ADC_ConfigChannel+0xe6>
      MODIFY_REG(hadc->Instance->SMPR2                             ,
 8000bec:	4422      	add	r2, r4
 8000bee:	6998      	ldr	r0, [r3, #24]
 8000bf0:	3a1e      	subs	r2, #30
 8000bf2:	f04f 0e07 	mov.w	lr, #7
 8000bf6:	fa0e fe02 	lsl.w	lr, lr, r2
 8000bfa:	ea20 000e 	bic.w	r0, r0, lr
 8000bfe:	fa07 f202 	lsl.w	r2, r7, r2
 8000c02:	4302      	orrs	r2, r0
 8000c04:	619a      	str	r2, [r3, #24]
    tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 8000c06:	68da      	ldr	r2, [r3, #12]
 8000c08:	f3c2 0ec1 	ubfx	lr, r2, #3, #2
 8000c0c:	694a      	ldr	r2, [r1, #20]
 8000c0e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8000c12:	fa02 fe0e 	lsl.w	lr, r2, lr
    switch (sConfig->OffsetNumber)
 8000c16:	690a      	ldr	r2, [r1, #16]
 8000c18:	3a01      	subs	r2, #1
 8000c1a:	ea4f 6c84 	mov.w	ip, r4, lsl #26
 8000c1e:	2a03      	cmp	r2, #3
 8000c20:	d873      	bhi.n	8000d0a <HAL_ADC_ConfigChannel+0x176>
 8000c22:	e8df f002 	tbb	[pc, r2]
 8000c26:	5137      	.short	0x5137
 8000c28:	675c      	.short	0x675c
    else if (sConfig->Rank < 10U)
 8000c2a:	2809      	cmp	r0, #9
 8000c2c:	d80b      	bhi.n	8000c46 <HAL_ADC_ConfigChannel+0xb2>
      MODIFY_REG(hadc->Instance->SQR2,
 8000c2e:	4342      	muls	r2, r0
 8000c30:	6b5f      	ldr	r7, [r3, #52]	; 0x34
 8000c32:	3a1e      	subs	r2, #30
 8000c34:	201f      	movs	r0, #31
 8000c36:	4090      	lsls	r0, r2
 8000c38:	ea27 0000 	bic.w	r0, r7, r0
 8000c3c:	fa04 f202 	lsl.w	r2, r4, r2
 8000c40:	4302      	orrs	r2, r0
 8000c42:	635a      	str	r2, [r3, #52]	; 0x34
 8000c44:	e7c9      	b.n	8000bda <HAL_ADC_ConfigChannel+0x46>
    else if (sConfig->Rank < 15U)
 8000c46:	280e      	cmp	r0, #14
 8000c48:	d80b      	bhi.n	8000c62 <HAL_ADC_ConfigChannel+0xce>
      MODIFY_REG(hadc->Instance->SQR3                        ,
 8000c4a:	4342      	muls	r2, r0
 8000c4c:	6b9f      	ldr	r7, [r3, #56]	; 0x38
 8000c4e:	3a3c      	subs	r2, #60	; 0x3c
 8000c50:	201f      	movs	r0, #31
 8000c52:	4090      	lsls	r0, r2
 8000c54:	ea27 0000 	bic.w	r0, r7, r0
 8000c58:	fa04 f202 	lsl.w	r2, r4, r2
 8000c5c:	4302      	orrs	r2, r0
 8000c5e:	639a      	str	r2, [r3, #56]	; 0x38
 8000c60:	e7bb      	b.n	8000bda <HAL_ADC_ConfigChannel+0x46>
      MODIFY_REG(hadc->Instance->SQR4                        ,
 8000c62:	4342      	muls	r2, r0
 8000c64:	6bdf      	ldr	r7, [r3, #60]	; 0x3c
 8000c66:	3a5a      	subs	r2, #90	; 0x5a
 8000c68:	201f      	movs	r0, #31
 8000c6a:	4090      	lsls	r0, r2
 8000c6c:	ea27 0000 	bic.w	r0, r7, r0
 8000c70:	fa04 f202 	lsl.w	r2, r4, r2
 8000c74:	4302      	orrs	r2, r0
 8000c76:	63da      	str	r2, [r3, #60]	; 0x3c
 8000c78:	e7af      	b.n	8000bda <HAL_ADC_ConfigChannel+0x46>
      MODIFY_REG(hadc->Instance->SMPR1                             ,
 8000c7a:	6958      	ldr	r0, [r3, #20]
 8000c7c:	4422      	add	r2, r4
 8000c7e:	f04f 0e07 	mov.w	lr, #7
 8000c82:	fa0e fe02 	lsl.w	lr, lr, r2
 8000c86:	ea20 000e 	bic.w	r0, r0, lr
 8000c8a:	fa07 f202 	lsl.w	r2, r7, r2
 8000c8e:	4302      	orrs	r2, r0
 8000c90:	615a      	str	r2, [r3, #20]
 8000c92:	e7b8      	b.n	8000c06 <HAL_ADC_ConfigChannel+0x72>
      MODIFY_REG(hadc->Instance->OFR1               ,
 8000c94:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000c96:	4f83      	ldr	r7, [pc, #524]	; (8000ea4 <HAL_ADC_ConfigChannel+0x310>)
 8000c98:	4017      	ands	r7, r2
 8000c9a:	ea47 020c 	orr.w	r2, r7, ip
 8000c9e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000ca2:	ea42 020e 	orr.w	r2, r2, lr
 8000ca6:	661a      	str	r2, [r3, #96]	; 0x60
  if (ADC_IS_ENABLE(hadc) == RESET)
 8000ca8:	689a      	ldr	r2, [r3, #8]
 8000caa:	f002 0203 	and.w	r2, r2, #3
 8000cae:	2a01      	cmp	r2, #1
 8000cb0:	f040 80df 	bne.w	8000e72 <HAL_ADC_ConfigChannel+0x2de>
 8000cb4:	681a      	ldr	r2, [r3, #0]
 8000cb6:	07d7      	lsls	r7, r2, #31
 8000cb8:	f140 80db 	bpl.w	8000e72 <HAL_ADC_ConfigChannel+0x2de>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000cbc:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 8000cbe:	2300      	movs	r3, #0
 8000cc0:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
}
 8000cc4:	b017      	add	sp, #92	; 0x5c
 8000cc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      MODIFY_REG(hadc->Instance->OFR2               ,
 8000cc8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8000cca:	4f76      	ldr	r7, [pc, #472]	; (8000ea4 <HAL_ADC_ConfigChannel+0x310>)
 8000ccc:	4017      	ands	r7, r2
 8000cce:	ea47 020c 	orr.w	r2, r7, ip
 8000cd2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000cd6:	ea42 020e 	orr.w	r2, r2, lr
 8000cda:	665a      	str	r2, [r3, #100]	; 0x64
      break;
 8000cdc:	e7e4      	b.n	8000ca8 <HAL_ADC_ConfigChannel+0x114>
      MODIFY_REG(hadc->Instance->OFR3               ,
 8000cde:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8000ce0:	4870      	ldr	r0, [pc, #448]	; (8000ea4 <HAL_ADC_ConfigChannel+0x310>)
 8000ce2:	4010      	ands	r0, r2
 8000ce4:	ea40 020c 	orr.w	r2, r0, ip
 8000ce8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000cec:	ea42 020e 	orr.w	r2, r2, lr
 8000cf0:	669a      	str	r2, [r3, #104]	; 0x68
      break;
 8000cf2:	e7d9      	b.n	8000ca8 <HAL_ADC_ConfigChannel+0x114>
      MODIFY_REG(hadc->Instance->OFR4               ,
 8000cf4:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8000cf6:	4a6b      	ldr	r2, [pc, #428]	; (8000ea4 <HAL_ADC_ConfigChannel+0x310>)
 8000cf8:	4002      	ands	r2, r0
 8000cfa:	ea42 020c 	orr.w	r2, r2, ip
 8000cfe:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8000d02:	ea42 020e 	orr.w	r2, r2, lr
        CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_OFFSET4_EN);
 8000d06:	66da      	str	r2, [r3, #108]	; 0x6c
 8000d08:	e7ce      	b.n	8000ca8 <HAL_ADC_ConfigChannel+0x114>
      if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8000d0a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000d0c:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 8000d10:	4562      	cmp	r2, ip
        CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_OFFSET1_EN);
 8000d12:	bf02      	ittt	eq
 8000d14:	6e1a      	ldreq	r2, [r3, #96]	; 0x60
 8000d16:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 8000d1a:	661a      	streq	r2, [r3, #96]	; 0x60
      if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8000d1c:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8000d1e:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 8000d22:	4594      	cmp	ip, r2
        CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_OFFSET2_EN); 
 8000d24:	bf02      	ittt	eq
 8000d26:	6e5a      	ldreq	r2, [r3, #100]	; 0x64
 8000d28:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 8000d2c:	665a      	streq	r2, [r3, #100]	; 0x64
      if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8000d2e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8000d30:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 8000d34:	4594      	cmp	ip, r2
        CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_OFFSET3_EN);
 8000d36:	bf02      	ittt	eq
 8000d38:	6e9a      	ldreq	r2, [r3, #104]	; 0x68
 8000d3a:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 8000d3e:	669a      	streq	r2, [r3, #104]	; 0x68
      if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8000d40:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8000d42:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 8000d46:	4594      	cmp	ip, r2
 8000d48:	d1ae      	bne.n	8000ca8 <HAL_ADC_ConfigChannel+0x114>
        CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_OFFSET4_EN);
 8000d4a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8000d4c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8000d50:	e7d9      	b.n	8000d06 <HAL_ADC_ConfigChannel+0x172>
      CLEAR_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_CHANNEL(sConfig->Channel));
 8000d52:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 8000d56:	2101      	movs	r1, #1
 8000d58:	40a1      	lsls	r1, r4
 8000d5a:	ea22 0201 	bic.w	r2, r2, r1
 8000d5e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000d62:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000d66:	d01e      	beq.n	8000da6 <HAL_ADC_ConfigChannel+0x212>
 8000d68:	494f      	ldr	r1, [pc, #316]	; (8000ea8 <HAL_ADC_ConfigChannel+0x314>)
 8000d6a:	4a50      	ldr	r2, [pc, #320]	; (8000eac <HAL_ADC_ConfigChannel+0x318>)
 8000d6c:	4850      	ldr	r0, [pc, #320]	; (8000eb0 <HAL_ADC_ConfigChannel+0x31c>)
 8000d6e:	4283      	cmp	r3, r0
 8000d70:	bf08      	it	eq
 8000d72:	460a      	moveq	r2, r1
    if (( (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8000d74:	2c10      	cmp	r4, #16
 8000d76:	d118      	bne.n	8000daa <HAL_ADC_ConfigChannel+0x216>
          (HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_TSEN))            ) ||
 8000d78:	6891      	ldr	r1, [r2, #8]
    if (( (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8000d7a:	f411 0f00 	tst.w	r1, #8388608	; 0x800000
        ( (sConfig->Channel == ADC_CHANNEL_VREFINT)    &&
 8000d7e:	d19d      	bne.n	8000cbc <HAL_ADC_ConfigChannel+0x128>
      ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 8000d80:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000d84:	494a      	ldr	r1, [pc, #296]	; (8000eb0 <HAL_ADC_ConfigChannel+0x31c>)
 8000d86:	d11c      	bne.n	8000dc2 <HAL_ADC_ConfigChannel+0x22e>
 8000d88:	9101      	str	r1, [sp, #4]
 8000d8a:	e024      	b.n	8000dd6 <HAL_ADC_ConfigChannel+0x242>
        MODIFY_REG(hadc->Instance->SMPR1,
 8000d8c:	1c60      	adds	r0, r4, #1
 8000d8e:	6959      	ldr	r1, [r3, #20]
 8000d90:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8000d94:	2207      	movs	r2, #7
 8000d96:	4082      	lsls	r2, r0
 8000d98:	ea21 0102 	bic.w	r1, r1, r2
 8000d9c:	fa06 f200 	lsl.w	r2, r6, r0
 8000da0:	430a      	orrs	r2, r1
 8000da2:	615a      	str	r2, [r3, #20]
 8000da4:	e7dd      	b.n	8000d62 <HAL_ADC_ConfigChannel+0x1ce>
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);
 8000da6:	4a40      	ldr	r2, [pc, #256]	; (8000ea8 <HAL_ADC_ConfigChannel+0x314>)
 8000da8:	e7e4      	b.n	8000d74 <HAL_ADC_ConfigChannel+0x1e0>
          (HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_TSEN))            ) ||
 8000daa:	2c11      	cmp	r4, #17
 8000dac:	d103      	bne.n	8000db6 <HAL_ADC_ConfigChannel+0x222>
          (HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_VBATEN))          ) ||
 8000dae:	6891      	ldr	r1, [r2, #8]
        ( (sConfig->Channel == ADC_CHANNEL_VBAT)       &&
 8000db0:	f011 7f80 	tst.w	r1, #16777216	; 0x1000000
 8000db4:	e7e3      	b.n	8000d7e <HAL_ADC_ConfigChannel+0x1ea>
          (HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_VBATEN))          ) ||
 8000db6:	2c12      	cmp	r4, #18
 8000db8:	d180      	bne.n	8000cbc <HAL_ADC_ConfigChannel+0x128>
          (HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_VREFEN)))
 8000dba:	6891      	ldr	r1, [r2, #8]
        ( (sConfig->Channel == ADC_CHANNEL_VREFINT)    &&
 8000dbc:	f411 0f80 	tst.w	r1, #4194304	; 0x400000
 8000dc0:	e7dd      	b.n	8000d7e <HAL_ADC_ConfigChannel+0x1ea>
      ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 8000dc2:	428b      	cmp	r3, r1
 8000dc4:	d102      	bne.n	8000dcc <HAL_ADC_ConfigChannel+0x238>
 8000dc6:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
 8000dca:	e7dd      	b.n	8000d88 <HAL_ADC_ConfigChannel+0x1f4>
 8000dcc:	4939      	ldr	r1, [pc, #228]	; (8000eb4 <HAL_ADC_ConfigChannel+0x320>)
 8000dce:	483a      	ldr	r0, [pc, #232]	; (8000eb8 <HAL_ADC_ConfigChannel+0x324>)
 8000dd0:	428b      	cmp	r3, r1
 8000dd2:	d12b      	bne.n	8000e2c <HAL_ADC_ConfigChannel+0x298>
 8000dd4:	9001      	str	r0, [sp, #4]
      if ((ADC_IS_ENABLE(hadc) == RESET)                                    &&
 8000dd6:	6899      	ldr	r1, [r3, #8]
 8000dd8:	f001 0103 	and.w	r1, r1, #3
 8000ddc:	2901      	cmp	r1, #1
 8000dde:	d102      	bne.n	8000de6 <HAL_ADC_ConfigChannel+0x252>
 8000de0:	6819      	ldr	r1, [r3, #0]
 8000de2:	07c8      	lsls	r0, r1, #31
 8000de4:	d438      	bmi.n	8000e58 <HAL_ADC_ConfigChannel+0x2c4>
          ( (tmphadcSharingSameCommonRegister.Instance == NULL)         ||
 8000de6:	9901      	ldr	r1, [sp, #4]
      if ((ADC_IS_ENABLE(hadc) == RESET)                                    &&
 8000de8:	b139      	cbz	r1, 8000dfa <HAL_ADC_ConfigChannel+0x266>
            (ADC_IS_ENABLE(&tmphadcSharingSameCommonRegister) == RESET)   )   )
 8000dea:	6888      	ldr	r0, [r1, #8]
 8000dec:	f000 0003 	and.w	r0, r0, #3
 8000df0:	2801      	cmp	r0, #1
 8000df2:	d102      	bne.n	8000dfa <HAL_ADC_ConfigChannel+0x266>
 8000df4:	6809      	ldr	r1, [r1, #0]
 8000df6:	07c9      	lsls	r1, r1, #31
 8000df8:	d42e      	bmi.n	8000e58 <HAL_ADC_ConfigChannel+0x2c4>
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && (hadc->Instance == ADC1))
 8000dfa:	2c10      	cmp	r4, #16
 8000dfc:	d11a      	bne.n	8000e34 <HAL_ADC_ConfigChannel+0x2a0>
 8000dfe:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000e02:	f47f af5b 	bne.w	8000cbc <HAL_ADC_ConfigChannel+0x128>
          SET_BIT(tmpADC_Common->CCR, ADC_CCR_TSEN);
 8000e06:	6893      	ldr	r3, [r2, #8]
 8000e08:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000e0c:	6093      	str	r3, [r2, #8]
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8000e0e:	4b2b      	ldr	r3, [pc, #172]	; (8000ebc <HAL_ADC_ConfigChannel+0x328>)
 8000e10:	4a2b      	ldr	r2, [pc, #172]	; (8000ec0 <HAL_ADC_ConfigChannel+0x32c>)
 8000e12:	681b      	ldr	r3, [r3, #0]
 8000e14:	fbb3 f2f2 	udiv	r2, r3, r2
 8000e18:	230a      	movs	r3, #10
 8000e1a:	4353      	muls	r3, r2
            wait_loop_index--;
 8000e1c:	9300      	str	r3, [sp, #0]
          while(wait_loop_index != 0U)
 8000e1e:	9b00      	ldr	r3, [sp, #0]
 8000e20:	2b00      	cmp	r3, #0
 8000e22:	f43f af4b 	beq.w	8000cbc <HAL_ADC_ConfigChannel+0x128>
            wait_loop_index--;
 8000e26:	9b00      	ldr	r3, [sp, #0]
 8000e28:	3b01      	subs	r3, #1
 8000e2a:	e7f7      	b.n	8000e1c <HAL_ADC_ConfigChannel+0x288>
      ADC_COMMON_ADC_OTHER(hadc, &tmphadcSharingSameCommonRegister);
 8000e2c:	4283      	cmp	r3, r0
 8000e2e:	bf18      	it	ne
 8000e30:	2100      	movne	r1, #0
 8000e32:	e7a9      	b.n	8000d88 <HAL_ADC_ConfigChannel+0x1f4>
        else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && (hadc->Instance == ADC1))
 8000e34:	2c11      	cmp	r4, #17
 8000e36:	d108      	bne.n	8000e4a <HAL_ADC_ConfigChannel+0x2b6>
 8000e38:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8000e3c:	f47f af3e 	bne.w	8000cbc <HAL_ADC_ConfigChannel+0x128>
          SET_BIT(tmpADC_Common->CCR, ADC_CCR_VBATEN);
 8000e40:	6893      	ldr	r3, [r2, #8]
 8000e42:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
          SET_BIT(tmpADC_Common->CCR, ADC_CCR_VREFEN);
 8000e46:	6093      	str	r3, [r2, #8]
 8000e48:	e738      	b.n	8000cbc <HAL_ADC_ConfigChannel+0x128>
        else if (sConfig->Channel == ADC_CHANNEL_VREFINT)
 8000e4a:	2c12      	cmp	r4, #18
 8000e4c:	f47f af36 	bne.w	8000cbc <HAL_ADC_ConfigChannel+0x128>
          SET_BIT(tmpADC_Common->CCR, ADC_CCR_VREFEN);
 8000e50:	6893      	ldr	r3, [r2, #8]
 8000e52:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000e56:	e7f6      	b.n	8000e46 <HAL_ADC_ConfigChannel+0x2b2>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8000e58:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8000e5a:	f043 0320 	orr.w	r3, r3, #32
 8000e5e:	646b      	str	r3, [r5, #68]	; 0x44
        tmp_hal_status = HAL_ERROR;
 8000e60:	2001      	movs	r0, #1
 8000e62:	e72c      	b.n	8000cbe <HAL_ADC_ConfigChannel+0x12a>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8000e64:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8000e66:	f043 0320 	orr.w	r3, r3, #32
 8000e6a:	646b      	str	r3, [r5, #68]	; 0x44
 8000e6c:	e727      	b.n	8000cbe <HAL_ADC_ConfigChannel+0x12a>
  __HAL_LOCK(hadc);
 8000e6e:	2002      	movs	r0, #2
 8000e70:	e728      	b.n	8000cc4 <HAL_ADC_ConfigChannel+0x130>
    if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8000e72:	2e01      	cmp	r6, #1
 8000e74:	f47f af6d 	bne.w	8000d52 <HAL_ADC_ConfigChannel+0x1be>
      SET_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_CHANNEL(sConfig->Channel));
 8000e78:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 8000e7c:	40a6      	lsls	r6, r4
 8000e7e:	4316      	orrs	r6, r2
      if (sConfig->Channel >= ADC_CHANNEL_10)
 8000e80:	2c09      	cmp	r4, #9
      SET_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_CHANNEL(sConfig->Channel));
 8000e82:	f8c3 60b0 	str.w	r6, [r3, #176]	; 0xb0
 8000e86:	688e      	ldr	r6, [r1, #8]
      if (sConfig->Channel >= ADC_CHANNEL_10)
 8000e88:	d980      	bls.n	8000d8c <HAL_ADC_ConfigChannel+0x1f8>
        MODIFY_REG(hadc->Instance->SMPR2,
 8000e8a:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 8000e8e:	6999      	ldr	r1, [r3, #24]
 8000e90:	3a1b      	subs	r2, #27
 8000e92:	2007      	movs	r0, #7
 8000e94:	4090      	lsls	r0, r2
 8000e96:	ea21 0100 	bic.w	r1, r1, r0
 8000e9a:	fa06 f202 	lsl.w	r2, r6, r2
 8000e9e:	430a      	orrs	r2, r1
 8000ea0:	619a      	str	r2, [r3, #24]
 8000ea2:	e75e      	b.n	8000d62 <HAL_ADC_ConfigChannel+0x1ce>
 8000ea4:	83fff000 	.word	0x83fff000
 8000ea8:	50000300 	.word	0x50000300
 8000eac:	50000700 	.word	0x50000700
 8000eb0:	50000100 	.word	0x50000100
 8000eb4:	50000400 	.word	0x50000400
 8000eb8:	50000500 	.word	0x50000500
 8000ebc:	20000120 	.word	0x20000120
 8000ec0:	000f4240 	.word	0x000f4240

08000ec4 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000ec4:	4a07      	ldr	r2, [pc, #28]	; (8000ee4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000ec6:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000ec8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000ecc:	041b      	lsls	r3, r3, #16
 8000ece:	0c1b      	lsrs	r3, r3, #16
 8000ed0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000ed4:	0200      	lsls	r0, r0, #8
 8000ed6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000eda:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8000ede:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000ee0:	60d3      	str	r3, [r2, #12]
 8000ee2:	4770      	bx	lr
 8000ee4:	e000ed00 	.word	0xe000ed00

08000ee8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000ee8:	4b17      	ldr	r3, [pc, #92]	; (8000f48 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15 as described in the table CORTEX_NVIC_Priority_Table
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000eea:	b530      	push	{r4, r5, lr}
 8000eec:	68dc      	ldr	r4, [r3, #12]
 8000eee:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000ef2:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000ef6:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000ef8:	2b04      	cmp	r3, #4
 8000efa:	bf28      	it	cs
 8000efc:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000efe:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f00:	f04f 0501 	mov.w	r5, #1
 8000f04:	fa05 f303 	lsl.w	r3, r5, r3
 8000f08:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000f0c:	bf8c      	ite	hi
 8000f0e:	3c03      	subhi	r4, #3
 8000f10:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f12:	4019      	ands	r1, r3
 8000f14:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000f16:	fa05 f404 	lsl.w	r4, r5, r4
 8000f1a:	3c01      	subs	r4, #1
 8000f1c:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8000f1e:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000f20:	ea42 0201 	orr.w	r2, r2, r1
 8000f24:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f28:	bfaf      	iteee	ge
 8000f2a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f2e:	f000 000f 	andlt.w	r0, r0, #15
 8000f32:	4b06      	ldrlt	r3, [pc, #24]	; (8000f4c <HAL_NVIC_SetPriority+0x64>)
 8000f34:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f36:	bfa5      	ittet	ge
 8000f38:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8000f3c:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f3e:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f40:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000f44:	bd30      	pop	{r4, r5, pc}
 8000f46:	bf00      	nop
 8000f48:	e000ed00 	.word	0xe000ed00
 8000f4c:	e000ed14 	.word	0xe000ed14

08000f50 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8000f50:	0942      	lsrs	r2, r0, #5
 8000f52:	2301      	movs	r3, #1
 8000f54:	f000 001f 	and.w	r0, r0, #31
 8000f58:	fa03 f000 	lsl.w	r0, r3, r0
 8000f5c:	4b01      	ldr	r3, [pc, #4]	; (8000f64 <HAL_NVIC_EnableIRQ+0x14>)
 8000f5e:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8000f62:	4770      	bx	lr
 8000f64:	e000e100 	.word	0xe000e100

08000f68 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000f68:	3801      	subs	r0, #1
 8000f6a:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000f6e:	d20a      	bcs.n	8000f86 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000f70:	4b06      	ldr	r3, [pc, #24]	; (8000f8c <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f72:	4a07      	ldr	r2, [pc, #28]	; (8000f90 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000f74:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000f76:	21f0      	movs	r1, #240	; 0xf0
 8000f78:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000f7c:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f7e:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000f80:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000f82:	601a      	str	r2, [r3, #0]
 8000f84:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000f86:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	e000e010 	.word	0xe000e010
 8000f90:	e000ed00 	.word	0xe000ed00

08000f94 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000f94:	4b04      	ldr	r3, [pc, #16]	; (8000fa8 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000f96:	681a      	ldr	r2, [r3, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000f98:	2804      	cmp	r0, #4
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000f9a:	bf0c      	ite	eq
 8000f9c:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000fa0:	f022 0204 	bicne.w	r2, r2, #4
 8000fa4:	601a      	str	r2, [r3, #0]
 8000fa6:	4770      	bx	lr
 8000fa8:	e000e010 	.word	0xe000e010

08000fac <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and initialize the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8000fac:	b510      	push	{r4, lr}
  /* Check the CRC handle allocation */
  if(hcrc == NULL)
 8000fae:	4604      	mov	r4, r0
 8000fb0:	b908      	cbnz	r0, 8000fb6 <HAL_CRC_Init+0xa>
  {
    return HAL_ERROR;
 8000fb2:	2001      	movs	r0, #1
 8000fb4:	bd10      	pop	{r4, pc}
  }
  
  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if(hcrc->State == HAL_CRC_STATE_RESET)
 8000fb6:	7f43      	ldrb	r3, [r0, #29]
 8000fb8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000fbc:	b913      	cbnz	r3, 8000fc4 <HAL_CRC_Init+0x18>
  {   
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8000fbe:	7702      	strb	r2, [r0, #28]

    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8000fc0:	f005 fc14 	bl	80067ec <HAL_CRC_MspInit>
  }
  
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8000fc4:	2302      	movs	r3, #2
 8000fc6:	7763      	strb	r3, [r4, #29]
  
  /* check whether or not non-default generating polynomial has been 
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse)); 
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8000fc8:	7923      	ldrb	r3, [r4, #4]
 8000fca:	b9e3      	cbnz	r3, 8001006 <HAL_CRC_Init+0x5a>
  {
    /* initialize IP with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8000fcc:	6823      	ldr	r3, [r4, #0]
 8000fce:	4a13      	ldr	r2, [pc, #76]	; (800101c <HAL_CRC_Init+0x70>)
 8000fd0:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8000fd2:	689a      	ldr	r2, [r3, #8]
 8000fd4:	f022 0218 	bic.w	r2, r2, #24
 8000fd8:	609a      	str	r2, [r3, #8]
  }
  
  /* check whether or not non-default CRC initial value has been 
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8000fda:	7962      	ldrb	r2, [r4, #5]
 8000fdc:	6823      	ldr	r3, [r4, #0]
 8000fde:	b9d2      	cbnz	r2, 8001016 <HAL_CRC_Init+0x6a>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 8000fe0:	f04f 32ff 	mov.w	r2, #4294967295
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8000fe4:	611a      	str	r2, [r3, #16]
  }
  

  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode)); 
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 8000fe6:	689a      	ldr	r2, [r3, #8]
 8000fe8:	6961      	ldr	r1, [r4, #20]
 8000fea:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8000fee:	430a      	orrs	r2, r1
 8000ff0:	609a      	str	r2, [r3, #8]
  
  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode)); 
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 8000ff2:	689a      	ldr	r2, [r3, #8]
 8000ff4:	69a1      	ldr	r1, [r4, #24]
 8000ff6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000ffa:	430a      	orrs	r2, r1
 8000ffc:	609a      	str	r2, [r3, #8]
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8000ffe:	2301      	movs	r3, #1
 8001000:	7763      	strb	r3, [r4, #29]
  
  /* Return function status */
  return HAL_OK;
 8001002:	2000      	movs	r0, #0
}
 8001004:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8001006:	68e2      	ldr	r2, [r4, #12]
 8001008:	68a1      	ldr	r1, [r4, #8]
 800100a:	4620      	mov	r0, r4
 800100c:	f000 f808 	bl	8001020 <HAL_CRCEx_Polynomial_Set>
 8001010:	2800      	cmp	r0, #0
 8001012:	d0e2      	beq.n	8000fda <HAL_CRC_Init+0x2e>
 8001014:	e7cd      	b.n	8000fb2 <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8001016:	6922      	ldr	r2, [r4, #16]
 8001018:	e7e4      	b.n	8000fe4 <HAL_CRC_Init+0x38>
 800101a:	bf00      	nop
 800101c:	04c11db7 	.word	0x04c11db7

08001020 <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 8001020:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 8001022:	231f      	movs	r3, #31
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0U) && (msb-- > 0U)){}
 8001024:	2401      	movs	r4, #1
 8001026:	fa04 f503 	lsl.w	r5, r4, r3
 800102a:	420d      	tst	r5, r1
 800102c:	d10a      	bne.n	8001044 <HAL_CRCEx_Polynomial_Set+0x24>
 800102e:	f113 33ff 	adds.w	r3, r3, #4294967295
 8001032:	d2f8      	bcs.n	8001026 <HAL_CRCEx_Polynomial_Set+0x6>

  switch (PolyLength)
 8001034:	2a10      	cmp	r2, #16
 8001036:	d003      	beq.n	8001040 <HAL_CRCEx_Polynomial_Set+0x20>
 8001038:	2a18      	cmp	r2, #24
 800103a:	d001      	beq.n	8001040 <HAL_CRCEx_Polynomial_Set+0x20>
 800103c:	2a08      	cmp	r2, #8
 800103e:	d10b      	bne.n	8001058 <HAL_CRCEx_Polynomial_Set+0x38>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B) 
      {
        return  HAL_ERROR;
 8001040:	2001      	movs	r0, #1
 8001042:	bd30      	pop	{r4, r5, pc}
  switch (PolyLength)
 8001044:	2a10      	cmp	r2, #16
 8001046:	d010      	beq.n	800106a <HAL_CRCEx_Polynomial_Set+0x4a>
 8001048:	2a18      	cmp	r2, #24
 800104a:	d003      	beq.n	8001054 <HAL_CRCEx_Polynomial_Set+0x34>
 800104c:	2a08      	cmp	r2, #8
 800104e:	d103      	bne.n	8001058 <HAL_CRCEx_Polynomial_Set+0x38>
      {
        return  HAL_ERROR;
      }      
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 8001050:	2b0f      	cmp	r3, #15
 8001052:	e000      	b.n	8001056 <HAL_CRCEx_Polynomial_Set+0x36>
      if (msb >= HAL_CRC_LENGTH_7B) 
 8001054:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 8001056:	d8f3      	bhi.n	8001040 <HAL_CRCEx_Polynomial_Set+0x20>
    default:
      break;                  
  }

  /* set generating polynomial */
  WRITE_REG(hcrc->Instance->POL, Pol);
 8001058:	6800      	ldr	r0, [r0, #0]
 800105a:	6141      	str	r1, [r0, #20]
  
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 800105c:	6883      	ldr	r3, [r0, #8]
 800105e:	f023 0318 	bic.w	r3, r3, #24
 8001062:	431a      	orrs	r2, r3
 8001064:	6082      	str	r2, [r0, #8]
  
  /* Return function status */
  return HAL_OK;
 8001066:	2000      	movs	r0, #0
 8001068:	bd30      	pop	{r4, r5, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 800106a:	2b07      	cmp	r3, #7
 800106c:	e7f3      	b.n	8001056 <HAL_CRCEx_Polynomial_Set+0x36>
	...

08001070 <DMA_CalcBaseAndBitshift>:
  */
static void DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
#if defined (DMA2)
  /* calculation of the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8001070:	6801      	ldr	r1, [r0, #0]
 8001072:	4b0c      	ldr	r3, [pc, #48]	; (80010a4 <DMA_CalcBaseAndBitshift+0x34>)
 8001074:	4299      	cmp	r1, r3
{
 8001076:	b510      	push	{r4, lr}
 8001078:	f04f 0414 	mov.w	r4, #20
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800107c:	d809      	bhi.n	8001092 <DMA_CalcBaseAndBitshift+0x22>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800107e:	4a0a      	ldr	r2, [pc, #40]	; (80010a8 <DMA_CalcBaseAndBitshift+0x38>)
 8001080:	440a      	add	r2, r1
 8001082:	fbb2 f2f4 	udiv	r2, r2, r4
 8001086:	0092      	lsls	r2, r2, #2
 8001088:	6402      	str	r2, [r0, #64]	; 0x40
    hdma->DmaBaseAddress = DMA1;
 800108a:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
  }
  else 
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
    hdma->DmaBaseAddress = DMA2;
 800108e:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001090:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8001092:	4b06      	ldr	r3, [pc, #24]	; (80010ac <DMA_CalcBaseAndBitshift+0x3c>)
 8001094:	440b      	add	r3, r1
 8001096:	fbb3 f3f4 	udiv	r3, r3, r4
 800109a:	009b      	lsls	r3, r3, #2
 800109c:	6403      	str	r3, [r0, #64]	; 0x40
    hdma->DmaBaseAddress = DMA2;
 800109e:	4b04      	ldr	r3, [pc, #16]	; (80010b0 <DMA_CalcBaseAndBitshift+0x40>)
 80010a0:	e7f5      	b.n	800108e <DMA_CalcBaseAndBitshift+0x1e>
 80010a2:	bf00      	nop
 80010a4:	40020407 	.word	0x40020407
 80010a8:	bffdfff8 	.word	0xbffdfff8
 80010ac:	bffdfbf8 	.word	0xbffdfbf8
 80010b0:	40020400 	.word	0x40020400

080010b4 <HAL_DMA_Init>:
{ 
 80010b4:	b538      	push	{r3, r4, r5, lr}
  if(NULL == hdma)
 80010b6:	4604      	mov	r4, r0
 80010b8:	b328      	cbz	r0, 8001106 <HAL_DMA_Init+0x52>
  hdma->State = HAL_DMA_STATE_BUSY;
 80010ba:	2302      	movs	r3, #2
  tmp |=  hdma->Init.Direction        |
 80010bc:	6885      	ldr	r5, [r0, #8]
  hdma->State = HAL_DMA_STATE_BUSY;
 80010be:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tmp |=  hdma->Init.Direction        |
 80010c2:	6843      	ldr	r3, [r0, #4]
  tmp = hdma->Instance->CCR;
 80010c4:	6801      	ldr	r1, [r0, #0]
  tmp |=  hdma->Init.Direction        |
 80010c6:	432b      	orrs	r3, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80010c8:	68c5      	ldr	r5, [r0, #12]
  tmp = hdma->Instance->CCR;
 80010ca:	680a      	ldr	r2, [r1, #0]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80010cc:	432b      	orrs	r3, r5
 80010ce:	6905      	ldr	r5, [r0, #16]
 80010d0:	432b      	orrs	r3, r5
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80010d2:	6945      	ldr	r5, [r0, #20]
 80010d4:	432b      	orrs	r3, r5
 80010d6:	6985      	ldr	r5, [r0, #24]
 80010d8:	432b      	orrs	r3, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 80010da:	69c5      	ldr	r5, [r0, #28]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80010dc:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 80010e0:	f022 0230 	bic.w	r2, r2, #48	; 0x30
          hdma->Init.Mode                | hdma->Init.Priority;
 80010e4:	432b      	orrs	r3, r5
  tmp |=  hdma->Init.Direction        |
 80010e6:	4313      	orrs	r3, r2
  hdma->Instance->CCR = tmp;  
 80010e8:	600b      	str	r3, [r1, #0]
  DMA_CalcBaseAndBitshift(hdma);
 80010ea:	f7ff ffc1 	bl	8001070 <DMA_CalcBaseAndBitshift>
  hdma->XferCpltCallback = NULL;
 80010ee:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 80010f0:	2301      	movs	r3, #1
  hdma->XferCpltCallback = NULL;
 80010f2:	62a0      	str	r0, [r4, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 80010f4:	62e0      	str	r0, [r4, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 80010f6:	6320      	str	r0, [r4, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 80010f8:	6360      	str	r0, [r4, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80010fa:	63a0      	str	r0, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 80010fc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  hdma->Lock = HAL_UNLOCKED;
 8001100:	f884 0020 	strb.w	r0, [r4, #32]
  return HAL_OK;
 8001104:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001106:	2001      	movs	r0, #1
}  
 8001108:	bd38      	pop	{r3, r4, r5, pc}

0800110a <HAL_DMA_Start_IT>:
{
 800110a:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 800110c:	f890 4020 	ldrb.w	r4, [r0, #32]
 8001110:	2c01      	cmp	r4, #1
 8001112:	d035      	beq.n	8001180 <HAL_DMA_Start_IT+0x76>
  if(HAL_DMA_STATE_READY == hdma->State)
 8001114:	f890 5021 	ldrb.w	r5, [r0, #33]	; 0x21
  __HAL_LOCK(hdma);
 8001118:	2401      	movs	r4, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 800111a:	42a5      	cmp	r5, r4
  __HAL_LOCK(hdma);
 800111c:	f880 4020 	strb.w	r4, [r0, #32]
 8001120:	f04f 0600 	mov.w	r6, #0
 8001124:	f04f 0402 	mov.w	r4, #2
  if(HAL_DMA_STATE_READY == hdma->State)
 8001128:	d128      	bne.n	800117c <HAL_DMA_Start_IT+0x72>
  	hdma->State = HAL_DMA_STATE_BUSY;
 800112a:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800112e:	6804      	ldr	r4, [r0, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001130:	6386      	str	r6, [r0, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001132:	6826      	ldr	r6, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8001134:	6c07      	ldr	r7, [r0, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001136:	f026 0601 	bic.w	r6, r6, #1
 800113a:	6026      	str	r6, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800113c:	6bc6      	ldr	r6, [r0, #60]	; 0x3c
 800113e:	40bd      	lsls	r5, r7
 8001140:	6075      	str	r5, [r6, #4]
  hdma->Instance->CNDTR = DataLength;
 8001142:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001144:	6843      	ldr	r3, [r0, #4]
 8001146:	6805      	ldr	r5, [r0, #0]
 8001148:	2b10      	cmp	r3, #16
    if(NULL != hdma->XferHalfCpltCallback )
 800114a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    hdma->Instance->CPAR = DstAddress;
 800114c:	bf0b      	itete	eq
 800114e:	60a2      	streq	r2, [r4, #8]
    hdma->Instance->CPAR = SrcAddress;
 8001150:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8001152:	60e1      	streq	r1, [r4, #12]
    hdma->Instance->CMAR = DstAddress;
 8001154:	60e2      	strne	r2, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8001156:	b14b      	cbz	r3, 800116c <HAL_DMA_Start_IT+0x62>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001158:	6823      	ldr	r3, [r4, #0]
 800115a:	f043 030e 	orr.w	r3, r3, #14
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800115e:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8001160:	682b      	ldr	r3, [r5, #0]
 8001162:	f043 0301 	orr.w	r3, r3, #1
 8001166:	602b      	str	r3, [r5, #0]
	HAL_StatusTypeDef status = HAL_OK;
 8001168:	2000      	movs	r0, #0
 800116a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 800116c:	6823      	ldr	r3, [r4, #0]
 800116e:	f043 030a 	orr.w	r3, r3, #10
 8001172:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8001174:	6823      	ldr	r3, [r4, #0]
 8001176:	f023 0304 	bic.w	r3, r3, #4
 800117a:	e7f0      	b.n	800115e <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma); 
 800117c:	f880 6020 	strb.w	r6, [r0, #32]
  __HAL_LOCK(hdma);
 8001180:	2002      	movs	r0, #2
} 
 8001182:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001184 <HAL_DMA_Abort_IT>:
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8001184:	f890 2021 	ldrb.w	r2, [r0, #33]	; 0x21
 8001188:	2a02      	cmp	r2, #2
{  
 800118a:	b510      	push	{r4, lr}
  if(HAL_DMA_STATE_BUSY != hdma->State)
 800118c:	d003      	beq.n	8001196 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800118e:	2204      	movs	r2, #4
 8001190:	6382      	str	r2, [r0, #56]	; 0x38
    status = HAL_ERROR;
 8001192:	2001      	movs	r0, #1
 8001194:	bd10      	pop	{r4, pc}
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001196:	6802      	ldr	r2, [r0, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8001198:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800119a:	6811      	ldr	r1, [r2, #0]
    if(hdma->XferAbortCallback != NULL)
 800119c:	6b43      	ldr	r3, [r0, #52]	; 0x34
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800119e:	f021 010e 	bic.w	r1, r1, #14
 80011a2:	6011      	str	r1, [r2, #0]
    hdma->Instance->CCR &= ~DMA_CCR_EN;
 80011a4:	6811      	ldr	r1, [r2, #0]
 80011a6:	f021 0101 	bic.w	r1, r1, #1
 80011aa:	6011      	str	r1, [r2, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80011ac:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80011ae:	2101      	movs	r1, #1
 80011b0:	fa01 f202 	lsl.w	r2, r1, r2
 80011b4:	6062      	str	r2, [r4, #4]
    __HAL_UNLOCK(hdma);
 80011b6:	2400      	movs	r4, #0
    hdma->State = HAL_DMA_STATE_READY;
 80011b8:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 80011bc:	f880 4020 	strb.w	r4, [r0, #32]
    if(hdma->XferAbortCallback != NULL)
 80011c0:	b113      	cbz	r3, 80011c8 <HAL_DMA_Abort_IT+0x44>
      hdma->XferAbortCallback(hdma);
 80011c2:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 80011c4:	4620      	mov	r0, r4
 80011c6:	bd10      	pop	{r4, pc}
 80011c8:	4618      	mov	r0, r3
}
 80011ca:	bd10      	pop	{r4, pc}

080011cc <HAL_DMA_IRQHandler>:
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80011cc:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80011ce:	6c02      	ldr	r2, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 80011d0:	6803      	ldr	r3, [r0, #0]
{
 80011d2:	b470      	push	{r4, r5, r6}
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80011d4:	680e      	ldr	r6, [r1, #0]
  uint32_t source_it = hdma->Instance->CCR;
 80011d6:	681d      	ldr	r5, [r3, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 80011d8:	2404      	movs	r4, #4
 80011da:	4094      	lsls	r4, r2
 80011dc:	4226      	tst	r6, r4
 80011de:	d00e      	beq.n	80011fe <HAL_DMA_IRQHandler+0x32>
 80011e0:	f015 0f04 	tst.w	r5, #4
 80011e4:	d00b      	beq.n	80011fe <HAL_DMA_IRQHandler+0x32>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80011e6:	681a      	ldr	r2, [r3, #0]
 80011e8:	0692      	lsls	r2, r2, #26
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80011ea:	bf5e      	ittt	pl
 80011ec:	681a      	ldrpl	r2, [r3, #0]
 80011ee:	f022 0204 	bicpl.w	r2, r2, #4
 80011f2:	601a      	strpl	r2, [r3, #0]
  	if(hdma->XferHalfCpltCallback != NULL)
 80011f4:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
 80011f6:	604c      	str	r4, [r1, #4]
    if(hdma->XferErrorCallback != NULL)
 80011f8:	b373      	cbz	r3, 8001258 <HAL_DMA_IRQHandler+0x8c>
}  
 80011fa:	bc70      	pop	{r4, r5, r6}
    	hdma->XferErrorCallback(hdma);
 80011fc:	4718      	bx	r3
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 80011fe:	2402      	movs	r4, #2
 8001200:	4094      	lsls	r4, r2
 8001202:	4226      	tst	r6, r4
 8001204:	d012      	beq.n	800122c <HAL_DMA_IRQHandler+0x60>
 8001206:	f015 0f02 	tst.w	r5, #2
 800120a:	d00f      	beq.n	800122c <HAL_DMA_IRQHandler+0x60>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800120c:	681a      	ldr	r2, [r3, #0]
 800120e:	0695      	lsls	r5, r2, #26
 8001210:	d406      	bmi.n	8001220 <HAL_DMA_IRQHandler+0x54>
  		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
 8001212:	681a      	ldr	r2, [r3, #0]
 8001214:	f022 020a 	bic.w	r2, r2, #10
 8001218:	601a      	str	r2, [r3, #0]
  		hdma->State = HAL_DMA_STATE_READY;
 800121a:	2301      	movs	r3, #1
 800121c:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  	__HAL_UNLOCK(hdma);
 8001220:	2300      	movs	r3, #0
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
 8001222:	604c      	str	r4, [r1, #4]
  	__HAL_UNLOCK(hdma);
 8001224:	f880 3020 	strb.w	r3, [r0, #32]
  	if(hdma->XferCpltCallback != NULL)
 8001228:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800122a:	e7e5      	b.n	80011f8 <HAL_DMA_IRQHandler+0x2c>
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 800122c:	2408      	movs	r4, #8
 800122e:	4094      	lsls	r4, r2
 8001230:	4234      	tst	r4, r6
 8001232:	d011      	beq.n	8001258 <HAL_DMA_IRQHandler+0x8c>
 8001234:	072c      	lsls	r4, r5, #28
 8001236:	d50f      	bpl.n	8001258 <HAL_DMA_IRQHandler+0x8c>
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001238:	681c      	ldr	r4, [r3, #0]
 800123a:	f024 040e 	bic.w	r4, r4, #14
 800123e:	601c      	str	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8001240:	2301      	movs	r3, #1
 8001242:	fa03 f202 	lsl.w	r2, r3, r2
 8001246:	604a      	str	r2, [r1, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8001248:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;    
 800124a:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma); 
 800124e:	2300      	movs	r3, #0
 8001250:	f880 3020 	strb.w	r3, [r0, #32]
    if(hdma->XferErrorCallback != NULL)
 8001254:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001256:	e7cf      	b.n	80011f8 <HAL_DMA_IRQHandler+0x2c>
}  
 8001258:	bc70      	pop	{r4, r5, r6}
 800125a:	4770      	bx	lr

0800125c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800125c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001260:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001264:	f8df 9174 	ldr.w	r9, [pc, #372]	; 80013dc <HAL_GPIO_Init+0x180>
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001268:	4a5a      	ldr	r2, [pc, #360]	; (80013d4 <HAL_GPIO_Init+0x178>)
  uint32_t position = 0x00U;
 800126a:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != RESET)
 800126c:	fa38 f403 	lsrs.w	r4, r8, r3
 8001270:	d102      	bne.n	8001278 <HAL_GPIO_Init+0x1c>
      }
    }
    
    position++;
  }
}
 8001272:	b003      	add	sp, #12
 8001274:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8001278:	2401      	movs	r4, #1
 800127a:	fa04 fa03 	lsl.w	sl, r4, r3
    if(iocurrent)
 800127e:	ea18 050a 	ands.w	r5, r8, sl
 8001282:	f000 809c 	beq.w	80013be <HAL_GPIO_Init+0x162>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001286:	684c      	ldr	r4, [r1, #4]
 8001288:	f024 0b10 	bic.w	fp, r4, #16
 800128c:	f1bb 0f02 	cmp.w	fp, #2
 8001290:	d114      	bne.n	80012bc <HAL_GPIO_Init+0x60>
        temp = GPIOx->AFR[position >> 3];
 8001292:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 8001296:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800129a:	f003 0c07 	and.w	ip, r3, #7
        temp = GPIOx->AFR[position >> 3];
 800129e:	f8de 6020 	ldr.w	r6, [lr, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 80012a2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80012a6:	270f      	movs	r7, #15
 80012a8:	fa07 f70c 	lsl.w	r7, r7, ip
 80012ac:	ea26 0707 	bic.w	r7, r6, r7
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 80012b0:	690e      	ldr	r6, [r1, #16]
 80012b2:	fa06 f60c 	lsl.w	r6, r6, ip
 80012b6:	433e      	orrs	r6, r7
        GPIOx->AFR[position >> 3] = temp;
 80012b8:	f8ce 6020 	str.w	r6, [lr, #32]
 80012bc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80012c0:	2703      	movs	r7, #3
      temp = GPIOx->MODER;
 80012c2:	6806      	ldr	r6, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80012c4:	fa07 f70c 	lsl.w	r7, r7, ip
 80012c8:	43ff      	mvns	r7, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80012ca:	f004 0e03 	and.w	lr, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 80012ce:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80012d0:	fa0e fe0c 	lsl.w	lr, lr, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80012d4:	f10b 3bff 	add.w	fp, fp, #4294967295
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80012d8:	ea4e 0606 	orr.w	r6, lr, r6
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80012dc:	f1bb 0f01 	cmp.w	fp, #1
      GPIOx->MODER = temp;
 80012e0:	6006      	str	r6, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80012e2:	d811      	bhi.n	8001308 <HAL_GPIO_Init+0xac>
        temp = GPIOx->OSPEEDR;
 80012e4:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80012e6:	ea06 0b07 	and.w	fp, r6, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 80012ea:	68ce      	ldr	r6, [r1, #12]
 80012ec:	fa06 fe0c 	lsl.w	lr, r6, ip
 80012f0:	ea4e 060b 	orr.w	r6, lr, fp
        GPIOx->OSPEEDR = temp;
 80012f4:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 80012f6:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80012f8:	ea26 0a0a 	bic.w	sl, r6, sl
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80012fc:	f3c4 1600 	ubfx	r6, r4, #4, #1
 8001300:	409e      	lsls	r6, r3
 8001302:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OTYPER = temp;
 8001306:	6046      	str	r6, [r0, #4]
      temp = GPIOx->PUPDR;
 8001308:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800130a:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800130c:	688e      	ldr	r6, [r1, #8]
 800130e:	fa06 f60c 	lsl.w	r6, r6, ip
 8001312:	4337      	orrs	r7, r6
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001314:	00e6      	lsls	r6, r4, #3
      GPIOx->PUPDR = temp;
 8001316:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001318:	d551      	bpl.n	80013be <HAL_GPIO_Init+0x162>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800131a:	f8d9 6018 	ldr.w	r6, [r9, #24]
 800131e:	f046 0601 	orr.w	r6, r6, #1
 8001322:	f8c9 6018 	str.w	r6, [r9, #24]
 8001326:	f8d9 6018 	ldr.w	r6, [r9, #24]
 800132a:	f023 0703 	bic.w	r7, r3, #3
 800132e:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8001332:	f006 0601 	and.w	r6, r6, #1
 8001336:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 800133a:	9601      	str	r6, [sp, #4]
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 800133c:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001340:	9e01      	ldr	r6, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 8001342:	68be      	ldr	r6, [r7, #8]
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 8001344:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001348:	f04f 0e0f 	mov.w	lr, #15
 800134c:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8001350:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 8001354:	ea26 0e0e 	bic.w	lr, r6, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8001358:	d033      	beq.n	80013c2 <HAL_GPIO_Init+0x166>
 800135a:	4e1f      	ldr	r6, [pc, #124]	; (80013d8 <HAL_GPIO_Init+0x17c>)
 800135c:	42b0      	cmp	r0, r6
 800135e:	d032      	beq.n	80013c6 <HAL_GPIO_Init+0x16a>
 8001360:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001364:	42b0      	cmp	r0, r6
 8001366:	d030      	beq.n	80013ca <HAL_GPIO_Init+0x16e>
 8001368:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 800136c:	42b0      	cmp	r0, r6
 800136e:	d02e      	beq.n	80013ce <HAL_GPIO_Init+0x172>
 8001370:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001374:	42b0      	cmp	r0, r6
 8001376:	bf14      	ite	ne
 8001378:	2605      	movne	r6, #5
 800137a:	2604      	moveq	r6, #4
 800137c:	fa06 f60c 	lsl.w	r6, r6, ip
 8001380:	ea46 060e 	orr.w	r6, r6, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8001384:	60be      	str	r6, [r7, #8]
        temp = EXTI->IMR;
 8001386:	6816      	ldr	r6, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8001388:	43ef      	mvns	r7, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800138a:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 800138e:	bf0c      	ite	eq
 8001390:	403e      	andeq	r6, r7
          temp |= iocurrent;
 8001392:	432e      	orrne	r6, r5
        EXTI->IMR = temp;
 8001394:	6016      	str	r6, [r2, #0]
        temp = EXTI->EMR;
 8001396:	6856      	ldr	r6, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001398:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 800139c:	bf0c      	ite	eq
 800139e:	403e      	andeq	r6, r7
          temp |= iocurrent;
 80013a0:	432e      	orrne	r6, r5
        EXTI->EMR = temp;
 80013a2:	6056      	str	r6, [r2, #4]
        temp = EXTI->RTSR;
 80013a4:	6896      	ldr	r6, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80013a6:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 80013aa:	bf0c      	ite	eq
 80013ac:	403e      	andeq	r6, r7
          temp |= iocurrent;
 80013ae:	432e      	orrne	r6, r5
        EXTI->RTSR = temp;
 80013b0:	6096      	str	r6, [r2, #8]
        temp = EXTI->FTSR;
 80013b2:	68d6      	ldr	r6, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80013b4:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 80013b6:	bf54      	ite	pl
 80013b8:	403e      	andpl	r6, r7
          temp |= iocurrent;
 80013ba:	432e      	orrmi	r6, r5
        EXTI->FTSR = temp;
 80013bc:	60d6      	str	r6, [r2, #12]
    position++;
 80013be:	3301      	adds	r3, #1
 80013c0:	e754      	b.n	800126c <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80013c2:	2600      	movs	r6, #0
 80013c4:	e7da      	b.n	800137c <HAL_GPIO_Init+0x120>
 80013c6:	2601      	movs	r6, #1
 80013c8:	e7d8      	b.n	800137c <HAL_GPIO_Init+0x120>
 80013ca:	2602      	movs	r6, #2
 80013cc:	e7d6      	b.n	800137c <HAL_GPIO_Init+0x120>
 80013ce:	2603      	movs	r6, #3
 80013d0:	e7d4      	b.n	800137c <HAL_GPIO_Init+0x120>
 80013d2:	bf00      	nop
 80013d4:	40010400 	.word	0x40010400
 80013d8:	48000400 	.word	0x48000400
 80013dc:	40021000 	.word	0x40021000

080013e0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80013e0:	b10a      	cbz	r2, 80013e6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80013e2:	6181      	str	r1, [r0, #24]
 80013e4:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80013e6:	6281      	str	r1, [r0, #40]	; 0x28
 80013e8:	4770      	bx	lr

080013ea <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80013ea:	6943      	ldr	r3, [r0, #20]
 80013ec:	4059      	eors	r1, r3
 80013ee:	6141      	str	r1, [r0, #20]
 80013f0:	4770      	bx	lr

080013f2 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80013f2:	6803      	ldr	r3, [r0, #0]
 80013f4:	699a      	ldr	r2, [r3, #24]
 80013f6:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 80013f8:	bf44      	itt	mi
 80013fa:	2200      	movmi	r2, #0
 80013fc:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80013fe:	699a      	ldr	r2, [r3, #24]
 8001400:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8001402:	bf5e      	ittt	pl
 8001404:	699a      	ldrpl	r2, [r3, #24]
 8001406:	f042 0201 	orrpl.w	r2, r2, #1
 800140a:	619a      	strpl	r2, [r3, #24]
 800140c:	4770      	bx	lr

0800140e <I2C_Disable_IRQ>:
  */
static HAL_StatusTypeDef I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
 800140e:	f011 0301 	ands.w	r3, r1, #1
 8001412:	d007      	beq.n	8001424 <I2C_Disable_IRQ+0x16>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;

    if ((hi2c->State & HAL_I2C_STATE_LISTEN) != HAL_I2C_STATE_LISTEN)
 8001414:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001418:	f003 0328 	and.w	r3, r3, #40	; 0x28
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 800141c:	2b28      	cmp	r3, #40	; 0x28
 800141e:	bf0c      	ite	eq
 8001420:	2342      	moveq	r3, #66	; 0x42
 8001422:	23f2      	movne	r3, #242	; 0xf2
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
 8001424:	078a      	lsls	r2, r1, #30
 8001426:	d509      	bpl.n	800143c <I2C_Disable_IRQ+0x2e>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;

    if ((hi2c->State & HAL_I2C_STATE_LISTEN) != HAL_I2C_STATE_LISTEN)
 8001428:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 800142c:	f002 0228 	and.w	r2, r2, #40	; 0x28
 8001430:	2a28      	cmp	r2, #40	; 0x28
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
 8001432:	bf0c      	ite	eq
 8001434:	f043 0344 	orreq.w	r3, r3, #68	; 0x44
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 8001438:	f043 03f4 	orrne.w	r3, r3, #244	; 0xf4
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
 800143c:	074a      	lsls	r2, r1, #29
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
  }

  if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
 800143e:	f001 0211 	and.w	r2, r1, #17
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
 8001442:	bf48      	it	mi
 8001444:	f043 03b8 	orrmi.w	r3, r3, #184	; 0xb8
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
  }

  if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
 8001448:	f001 0112 	and.w	r1, r1, #18
  if ((InterruptRequest & I2C_XFER_ERROR_IT) == I2C_XFER_ERROR_IT)
 800144c:	2a11      	cmp	r2, #17
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
 800144e:	bf08      	it	eq
 8001450:	f043 0390 	orreq.w	r3, r3, #144	; 0x90
  if ((InterruptRequest & I2C_XFER_CPLT_IT) == I2C_XFER_CPLT_IT)
 8001454:	2912      	cmp	r1, #18
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8001456:	6801      	ldr	r1, [r0, #0]
 8001458:	680a      	ldr	r2, [r1, #0]
    tmpisr |= I2C_IT_TCI;
 800145a:	bf08      	it	eq
 800145c:	f043 0360 	orreq.w	r3, r3, #96	; 0x60
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8001460:	ea22 0303 	bic.w	r3, r2, r3
 8001464:	600b      	str	r3, [r1, #0]

  return HAL_OK;
}
 8001466:	2000      	movs	r0, #0
 8001468:	4770      	bx	lr

0800146a <HAL_I2C_Init>:
{
 800146a:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 800146c:	4604      	mov	r4, r0
 800146e:	2800      	cmp	r0, #0
 8001470:	d04a      	beq.n	8001508 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8001472:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001476:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800147a:	b91b      	cbnz	r3, 8001484 <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
 800147c:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8001480:	f005 f9c8 	bl	8006814 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8001484:	2324      	movs	r3, #36	; 0x24
 8001486:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 800148a:	6823      	ldr	r3, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800148c:	68e1      	ldr	r1, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 800148e:	681a      	ldr	r2, [r3, #0]
 8001490:	f022 0201 	bic.w	r2, r2, #1
 8001494:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8001496:	6862      	ldr	r2, [r4, #4]
 8001498:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 800149c:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800149e:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80014a0:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 80014a2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80014a6:	609a      	str	r2, [r3, #8]
 80014a8:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80014aa:	d124      	bne.n	80014f6 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80014ac:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80014b0:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80014b2:	685a      	ldr	r2, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80014b4:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80014b6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80014ba:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80014be:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80014c0:	68da      	ldr	r2, [r3, #12]
 80014c2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80014c6:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80014c8:	6922      	ldr	r2, [r4, #16]
 80014ca:	430a      	orrs	r2, r1
 80014cc:	69a1      	ldr	r1, [r4, #24]
 80014ce:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80014d2:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80014d4:	6a21      	ldr	r1, [r4, #32]
 80014d6:	69e2      	ldr	r2, [r4, #28]
 80014d8:	430a      	orrs	r2, r1
 80014da:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 80014dc:	681a      	ldr	r2, [r3, #0]
 80014de:	f042 0201 	orr.w	r2, r2, #1
 80014e2:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80014e4:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 80014e6:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80014e8:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 80014ea:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80014ee:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80014f0:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  return HAL_OK;
 80014f4:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80014f6:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80014fa:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80014fc:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 80014fe:	bf04      	itt	eq
 8001500:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8001504:	605a      	streq	r2, [r3, #4]
 8001506:	e7d4      	b.n	80014b2 <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 8001508:	2001      	movs	r0, #1
}
 800150a:	bd10      	pop	{r4, pc}

0800150c <HAL_I2C_EV_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800150c:	6802      	ldr	r2, [r0, #0]
  if (hi2c->XferISR != NULL)
 800150e:	6b43      	ldr	r3, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 8001510:	6991      	ldr	r1, [r2, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8001512:	6812      	ldr	r2, [r2, #0]
  if (hi2c->XferISR != NULL)
 8001514:	b103      	cbz	r3, 8001518 <HAL_I2C_EV_IRQHandler+0xc>
    hi2c->XferISR(hi2c, itflags, itsources);
 8001516:	4718      	bx	r3
 8001518:	4770      	bx	lr

0800151a <HAL_I2C_SlaveTxCpltCallback>:
 800151a:	4770      	bx	lr

0800151c <HAL_I2C_SlaveRxCpltCallback>:
 800151c:	4770      	bx	lr

0800151e <I2C_ITSlaveSequentialCplt>:
{
 800151e:	b538      	push	{r3, r4, r5, lr}
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001520:	2500      	movs	r5, #0
 8001522:	f880 5042 	strb.w	r5, [r0, #66]	; 0x42
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8001526:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 800152a:	2b29      	cmp	r3, #41	; 0x29
{
 800152c:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 800152e:	d10d      	bne.n	800154c <I2C_ITSlaveSequentialCplt+0x2e>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8001530:	2328      	movs	r3, #40	; 0x28
 8001532:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8001536:	2321      	movs	r3, #33	; 0x21
 8001538:	6303      	str	r3, [r0, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
 800153a:	2101      	movs	r1, #1
 800153c:	f7ff ff67 	bl	800140e <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 8001540:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8001544:	4620      	mov	r0, r4
 8001546:	f7ff ffe8 	bl	800151a <HAL_I2C_SlaveTxCpltCallback>
 800154a:	bd38      	pop	{r3, r4, r5, pc}
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 800154c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001550:	2b2a      	cmp	r3, #42	; 0x2a
 8001552:	d10c      	bne.n	800156e <I2C_ITSlaveSequentialCplt+0x50>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8001554:	2328      	movs	r3, #40	; 0x28
 8001556:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800155a:	2322      	movs	r3, #34	; 0x22
 800155c:	6303      	str	r3, [r0, #48]	; 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
 800155e:	2102      	movs	r1, #2
 8001560:	f7ff ff55 	bl	800140e <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
 8001564:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8001568:	4620      	mov	r0, r4
 800156a:	f7ff ffd7 	bl	800151c <HAL_I2C_SlaveRxCpltCallback>
 800156e:	bd38      	pop	{r3, r4, r5, pc}

08001570 <HAL_I2C_AddrCallback>:
{
 8001570:	4770      	bx	lr

08001572 <HAL_I2C_ListenCpltCallback>:
 8001572:	4770      	bx	lr

08001574 <I2C_ITListenCplt>:
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8001574:	4b16      	ldr	r3, [pc, #88]	; (80015d0 <I2C_ITListenCplt+0x5c>)
{
 8001576:	b510      	push	{r4, lr}
  hi2c->State = HAL_I2C_STATE_READY;
 8001578:	2220      	movs	r2, #32
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800157a:	62c3      	str	r3, [r0, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 800157c:	2300      	movs	r3, #0
 800157e:	6303      	str	r3, [r0, #48]	; 0x30
  hi2c->XferISR = NULL;
 8001580:	6343      	str	r3, [r0, #52]	; 0x34
  hi2c->State = HAL_I2C_STATE_READY;
 8001582:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001586:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  if (((ITFlags & I2C_FLAG_RXNE) != RESET))
 800158a:	074b      	lsls	r3, r1, #29
{
 800158c:	4604      	mov	r4, r0
  if (((ITFlags & I2C_FLAG_RXNE) != RESET))
 800158e:	d511      	bpl.n	80015b4 <I2C_ITListenCplt+0x40>
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8001590:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001592:	1c5a      	adds	r2, r3, #1
 8001594:	6242      	str	r2, [r0, #36]	; 0x24
 8001596:	6802      	ldr	r2, [r0, #0]
 8001598:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800159a:	701a      	strb	r2, [r3, #0]
    if ((hi2c->XferSize > 0U))
 800159c:	8d03      	ldrh	r3, [r0, #40]	; 0x28
 800159e:	b14b      	cbz	r3, 80015b4 <I2C_ITListenCplt+0x40>
      hi2c->XferSize--;
 80015a0:	3b01      	subs	r3, #1
 80015a2:	8503      	strh	r3, [r0, #40]	; 0x28
      hi2c->XferCount--;
 80015a4:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80015a6:	3b01      	subs	r3, #1
 80015a8:	b29b      	uxth	r3, r3
 80015aa:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80015ac:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80015ae:	f043 0304 	orr.w	r3, r3, #4
 80015b2:	6443      	str	r3, [r0, #68]	; 0x44
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 80015b4:	2107      	movs	r1, #7
 80015b6:	4620      	mov	r0, r4
 80015b8:	f7ff ff29 	bl	800140e <I2C_Disable_IRQ>
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80015bc:	6823      	ldr	r3, [r4, #0]
 80015be:	2210      	movs	r2, #16
 80015c0:	61da      	str	r2, [r3, #28]
  __HAL_UNLOCK(hi2c);
 80015c2:	2300      	movs	r3, #0
 80015c4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 80015c8:	4620      	mov	r0, r4
 80015ca:	f7ff ffd2 	bl	8001572 <HAL_I2C_ListenCpltCallback>
 80015ce:	bd10      	pop	{r4, pc}
 80015d0:	ffff0000 	.word	0xffff0000

080015d4 <HAL_I2C_ErrorCallback>:
 80015d4:	4770      	bx	lr

080015d6 <HAL_I2C_AbortCpltCallback>:
{
 80015d6:	4770      	bx	lr

080015d8 <I2C_ITError>:
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 80015d8:	2300      	movs	r3, #0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80015da:	4a35      	ldr	r2, [pc, #212]	; (80016b0 <I2C_ITError+0xd8>)
{
 80015dc:	b510      	push	{r4, lr}
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 80015de:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80015e2:	62c2      	str	r2, [r0, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 80015e4:	8543      	strh	r3, [r0, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 80015e6:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80015e8:	4319      	orrs	r1, r3
 80015ea:	6441      	str	r1, [r0, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_LISTEN)         ||
 80015ec:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80015f0:	2b28      	cmp	r3, #40	; 0x28
{
 80015f2:	4604      	mov	r4, r0
  if ((hi2c->State == HAL_I2C_STATE_LISTEN)         ||
 80015f4:	d007      	beq.n	8001606 <I2C_ITError+0x2e>
      (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
 80015f6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  if ((hi2c->State == HAL_I2C_STATE_LISTEN)         ||
 80015fa:	2b29      	cmp	r3, #41	; 0x29
 80015fc:	d003      	beq.n	8001606 <I2C_ITError+0x2e>
      (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80015fe:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
      (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
 8001602:	2b2a      	cmp	r3, #42	; 0x2a
 8001604:	d122      	bne.n	800164c <I2C_ITError+0x74>
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 8001606:	2103      	movs	r1, #3
 8001608:	4620      	mov	r0, r4
 800160a:	f7ff ff00 	bl	800140e <I2C_Disable_IRQ>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800160e:	2328      	movs	r3, #40	; 0x28
 8001610:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8001614:	2300      	movs	r3, #0
 8001616:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8001618:	4b26      	ldr	r3, [pc, #152]	; (80016b4 <I2C_ITError+0xdc>)
    hi2c->XferISR       = NULL;
 800161a:	6363      	str	r3, [r4, #52]	; 0x34
  if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 800161c:	6823      	ldr	r3, [r4, #0]
 800161e:	6819      	ldr	r1, [r3, #0]
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8001620:	681a      	ldr	r2, [r3, #0]
  if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8001622:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 8001626:	d01e      	beq.n	8001666 <I2C_ITError+0x8e>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8001628:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800162c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 800162e:	601a      	str	r2, [r3, #0]
    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8001630:	4b21      	ldr	r3, [pc, #132]	; (80016b8 <I2C_ITError+0xe0>)
 8001632:	6343      	str	r3, [r0, #52]	; 0x34
    __HAL_UNLOCK(hi2c);
 8001634:	2300      	movs	r3, #0
 8001636:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 800163a:	f7ff fda3 	bl	8001184 <HAL_DMA_Abort_IT>
 800163e:	2800      	cmp	r0, #0
 8001640:	d034      	beq.n	80016ac <I2C_ITError+0xd4>
      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8001642:	6ba0      	ldr	r0, [r4, #56]	; 0x38
      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8001644:	6b43      	ldr	r3, [r0, #52]	; 0x34
}
 8001646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800164a:	4718      	bx	r3
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
 800164c:	2107      	movs	r1, #7
 800164e:	f7ff fede 	bl	800140e <I2C_Disable_IRQ>
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8001652:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8001656:	2b60      	cmp	r3, #96	; 0x60
      hi2c->State         = HAL_I2C_STATE_READY;
 8001658:	bf1c      	itt	ne
 800165a:	2320      	movne	r3, #32
 800165c:	f884 3041 	strbne.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8001660:	2300      	movs	r3, #0
 8001662:	6323      	str	r3, [r4, #48]	; 0x30
 8001664:	e7d9      	b.n	800161a <I2C_ITError+0x42>
  else if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8001666:	f412 4200 	ands.w	r2, r2, #32768	; 0x8000
 800166a:	d00d      	beq.n	8001688 <I2C_ITError+0xb0>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800166c:	681a      	ldr	r2, [r3, #0]
    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800166e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8001670:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001674:	601a      	str	r2, [r3, #0]
    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8001676:	4b10      	ldr	r3, [pc, #64]	; (80016b8 <I2C_ITError+0xe0>)
 8001678:	6343      	str	r3, [r0, #52]	; 0x34
    __HAL_UNLOCK(hi2c);
 800167a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 800167e:	f7ff fd81 	bl	8001184 <HAL_DMA_Abort_IT>
 8001682:	b198      	cbz	r0, 80016ac <I2C_ITError+0xd4>
      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8001684:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001686:	e7dd      	b.n	8001644 <I2C_ITError+0x6c>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8001688:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800168c:	2b60      	cmp	r3, #96	; 0x60
 800168e:	d108      	bne.n	80016a2 <I2C_ITError+0xca>
    hi2c->State = HAL_I2C_STATE_READY;
 8001690:	2320      	movs	r3, #32
 8001692:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001696:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_AbortCpltCallback(hi2c);
 800169a:	4620      	mov	r0, r4
 800169c:	f7ff ff9b 	bl	80015d6 <HAL_I2C_AbortCpltCallback>
 80016a0:	bd10      	pop	{r4, pc}
    __HAL_UNLOCK(hi2c);
 80016a2:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 80016a6:	4620      	mov	r0, r4
 80016a8:	f7ff ff94 	bl	80015d4 <HAL_I2C_ErrorCallback>
 80016ac:	bd10      	pop	{r4, pc}
 80016ae:	bf00      	nop
 80016b0:	ffff0000 	.word	0xffff0000
 80016b4:	080017bd 	.word	0x080017bd
 80016b8:	080019cf 	.word	0x080019cf

080016bc <I2C_ITSlaveCplt>:
{
 80016bc:	b538      	push	{r3, r4, r5, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80016be:	6803      	ldr	r3, [r0, #0]
 80016c0:	2220      	movs	r2, #32
{
 80016c2:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80016c4:	61da      	str	r2, [r3, #28]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80016c6:	2208      	movs	r2, #8
 80016c8:	61da      	str	r2, [r3, #28]
{
 80016ca:	460d      	mov	r5, r1
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
 80016cc:	2107      	movs	r1, #7
 80016ce:	f7ff fe9e 	bl	800140e <I2C_Disable_IRQ>
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80016d2:	6823      	ldr	r3, [r4, #0]
 80016d4:	685a      	ldr	r2, [r3, #4]
 80016d6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80016da:	605a      	str	r2, [r3, #4]
  I2C_RESET_CR2(hi2c);
 80016dc:	685a      	ldr	r2, [r3, #4]
 80016de:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 80016e2:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 80016e6:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 80016ea:	f022 0201 	bic.w	r2, r2, #1
 80016ee:	605a      	str	r2, [r3, #4]
  I2C_Flush_TXDR(hi2c);
 80016f0:	4620      	mov	r0, r4
 80016f2:	f7ff fe7e 	bl	80013f2 <I2C_Flush_TXDR>
  if (((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN) ||
 80016f6:	6822      	ldr	r2, [r4, #0]
 80016f8:	6813      	ldr	r3, [r2, #0]
 80016fa:	0458      	lsls	r0, r3, #17
 80016fc:	d402      	bmi.n	8001704 <I2C_ITSlaveCplt+0x48>
      ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN))
 80016fe:	6813      	ldr	r3, [r2, #0]
  if (((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN) ||
 8001700:	0419      	lsls	r1, r3, #16
 8001702:	d509      	bpl.n	8001718 <I2C_ITSlaveCplt+0x5c>
    hi2c->XferCount = I2C_GET_DMA_REMAIN_DATA(hi2c);
 8001704:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8001708:	2b21      	cmp	r3, #33	; 0x21
 800170a:	bf0c      	ite	eq
 800170c:	6ba3      	ldreq	r3, [r4, #56]	; 0x38
 800170e:	6be3      	ldrne	r3, [r4, #60]	; 0x3c
 8001710:	681b      	ldr	r3, [r3, #0]
 8001712:	685b      	ldr	r3, [r3, #4]
 8001714:	b29b      	uxth	r3, r3
 8001716:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (hi2c->XferCount != 0U)
 8001718:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800171a:	b29b      	uxth	r3, r3
 800171c:	b11b      	cbz	r3, 8001726 <I2C_ITSlaveCplt+0x6a>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800171e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001720:	f043 0304 	orr.w	r3, r3, #4
 8001724:	6463      	str	r3, [r4, #68]	; 0x44
  if (((ITFlags & I2C_FLAG_RXNE) != RESET))
 8001726:	076b      	lsls	r3, r5, #29
 8001728:	d510      	bpl.n	800174c <I2C_ITSlaveCplt+0x90>
    (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 800172a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800172c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800172e:	1c59      	adds	r1, r3, #1
 8001730:	6261      	str	r1, [r4, #36]	; 0x24
 8001732:	701a      	strb	r2, [r3, #0]
    if ((hi2c->XferSize > 0U))
 8001734:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8001736:	b14b      	cbz	r3, 800174c <I2C_ITSlaveCplt+0x90>
      hi2c->XferSize--;
 8001738:	3b01      	subs	r3, #1
 800173a:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800173c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800173e:	3b01      	subs	r3, #1
 8001740:	b29b      	uxth	r3, r3
 8001742:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8001744:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001746:	f043 0304 	orr.w	r3, r3, #4
 800174a:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->PreviousState = I2C_STATE_NONE;
 800174c:	2300      	movs	r3, #0
 800174e:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001750:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  hi2c->XferISR = NULL;
 8001754:	6363      	str	r3, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8001756:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001758:	b16b      	cbz	r3, 8001776 <I2C_ITSlaveCplt+0xba>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 800175a:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800175c:	4620      	mov	r0, r4
 800175e:	f7ff ff3b 	bl	80015d8 <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8001762:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8001766:	2b28      	cmp	r3, #40	; 0x28
 8001768:	d124      	bne.n	80017b4 <I2C_ITSlaveCplt+0xf8>
      I2C_ITListenCplt(hi2c, ITFlags);
 800176a:	4629      	mov	r1, r5
 800176c:	4620      	mov	r0, r4
}
 800176e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      I2C_ITListenCplt(hi2c, ITFlags);
 8001772:	f7ff beff 	b.w	8001574 <I2C_ITListenCplt>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8001776:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001778:	f512 3f80 	cmn.w	r2, #65536	; 0x10000
 800177c:	d00a      	beq.n	8001794 <I2C_ITSlaveCplt+0xd8>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800177e:	4a0e      	ldr	r2, [pc, #56]	; (80017b8 <I2C_ITSlaveCplt+0xfc>)
 8001780:	62e2      	str	r2, [r4, #44]	; 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
 8001782:	2220      	movs	r2, #32
 8001784:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001788:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
 800178c:	4620      	mov	r0, r4
 800178e:	f7ff fef0 	bl	8001572 <HAL_I2C_ListenCpltCallback>
 8001792:	bd38      	pop	{r3, r4, r5, pc}
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8001794:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001798:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800179c:	2a22      	cmp	r2, #34	; 0x22
 800179e:	f04f 0220 	mov.w	r2, #32
    hi2c->State = HAL_I2C_STATE_READY;
 80017a2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 80017a6:	4620      	mov	r0, r4
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80017a8:	d102      	bne.n	80017b0 <I2C_ITSlaveCplt+0xf4>
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 80017aa:	f7ff feb7 	bl	800151c <HAL_I2C_SlaveRxCpltCallback>
 80017ae:	bd38      	pop	{r3, r4, r5, pc}
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 80017b0:	f7ff feb3 	bl	800151a <HAL_I2C_SlaveTxCpltCallback>
 80017b4:	bd38      	pop	{r3, r4, r5, pc}
 80017b6:	bf00      	nop
 80017b8:	ffff0000 	.word	0xffff0000

080017bc <I2C_Slave_ISR_IT>:
{
 80017bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(hi2c);
 80017c0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80017c4:	2b01      	cmp	r3, #1
{
 80017c6:	4604      	mov	r4, r0
 80017c8:	460e      	mov	r6, r1
 80017ca:	4617      	mov	r7, r2
  __HAL_LOCK(hi2c);
 80017cc:	f000 80cb 	beq.w	8001966 <I2C_Slave_ISR_IT+0x1aa>
 80017d0:	2301      	movs	r3, #1
  if (((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
 80017d2:	06cd      	lsls	r5, r1, #27
  __HAL_LOCK(hi2c);
 80017d4:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if (((ITFlags & I2C_FLAG_AF) != RESET) && ((ITSources & I2C_IT_NACKI) != RESET))
 80017d8:	d53e      	bpl.n	8001858 <I2C_Slave_ISR_IT+0x9c>
 80017da:	06d0      	lsls	r0, r2, #27
 80017dc:	d53c      	bpl.n	8001858 <I2C_Slave_ISR_IT+0x9c>
    if (hi2c->XferCount == 0U)
 80017de:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80017e0:	b29b      	uxth	r3, r3
 80017e2:	bb8b      	cbnz	r3, 8001848 <I2C_Slave_ISR_IT+0x8c>
      if (((hi2c->XferOptions == I2C_FIRST_AND_LAST_FRAME) || (hi2c->XferOptions == I2C_LAST_FRAME)) && \
 80017e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80017e6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80017ea:	d003      	beq.n	80017f4 <I2C_Slave_ISR_IT+0x38>
 80017ec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80017ee:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80017f2:	d114      	bne.n	800181e <I2C_Slave_ISR_IT+0x62>
          (hi2c->State == HAL_I2C_STATE_LISTEN))
 80017f4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
      if (((hi2c->XferOptions == I2C_FIRST_AND_LAST_FRAME) || (hi2c->XferOptions == I2C_LAST_FRAME)) && \
 80017f8:	2b28      	cmp	r3, #40	; 0x28
 80017fa:	d110      	bne.n	800181e <I2C_Slave_ISR_IT+0x62>
        I2C_ITListenCplt(hi2c, ITFlags);
 80017fc:	4631      	mov	r1, r6
 80017fe:	4620      	mov	r0, r4
 8001800:	f7ff feb8 	bl	8001574 <I2C_ITListenCplt>
  if (((ITFlags & I2C_FLAG_STOPF) != RESET) && ((ITSources & I2C_IT_STOPI) != RESET))
 8001804:	06b2      	lsls	r2, r6, #26
 8001806:	d505      	bpl.n	8001814 <I2C_Slave_ISR_IT+0x58>
 8001808:	06bb      	lsls	r3, r7, #26
 800180a:	d503      	bpl.n	8001814 <I2C_Slave_ISR_IT+0x58>
    I2C_ITSlaveCplt(hi2c, ITFlags);
 800180c:	4631      	mov	r1, r6
 800180e:	4620      	mov	r0, r4
 8001810:	f7ff ff54 	bl	80016bc <I2C_ITSlaveCplt>
  __HAL_UNLOCK(hi2c);
 8001814:	2000      	movs	r0, #0
 8001816:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
 800181a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      else if ((hi2c->XferOptions != I2C_NO_OPTION_FRAME) && (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800181e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001820:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8001824:	6823      	ldr	r3, [r4, #0]
 8001826:	d00c      	beq.n	8001842 <I2C_Slave_ISR_IT+0x86>
 8001828:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800182c:	2a29      	cmp	r2, #41	; 0x29
 800182e:	d108      	bne.n	8001842 <I2C_Slave_ISR_IT+0x86>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001830:	2210      	movs	r2, #16
 8001832:	61da      	str	r2, [r3, #28]
        I2C_Flush_TXDR(hi2c);
 8001834:	4620      	mov	r0, r4
 8001836:	f7ff fddc 	bl	80013f2 <I2C_Flush_TXDR>
      I2C_ITSlaveSequentialCplt(hi2c);
 800183a:	4620      	mov	r0, r4
 800183c:	f7ff fe6f 	bl	800151e <I2C_ITSlaveSequentialCplt>
 8001840:	e7e0      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001842:	2210      	movs	r2, #16
 8001844:	61da      	str	r2, [r3, #28]
 8001846:	e7dd      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001848:	6823      	ldr	r3, [r4, #0]
 800184a:	2210      	movs	r2, #16
 800184c:	61da      	str	r2, [r3, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800184e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001850:	f043 0304 	orr.w	r3, r3, #4
 8001854:	6463      	str	r3, [r4, #68]	; 0x44
 8001856:	e7d5      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
  else if (((ITFlags & I2C_FLAG_RXNE) != RESET) && ((ITSources & I2C_IT_RXI) != RESET))
 8001858:	0771      	lsls	r1, r6, #29
 800185a:	d51a      	bpl.n	8001892 <I2C_Slave_ISR_IT+0xd6>
 800185c:	077a      	lsls	r2, r7, #29
 800185e:	d518      	bpl.n	8001892 <I2C_Slave_ISR_IT+0xd6>
    if (hi2c->XferCount > 0U)
 8001860:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001862:	b29b      	uxth	r3, r3
 8001864:	b163      	cbz	r3, 8001880 <I2C_Slave_ISR_IT+0xc4>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8001866:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001868:	1c5a      	adds	r2, r3, #1
 800186a:	6262      	str	r2, [r4, #36]	; 0x24
 800186c:	6822      	ldr	r2, [r4, #0]
 800186e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001870:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 8001872:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8001874:	3b01      	subs	r3, #1
 8001876:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8001878:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800187a:	3b01      	subs	r3, #1
 800187c:	b29b      	uxth	r3, r3
 800187e:	8563      	strh	r3, [r4, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && \
 8001880:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001882:	b29b      	uxth	r3, r3
 8001884:	2b00      	cmp	r3, #0
 8001886:	d1bd      	bne.n	8001804 <I2C_Slave_ISR_IT+0x48>
        (hi2c->XferOptions != I2C_NO_OPTION_FRAME))
 8001888:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if ((hi2c->XferCount == 0U) && \
 800188a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 800188e:	d1d4      	bne.n	800183a <I2C_Slave_ISR_IT+0x7e>
 8001890:	e7b8      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
  else if (((ITFlags & I2C_FLAG_ADDR) != RESET) && ((ITSources & I2C_IT_ADDRI) != RESET))
 8001892:	0733      	lsls	r3, r6, #28
 8001894:	d546      	bpl.n	8001924 <I2C_Slave_ISR_IT+0x168>
 8001896:	073d      	lsls	r5, r7, #28
 8001898:	d544      	bpl.n	8001924 <I2C_Slave_ISR_IT+0x168>
  if ((hi2c->State & HAL_I2C_STATE_LISTEN) == HAL_I2C_STATE_LISTEN)
 800189a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 800189e:	f003 0328 	and.w	r3, r3, #40	; 0x28
 80018a2:	2b28      	cmp	r3, #40	; 0x28
 80018a4:	6823      	ldr	r3, [r4, #0]
 80018a6:	d137      	bne.n	8001918 <I2C_Slave_ISR_IT+0x15c>
    transferdirection = I2C_GET_DIR(hi2c);
 80018a8:	699a      	ldr	r2, [r3, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80018aa:	68e1      	ldr	r1, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80018ac:	699d      	ldr	r5, [r3, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80018ae:	2902      	cmp	r1, #2
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80018b0:	ea4f 4515 	mov.w	r5, r5, lsr #16
    transferdirection = I2C_GET_DIR(hi2c);
 80018b4:	f3c2 4800 	ubfx	r8, r2, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80018b8:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80018bc:	689a      	ldr	r2, [r3, #8]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 80018be:	f8d3 900c 	ldr.w	r9, [r3, #12]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80018c2:	d120      	bne.n	8001906 <I2C_Slave_ISR_IT+0x14a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80018c4:	f3c2 0209 	ubfx	r2, r2, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 80018c8:	ea85 15d2 	eor.w	r5, r5, r2, lsr #7
 80018cc:	f015 0506 	ands.w	r5, r5, #6
 80018d0:	d10f      	bne.n	80018f2 <I2C_Slave_ISR_IT+0x136>
        hi2c->AddrEventCount++;
 80018d2:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80018d4:	3101      	adds	r1, #1
 80018d6:	64a1      	str	r1, [r4, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 80018d8:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80018da:	2902      	cmp	r1, #2
 80018dc:	d192      	bne.n	8001804 <I2C_Slave_ISR_IT+0x48>
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80018de:	2108      	movs	r1, #8
          hi2c->AddrEventCount = 0U;
 80018e0:	64a5      	str	r5, [r4, #72]	; 0x48
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 80018e2:	61d9      	str	r1, [r3, #28]
          __HAL_UNLOCK(hi2c);
 80018e4:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 80018e8:	4641      	mov	r1, r8
 80018ea:	4620      	mov	r0, r4
 80018ec:	f7ff fe40 	bl	8001570 <HAL_I2C_AddrCallback>
 80018f0:	e788      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 80018f2:	2104      	movs	r1, #4
 80018f4:	4620      	mov	r0, r4
 80018f6:	f7ff fd8a 	bl	800140e <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
 80018fa:	2300      	movs	r3, #0
 80018fc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8001900:	f009 02fe 	and.w	r2, r9, #254	; 0xfe
 8001904:	e7f0      	b.n	80018e8 <I2C_Slave_ISR_IT+0x12c>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
 8001906:	2104      	movs	r1, #4
 8001908:	4620      	mov	r0, r4
 800190a:	f7ff fd80 	bl	800140e <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
 800190e:	2300      	movs	r3, #0
 8001910:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8001914:	462a      	mov	r2, r5
 8001916:	e7e7      	b.n	80018e8 <I2C_Slave_ISR_IT+0x12c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8001918:	2208      	movs	r2, #8
 800191a:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
 800191c:	2300      	movs	r3, #0
 800191e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8001922:	e76f      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
  else if (((ITFlags & I2C_FLAG_TXIS) != RESET) && ((ITSources & I2C_IT_TXI) != RESET))
 8001924:	07b0      	lsls	r0, r6, #30
 8001926:	f57f af6d 	bpl.w	8001804 <I2C_Slave_ISR_IT+0x48>
 800192a:	07b9      	lsls	r1, r7, #30
 800192c:	f57f af6a 	bpl.w	8001804 <I2C_Slave_ISR_IT+0x48>
    if (hi2c->XferCount > 0U)
 8001930:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001932:	b29b      	uxth	r3, r3
 8001934:	b16b      	cbz	r3, 8001952 <I2C_Slave_ISR_IT+0x196>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8001936:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001938:	6822      	ldr	r2, [r4, #0]
 800193a:	1c59      	adds	r1, r3, #1
 800193c:	6261      	str	r1, [r4, #36]	; 0x24
 800193e:	781b      	ldrb	r3, [r3, #0]
 8001940:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 8001942:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001944:	3b01      	subs	r3, #1
 8001946:	b29b      	uxth	r3, r3
 8001948:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800194a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800194c:	3b01      	subs	r3, #1
 800194e:	8523      	strh	r3, [r4, #40]	; 0x28
 8001950:	e758      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
      if ((hi2c->XferOptions == I2C_NEXT_FRAME) || (hi2c->XferOptions == I2C_FIRST_FRAME))
 8001952:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001954:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8001958:	f43f af6f 	beq.w	800183a <I2C_Slave_ISR_IT+0x7e>
 800195c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800195e:	2b00      	cmp	r3, #0
 8001960:	f43f af6b 	beq.w	800183a <I2C_Slave_ISR_IT+0x7e>
 8001964:	e74e      	b.n	8001804 <I2C_Slave_ISR_IT+0x48>
  __HAL_LOCK(hi2c);
 8001966:	2002      	movs	r0, #2
}
 8001968:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800196c <HAL_I2C_ER_IRQHandler>:
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 800196c:	6803      	ldr	r3, [r0, #0]
 800196e:	6999      	ldr	r1, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8001970:	681a      	ldr	r2, [r3, #0]
{
 8001972:	b410      	push	{r4}
  if (((itflags & I2C_FLAG_BERR) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
 8001974:	05cc      	lsls	r4, r1, #23
 8001976:	d508      	bpl.n	800198a <HAL_I2C_ER_IRQHandler+0x1e>
 8001978:	0614      	lsls	r4, r2, #24
 800197a:	d506      	bpl.n	800198a <HAL_I2C_ER_IRQHandler+0x1e>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 800197c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800197e:	f044 0401 	orr.w	r4, r4, #1
 8001982:	6444      	str	r4, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8001984:	f44f 7480 	mov.w	r4, #256	; 0x100
 8001988:	61dc      	str	r4, [r3, #28]
  if (((itflags & I2C_FLAG_OVR) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
 800198a:	054c      	lsls	r4, r1, #21
 800198c:	d508      	bpl.n	80019a0 <HAL_I2C_ER_IRQHandler+0x34>
 800198e:	0614      	lsls	r4, r2, #24
 8001990:	d506      	bpl.n	80019a0 <HAL_I2C_ER_IRQHandler+0x34>
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8001992:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8001994:	f044 0408 	orr.w	r4, r4, #8
 8001998:	6444      	str	r4, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800199a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800199e:	61dc      	str	r4, [r3, #28]
  if (((itflags & I2C_FLAG_ARLO) != RESET) && ((itsources & I2C_IT_ERRI) != RESET))
 80019a0:	0589      	lsls	r1, r1, #22
 80019a2:	d508      	bpl.n	80019b6 <HAL_I2C_ER_IRQHandler+0x4a>
 80019a4:	0612      	lsls	r2, r2, #24
 80019a6:	d506      	bpl.n	80019b6 <HAL_I2C_ER_IRQHandler+0x4a>
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 80019a8:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80019aa:	f042 0202 	orr.w	r2, r2, #2
 80019ae:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 80019b0:	f44f 7200 	mov.w	r2, #512	; 0x200
 80019b4:	61da      	str	r2, [r3, #28]
  if ((hi2c->ErrorCode & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 80019b6:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80019b8:	f013 0f0b 	tst.w	r3, #11
 80019bc:	d004      	beq.n	80019c8 <HAL_I2C_ER_IRQHandler+0x5c>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 80019be:	6c41      	ldr	r1, [r0, #68]	; 0x44
}
 80019c0:	f85d 4b04 	ldr.w	r4, [sp], #4
    I2C_ITError(hi2c, hi2c->ErrorCode);
 80019c4:	f7ff be08 	b.w	80015d8 <I2C_ITError>
}
 80019c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80019cc:	4770      	bx	lr

080019ce <I2C_DMAAbort>:
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80019ce:	6a40      	ldr	r0, [r0, #36]	; 0x24
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80019d0:	6802      	ldr	r2, [r0, #0]
{
 80019d2:	b508      	push	{r3, lr}
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 80019d4:	6853      	ldr	r3, [r2, #4]
 80019d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80019da:	6053      	str	r3, [r2, #4]
  hi2c->hdmatx->XferAbortCallback = NULL;
 80019dc:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80019de:	2300      	movs	r3, #0
 80019e0:	6353      	str	r3, [r2, #52]	; 0x34
  hi2c->hdmarx->XferAbortCallback = NULL;
 80019e2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80019e4:	6353      	str	r3, [r2, #52]	; 0x34
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 80019e6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80019ea:	2b60      	cmp	r3, #96	; 0x60
 80019ec:	d105      	bne.n	80019fa <I2C_DMAAbort+0x2c>
    hi2c->State = HAL_I2C_STATE_READY;
 80019ee:	2320      	movs	r3, #32
 80019f0:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    HAL_I2C_AbortCpltCallback(hi2c);
 80019f4:	f7ff fdef 	bl	80015d6 <HAL_I2C_AbortCpltCallback>
 80019f8:	bd08      	pop	{r3, pc}
    HAL_I2C_ErrorCallback(hi2c);
 80019fa:	f7ff fdeb 	bl	80015d4 <HAL_I2C_ErrorCallback>
 80019fe:	bd08      	pop	{r3, pc}

08001a00 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001a00:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8001a04:	b2d2      	uxtb	r2, r2
 8001a06:	2a20      	cmp	r2, #32
{
 8001a08:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001a0a:	d11d      	bne.n	8001a48 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001a0c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001a10:	2b01      	cmp	r3, #1
 8001a12:	d019      	beq.n	8001a48 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001a14:	2324      	movs	r3, #36	; 0x24
 8001a16:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001a1a:	6803      	ldr	r3, [r0, #0]
 8001a1c:	681c      	ldr	r4, [r3, #0]
 8001a1e:	f024 0401 	bic.w	r4, r4, #1
 8001a22:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8001a24:	681c      	ldr	r4, [r3, #0]
 8001a26:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8001a2a:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8001a2c:	681c      	ldr	r4, [r3, #0]
 8001a2e:	4321      	orrs	r1, r4
 8001a30:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001a32:	6819      	ldr	r1, [r3, #0]
 8001a34:	f041 0101 	orr.w	r1, r1, #1
 8001a38:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001a3a:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001a3c:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001a40:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001a44:	4618      	mov	r0, r3
 8001a46:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8001a48:	2002      	movs	r0, #2
  }
}
 8001a4a:	bd10      	pop	{r4, pc}

08001a4c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8001a4c:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001a4e:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 8001a52:	b2e4      	uxtb	r4, r4
 8001a54:	2c20      	cmp	r4, #32
 8001a56:	d11c      	bne.n	8001a92 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001a58:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001a5c:	2b01      	cmp	r3, #1
 8001a5e:	d018      	beq.n	8001a92 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001a60:	2324      	movs	r3, #36	; 0x24
 8001a62:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001a66:	6803      	ldr	r3, [r0, #0]
 8001a68:	681a      	ldr	r2, [r3, #0]
 8001a6a:	f022 0201 	bic.w	r2, r2, #1
 8001a6e:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8001a70:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8001a72:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8001a76:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8001a7a:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001a7c:	681a      	ldr	r2, [r3, #0]
 8001a7e:	f042 0201 	orr.w	r2, r2, #1
 8001a82:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001a84:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001a86:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001a8a:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001a8e:	4618      	mov	r0, r3
 8001a90:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8001a92:	2002      	movs	r0, #2
  }
}
 8001a94:	bd10      	pop	{r4, pc}

08001a96 <HAL_IWDG_Init>:
  * @param  hiwdg  pointer to a IWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified IWDG module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
 8001a96:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if(hiwdg == NULL)
 8001a98:	4604      	mov	r4, r0
 8001a9a:	b300      	cbz	r0, 8001ade <HAL_IWDG_Init+0x48>
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));
  assert_param(IS_IWDG_WINDOW(hiwdg->Init.Window));

  /* Enable IWDG. LSI is turned on automaticaly */
  __HAL_IWDG_START(hiwdg);
 8001a9c:	6803      	ldr	r3, [r0, #0]
 8001a9e:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8001aa2:	601a      	str	r2, [r3, #0]

  /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 8001aa4:	f245 5255 	movw	r2, #21845	; 0x5555
 8001aa8:	601a      	str	r2, [r3, #0]

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
 8001aaa:	6842      	ldr	r2, [r0, #4]
 8001aac:	605a      	str	r2, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 8001aae:	6882      	ldr	r2, [r0, #8]
 8001ab0:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
 8001ab2:	f7fe fc0b 	bl	80002cc <HAL_GetTick>
 8001ab6:	4605      	mov	r5, r0

   /* Wait for register to be updated */
  while(hiwdg->Instance->SR != RESET)
 8001ab8:	6823      	ldr	r3, [r4, #0]
 8001aba:	68d8      	ldr	r0, [r3, #12]
 8001abc:	b940      	cbnz	r0, 8001ad0 <HAL_IWDG_Init+0x3a>
    }
  }

  /* If window parameter is different than current value, modify window 
  register */
  if(hiwdg->Instance->WINR != hiwdg->Init.Window)
 8001abe:	68e2      	ldr	r2, [r4, #12]
 8001ac0:	6919      	ldr	r1, [r3, #16]
 8001ac2:	4291      	cmp	r1, r2
    hiwdg->Instance->WINR = hiwdg->Init.Window;
  }
  else
  {
    /* Reload IWDG counter with value defined in the reload register */
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8001ac4:	bf0a      	itet	eq
 8001ac6:	f64a 22aa 	movweq	r2, #43690	; 0xaaaa
    hiwdg->Instance->WINR = hiwdg->Init.Window;
 8001aca:	611a      	strne	r2, [r3, #16]
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8001acc:	601a      	streq	r2, [r3, #0]
 8001ace:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > HAL_IWDG_DEFAULT_TIMEOUT)
 8001ad0:	f7fe fbfc 	bl	80002cc <HAL_GetTick>
 8001ad4:	1b40      	subs	r0, r0, r5
 8001ad6:	2830      	cmp	r0, #48	; 0x30
 8001ad8:	d9ee      	bls.n	8001ab8 <HAL_IWDG_Init+0x22>
      return HAL_TIMEOUT;
 8001ada:	2003      	movs	r0, #3
  }

  /* Return function status */
  return HAL_OK;
}
 8001adc:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001ade:	2001      	movs	r0, #1
 8001ae0:	bd38      	pop	{r3, r4, r5, pc}

08001ae2 <HAL_IWDG_Refresh>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8001ae2:	6803      	ldr	r3, [r0, #0]
 8001ae4:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8001ae8:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8001aea:	2000      	movs	r0, #0
 8001aec:	4770      	bx	lr

08001aee <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8001aee:	b538      	push	{r3, r4, r5, lr}
  uint32_t i = 0U;

  uint32_t wInterrupt_Mask = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8001af0:	4604      	mov	r4, r0
 8001af2:	2800      	cmp	r0, #0
 8001af4:	d04d      	beq.n	8001b92 <HAL_PCD_Init+0xa4>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if(hpcd->State == HAL_PCD_STATE_RESET)
 8001af6:	f890 3371 	ldrb.w	r3, [r0, #881]	; 0x371
 8001afa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001afe:	b91b      	cbnz	r3, 8001b08 <HAL_PCD_Init+0x1a>
  {  
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8001b00:	f880 2370 	strb.w	r2, [r0, #880]	; 0x370
  
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 8001b04:	f005 f946 	bl	8006d94 <HAL_PCD_MspInit>
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8001b08:	2303      	movs	r3, #3
 
 /* Init endpoints structures */
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 8001b0a:	2100      	movs	r1, #0
 8001b0c:	6860      	ldr	r0, [r4, #4]
  hpcd->State = HAL_PCD_STATE_BUSY;
 8001b0e:	f884 3371 	strb.w	r3, [r4, #881]	; 0x371
 8001b12:	460a      	mov	r2, r1
 8001b14:	f104 0328 	add.w	r3, r4, #40	; 0x28
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8001b18:	2501      	movs	r5, #1
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 8001b1a:	4281      	cmp	r1, r0
 8001b1c:	f103 031c 	add.w	r3, r3, #28
 8001b20:	d11b      	bne.n	8001b5a <HAL_PCD_Init+0x6c>
 8001b22:	2000      	movs	r0, #0
 8001b24:	f504 72e6 	add.w	r2, r4, #460	; 0x1cc
 8001b28:	4603      	mov	r3, r0
   hpcd->IN_ep[i].maxpacket =  0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 8001b2a:	4281      	cmp	r1, r0
 8001b2c:	f102 021c 	add.w	r2, r2, #28
 8001b30:	d121      	bne.n	8001b76 <HAL_PCD_Init+0x88>
   hpcd->OUT_ep[i].xfer_len = 0U;
 }
  
 /* Init Device */
 /*CNTR_FRES = 1U*/
 hpcd->Instance->CNTR = USB_CNTR_FRES;
 8001b32:	6822      	ldr	r2, [r4, #0]
 8001b34:	2101      	movs	r1, #1
  /*set wInterrupt_Mask global variable*/
  wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
  | USB_CNTR_SOFM | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /*Set interrupt mask*/
  hpcd->Instance->CNTR = wInterrupt_Mask;
 8001b36:	f44f 403f 	mov.w	r0, #48896	; 0xbf00
 hpcd->Instance->CNTR = USB_CNTR_FRES;
 8001b3a:	f8a2 1040 	strh.w	r1, [r2, #64]	; 0x40
 hpcd->Instance->CNTR = 0U;
 8001b3e:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
 hpcd->Instance->ISTR = 0U;
 8001b42:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
 hpcd->Instance->BTABLE = BTABLE_ADDRESS;
 8001b46:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
  hpcd->Instance->CNTR = wInterrupt_Mask;
 8001b4a:	f8a2 0040 	strh.w	r0, [r2, #64]	; 0x40
  
  hpcd->USB_Address = 0U;
 8001b4e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  hpcd->State= HAL_PCD_STATE_READY;

 return HAL_OK;
 8001b52:	2000      	movs	r0, #0
  hpcd->State= HAL_PCD_STATE_READY;
 8001b54:	f884 1371 	strb.w	r1, [r4, #881]	; 0x371
 return HAL_OK;
 8001b58:	bd38      	pop	{r3, r4, r5, pc}
   hpcd->IN_ep[i].num = i;
 8001b5a:	f803 1c1c 	strb.w	r1, [r3, #-28]
   hpcd->IN_ep[i].is_in = 1U;
 8001b5e:	f803 5c1b 	strb.w	r5, [r3, #-27]
   hpcd->IN_ep[i].type = PCD_EP_TYPE_CTRL;
 8001b62:	f803 2c19 	strb.w	r2, [r3, #-25]
   hpcd->IN_ep[i].maxpacket =  0U;
 8001b66:	f843 2c10 	str.w	r2, [r3, #-16]
   hpcd->IN_ep[i].xfer_buff = 0U;
 8001b6a:	f843 2c0c 	str.w	r2, [r3, #-12]
   hpcd->IN_ep[i].xfer_len = 0U;
 8001b6e:	f843 2c08 	str.w	r2, [r3, #-8]
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 8001b72:	3101      	adds	r1, #1
 8001b74:	e7d1      	b.n	8001b1a <HAL_PCD_Init+0x2c>
   hpcd->OUT_ep[i].num = i;
 8001b76:	f802 0c1c 	strb.w	r0, [r2, #-28]
   hpcd->OUT_ep[i].is_in = 0U;
 8001b7a:	f802 3c1b 	strb.w	r3, [r2, #-27]
   hpcd->OUT_ep[i].type = PCD_EP_TYPE_CTRL;
 8001b7e:	f802 3c19 	strb.w	r3, [r2, #-25]
   hpcd->OUT_ep[i].maxpacket = 0U;
 8001b82:	f842 3c10 	str.w	r3, [r2, #-16]
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8001b86:	f842 3c0c 	str.w	r3, [r2, #-12]
   hpcd->OUT_ep[i].xfer_len = 0U;
 8001b8a:	f842 3c08 	str.w	r3, [r2, #-8]
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 8001b8e:	3001      	adds	r0, #1
 8001b90:	e7cb      	b.n	8001b2a <HAL_PCD_Init+0x3c>
    return HAL_ERROR;
 8001b92:	2001      	movs	r0, #1
}
 8001b94:	bd38      	pop	{r3, r4, r5, pc}

08001b96 <HAL_PCD_Start>:
  * @brief  Start the USB device.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8001b96:	b508      	push	{r3, lr}
  /*  DP Pull-Down is external */
  HAL_PCDEx_SetConnectionState (hpcd, 1U);
 8001b98:	2101      	movs	r1, #1
 8001b9a:	f005 fa3e 	bl	800701a <HAL_PCDEx_SetConnectionState>
  
  return HAL_OK;
}
 8001b9e:	2000      	movs	r0, #0
 8001ba0:	bd08      	pop	{r3, pc}

08001ba2 <HAL_PCD_SetAddress>:
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
   __HAL_LOCK(hpcd); 
 8001ba2:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 8001ba6:	2b01      	cmp	r3, #1
 8001ba8:	d00f      	beq.n	8001bca <HAL_PCD_SetAddress+0x28>
 8001baa:	2301      	movs	r3, #1
 8001bac:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370

   if(address == 0U) 
 8001bb0:	b941      	cbnz	r1, 8001bc4 <HAL_PCD_SetAddress+0x22>
   {
     /* set device address and enable function */
     hpcd->Instance->DADDR = USB_DADDR_EF;
 8001bb2:	6803      	ldr	r3, [r0, #0]
 8001bb4:	2280      	movs	r2, #128	; 0x80
 8001bb6:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
   else /* USB Address will be applied later */
   {
     hpcd->USB_Address = address;
   }

  __HAL_UNLOCK(hpcd);   
 8001bba:	2300      	movs	r3, #0
 8001bbc:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 8001bc0:	4618      	mov	r0, r3
 8001bc2:	4770      	bx	lr
     hpcd->USB_Address = address;
 8001bc4:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
 8001bc8:	e7f7      	b.n	8001bba <HAL_PCD_SetAddress+0x18>
   __HAL_LOCK(hpcd); 
 8001bca:	2002      	movs	r0, #2
  return HAL_OK;
}
 8001bcc:	4770      	bx	lr
	...

08001bd0 <HAL_PCD_EP_Open>:
  * @param  ep_mps endpoint max packet size
  * @param  ep_type endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8001bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8001bd2:	b24c      	sxtb	r4, r1
 8001bd4:	2c00      	cmp	r4, #0
 8001bd6:	f001 067f 	and.w	r6, r1, #127	; 0x7f
 8001bda:	f04f 051c 	mov.w	r5, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001bde:	bfb5      	itete	lt
 8001be0:	fb05 0106 	mlalt	r1, r5, r6, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001be4:	fb05 0101 	mlage	r1, r5, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001be8:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8001bea:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001bee:	0fe4      	lsrs	r4, r4, #31
  ep->num   = ep_addr & 0x7FU;
 8001bf0:	700e      	strb	r6, [r1, #0]
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001bf2:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 8001bf4:	70cb      	strb	r3, [r1, #3]
  
  __HAL_LOCK(hpcd); 
 8001bf6:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
  ep->maxpacket = ep_mps;
 8001bfa:	60ca      	str	r2, [r1, #12]
  __HAL_LOCK(hpcd); 
 8001bfc:	2b01      	cmp	r3, #1
 8001bfe:	f000 8160 	beq.w	8001ec2 <HAL_PCD_EP_Open+0x2f2>
 8001c02:	2301      	movs	r3, #1
 8001c04:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370

  /* initialize Endpoint */
  switch (ep->type)
 8001c08:	78cd      	ldrb	r5, [r1, #3]
 8001c0a:	780c      	ldrb	r4, [r1, #0]
 8001c0c:	6803      	ldr	r3, [r0, #0]
 8001c0e:	2d03      	cmp	r5, #3
 8001c10:	d80e      	bhi.n	8001c30 <HAL_PCD_EP_Open+0x60>
 8001c12:	e8df f005 	tbb	[pc, r5]
 8001c16:	6402      	.short	0x6402
 8001c18:	5a52      	.short	0x5a52
  {
  case PCD_EP_TYPE_CTRL:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_CONTROL);
 8001c1a:	b224      	sxth	r4, r4
 8001c1c:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 8001c20:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 8001c24:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 8001c28:	f445 7500 	orr.w	r5, r5, #512	; 0x200
    break;
  case PCD_EP_TYPE_INTR:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
    break;
  case PCD_EP_TYPE_ISOC:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
 8001c2c:	f823 5024 	strh.w	r5, [r3, r4, lsl #2]
    break;
  default:
    break;
  } 
  
  PCD_SET_EP_ADDRESS(hpcd->Instance, ep->num, ep->num);
 8001c30:	780c      	ldrb	r4, [r1, #0]
 8001c32:	b226      	sxth	r6, r4
 8001c34:	f640 770f 	movw	r7, #3855	; 0xf0f
 8001c38:	f833 5026 	ldrh.w	r5, [r3, r6, lsl #2]
 8001c3c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 8001c40:	403d      	ands	r5, r7
 8001c42:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8001c46:	432c      	orrs	r4, r5
 8001c48:	f823 4026 	strh.w	r4, [r3, r6, lsl #2]
  
  if (ep->doublebuffer == 0U) 
 8001c4c:	7a8c      	ldrb	r4, [r1, #10]
 8001c4e:	f891 e000 	ldrb.w	lr, [r1]
 8001c52:	2c00      	cmp	r4, #0
 8001c54:	f040 808d 	bne.w	8001d72 <HAL_PCD_EP_Open+0x1a2>
  {
    if (ep->is_in)
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8001c58:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
    if (ep->is_in)
 8001c5c:	784c      	ldrb	r4, [r1, #1]
 8001c5e:	888e      	ldrh	r6, [r1, #4]
      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8001c60:	b2ad      	uxth	r5, r5
    if (ep->is_in)
 8001c62:	2c00      	cmp	r4, #0
 8001c64:	d045      	beq.n	8001cf2 <HAL_PCD_EP_Open+0x122>
      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8001c66:	eb05 05ce 	add.w	r5, r5, lr, lsl #3
 8001c6a:	eb03 0545 	add.w	r5, r3, r5, lsl #1
 8001c6e:	f026 0601 	bic.w	r6, r6, #1
 8001c72:	f8a5 6400 	strh.w	r6, [r5, #1024]	; 0x400
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001c76:	780d      	ldrb	r5, [r1, #0]
 8001c78:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8001c7c:	0654      	lsls	r4, r2, #25
 8001c7e:	bf41      	itttt	mi
 8001c80:	ea02 0407 	andmi.w	r4, r2, r7
 8001c84:	f444 4400 	orrmi.w	r4, r4, #32768	; 0x8000
 8001c88:	f044 04c0 	orrmi.w	r4, r4, #192	; 0xc0
 8001c8c:	f823 4025 	strhmi.w	r4, [r3, r5, lsl #2]
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_NAK) 
 8001c90:	7809      	ldrb	r1, [r1, #0]
 8001c92:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001c96:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8001c9a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001c9e:	b292      	uxth	r2, r2
 8001ca0:	f082 0220 	eor.w	r2, r2, #32
      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8001ca4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001ca8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
      PCD_RX_DTOG(hpcd->Instance, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001cac:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8001cb0:	2300      	movs	r3, #0
 8001cb2:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  return ret;
 8001cb6:	4618      	mov	r0, r3
 8001cb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_BULK);
 8001cba:	b224      	sxth	r4, r4
 8001cbc:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 8001cc0:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 8001cc4:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 8001cc8:	e7b0      	b.n	8001c2c <HAL_PCD_EP_Open+0x5c>
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
 8001cca:	b224      	sxth	r4, r4
 8001ccc:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 8001cd0:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 8001cd4:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 8001cd8:	f445 65c0 	orr.w	r5, r5, #1536	; 0x600
 8001cdc:	e7a6      	b.n	8001c2c <HAL_PCD_EP_Open+0x5c>
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
 8001cde:	b224      	sxth	r4, r4
 8001ce0:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 8001ce4:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 8001ce8:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 8001cec:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 8001cf0:	e79c      	b.n	8001c2c <HAL_PCD_EP_Open+0x5c>
      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8001cf2:	2408      	movs	r4, #8
 8001cf4:	fb14 550e 	smlabb	r5, r4, lr, r5
 8001cf8:	3504      	adds	r5, #4
 8001cfa:	f503 6780 	add.w	r7, r3, #1024	; 0x400
 8001cfe:	f026 0601 	bic.w	r6, r6, #1
 8001d02:	f827 6015 	strh.w	r6, [r7, r5, lsl #1]
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
 8001d06:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 8001d0a:	780e      	ldrb	r6, [r1, #0]
 8001d0c:	b2ad      	uxth	r5, r5
 8001d0e:	fb14 5406 	smlabb	r4, r4, r6, r5
 8001d12:	2a3e      	cmp	r2, #62	; 0x3e
 8001d14:	f104 0406 	add.w	r4, r4, #6
 8001d18:	d925      	bls.n	8001d66 <HAL_PCD_EP_Open+0x196>
 8001d1a:	0955      	lsrs	r5, r2, #5
 8001d1c:	06d2      	lsls	r2, r2, #27
 8001d1e:	bf08      	it	eq
 8001d20:	f105 35ff 	addeq.w	r5, r5, #4294967295
 8001d24:	4a68      	ldr	r2, [pc, #416]	; (8001ec8 <HAL_PCD_EP_Open+0x2f8>)
 8001d26:	bf08      	it	eq
 8001d28:	b2ad      	uxtheq	r5, r5
 8001d2a:	ea42 2585 	orr.w	r5, r2, r5, lsl #10
 8001d2e:	f827 5014 	strh.w	r5, [r7, r4, lsl #1]
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001d32:	780c      	ldrb	r4, [r1, #0]
 8001d34:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001d38:	0455      	lsls	r5, r2, #17
 8001d3a:	d509      	bpl.n	8001d50 <HAL_PCD_EP_Open+0x180>
 8001d3c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001d40:	0512      	lsls	r2, r2, #20
 8001d42:	0d12      	lsrs	r2, r2, #20
 8001d44:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8001d48:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001d4c:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8001d50:	7809      	ldrb	r1, [r1, #0]
 8001d52:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001d56:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001d5a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001d5e:	b292      	uxth	r2, r2
 8001d60:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 8001d64:	e79e      	b.n	8001ca4 <HAL_PCD_EP_Open+0xd4>
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
 8001d66:	0855      	lsrs	r5, r2, #1
 8001d68:	07d6      	lsls	r6, r2, #31
 8001d6a:	bf48      	it	mi
 8001d6c:	3501      	addmi	r5, #1
 8001d6e:	02ad      	lsls	r5, r5, #10
 8001d70:	e7dd      	b.n	8001d2e <HAL_PCD_EP_Open+0x15e>
    PCD_SET_EP_DBUF(hpcd->Instance, ep->num);
 8001d72:	fa0f f58e 	sxth.w	r5, lr
    PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1)
 8001d76:	2208      	movs	r2, #8
    PCD_SET_EP_DBUF(hpcd->Instance, ep->num);
 8001d78:	f833 6025 	ldrh.w	r6, [r3, r5, lsl #2]
 8001d7c:	f426 76f8 	bic.w	r6, r6, #496	; 0x1f0
 8001d80:	0536      	lsls	r6, r6, #20
 8001d82:	0d36      	lsrs	r6, r6, #20
 8001d84:	f446 4601 	orr.w	r6, r6, #33024	; 0x8100
 8001d88:	f046 0680 	orr.w	r6, r6, #128	; 0x80
 8001d8c:	f823 6025 	strh.w	r6, [r3, r5, lsl #2]
    PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1)
 8001d90:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 8001d94:	b2ae      	uxth	r6, r5
 8001d96:	780d      	ldrb	r5, [r1, #0]
 8001d98:	fb12 6505 	smlabb	r5, r2, r5, r6
 8001d9c:	88ce      	ldrh	r6, [r1, #6]
 8001d9e:	f503 6480 	add.w	r4, r3, #1024	; 0x400
 8001da2:	f026 0601 	bic.w	r6, r6, #1
 8001da6:	f824 6015 	strh.w	r6, [r4, r5, lsl #1]
 8001daa:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 8001dae:	780e      	ldrb	r6, [r1, #0]
 8001db0:	b2ad      	uxth	r5, r5
 8001db2:	fb12 5206 	smlabb	r2, r2, r6, r5
 8001db6:	890d      	ldrh	r5, [r1, #8]
 8001db8:	3204      	adds	r2, #4
 8001dba:	f025 0501 	bic.w	r5, r5, #1
 8001dbe:	f824 5012 	strh.w	r5, [r4, r2, lsl #1]
 8001dc2:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in==0U)
 8001dc4:	784c      	ldrb	r4, [r1, #1]
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001dc6:	b212      	sxth	r2, r2
    if (ep->is_in==0U)
 8001dc8:	2c00      	cmp	r4, #0
 8001dca:	d13f      	bne.n	8001e4c <HAL_PCD_EP_Open+0x27c>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001dcc:	f833 5022 	ldrh.w	r5, [r3, r2, lsl #2]
 8001dd0:	046c      	lsls	r4, r5, #17
 8001dd2:	bf41      	itttt	mi
 8001dd4:	ea05 0407 	andmi.w	r4, r5, r7
 8001dd8:	f444 4440 	orrmi.w	r4, r4, #49152	; 0xc000
 8001ddc:	f044 0480 	orrmi.w	r4, r4, #128	; 0x80
 8001de0:	f823 4022 	strhmi.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001de4:	780c      	ldrb	r4, [r1, #0]
 8001de6:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001dea:	0657      	lsls	r7, r2, #25
 8001dec:	d509      	bpl.n	8001e02 <HAL_PCD_EP_Open+0x232>
 8001dee:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001df2:	0512      	lsls	r2, r2, #20
 8001df4:	0d12      	lsrs	r2, r2, #20
 8001df6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001dfa:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8001dfe:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 8001e02:	780c      	ldrb	r4, [r1, #0]
 8001e04:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001e08:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001e0c:	0512      	lsls	r2, r2, #20
 8001e0e:	0d12      	lsrs	r2, r2, #20
 8001e10:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001e14:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8001e18:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8001e1c:	780d      	ldrb	r5, [r1, #0]
 8001e1e:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8001e22:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001e26:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001e2a:	b292      	uxth	r2, r2
 8001e2c:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 8001e30:	f248 0480 	movw	r4, #32896	; 0x8080
 8001e34:	4322      	orrs	r2, r4
 8001e36:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8001e3a:	7809      	ldrb	r1, [r1, #0]
 8001e3c:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001e40:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8001e44:	f022 0240 	bic.w	r2, r2, #64	; 0x40
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001e48:	4322      	orrs	r2, r4
 8001e4a:	e72f      	b.n	8001cac <HAL_PCD_EP_Open+0xdc>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001e4c:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8001e50:	0466      	lsls	r6, r4, #17
 8001e52:	bf41      	itttt	mi
 8001e54:	403c      	andmi	r4, r7
 8001e56:	f444 4440 	orrmi.w	r4, r4, #49152	; 0xc000
 8001e5a:	f044 0480 	orrmi.w	r4, r4, #128	; 0x80
 8001e5e:	f823 4022 	strhmi.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001e62:	780c      	ldrb	r4, [r1, #0]
 8001e64:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001e68:	0655      	lsls	r5, r2, #25
 8001e6a:	d509      	bpl.n	8001e80 <HAL_PCD_EP_Open+0x2b0>
 8001e6c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001e70:	0512      	lsls	r2, r2, #20
 8001e72:	0d12      	lsrs	r2, r2, #20
 8001e74:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001e78:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8001e7c:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8001e80:	780c      	ldrb	r4, [r1, #0]
 8001e82:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001e86:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001e8a:	0512      	lsls	r2, r2, #20
 8001e8c:	0d12      	lsrs	r2, r2, #20
 8001e8e:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8001e92:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001e96:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8001e9a:	780d      	ldrb	r5, [r1, #0]
 8001e9c:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8001ea0:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8001ea4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8001ea8:	f248 0480 	movw	r4, #32896	; 0x8080
 8001eac:	4322      	orrs	r2, r4
 8001eae:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001eb2:	7809      	ldrb	r1, [r1, #0]
 8001eb4:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001eb8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001ebc:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001ec0:	e7c2      	b.n	8001e48 <HAL_PCD_EP_Open+0x278>
  __HAL_LOCK(hpcd); 
 8001ec2:	2002      	movs	r0, #2
}
 8001ec4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ec6:	bf00      	nop
 8001ec8:	ffff8000 	.word	0xffff8000

08001ecc <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8001ecc:	b24b      	sxtb	r3, r1
 8001ece:	2b00      	cmp	r3, #0
{  
 8001ed0:	b530      	push	{r4, r5, lr}
 8001ed2:	f04f 021c 	mov.w	r2, #28
 8001ed6:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001eda:	bfb5      	itete	lt
 8001edc:	fb02 0104 	mlalt	r1, r2, r4, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001ee0:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001ee4:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 8001ee6:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001eea:	0fdb      	lsrs	r3, r3, #31
  ep->num   = ep_addr & 0x7FU;
 8001eec:	700c      	strb	r4, [r1, #0]
  ep->is_in = (0x80U & ep_addr) != 0U;
 8001eee:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8001ef0:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 8001ef4:	2b01      	cmp	r3, #1
 8001ef6:	f000 80bf 	beq.w	8002078 <HAL_PCD_EP_Close+0x1ac>
 8001efa:	2301      	movs	r3, #1
 8001efc:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 8001f00:	780a      	ldrb	r2, [r1, #0]

  if (ep->doublebuffer == 0U) 
 8001f02:	7a8d      	ldrb	r5, [r1, #10]
 8001f04:	784c      	ldrb	r4, [r1, #1]
 8001f06:	6803      	ldr	r3, [r0, #0]
  {
    if (ep->is_in)
    {
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001f08:	b212      	sxth	r2, r2
  if (ep->doublebuffer == 0U) 
 8001f0a:	bbb5      	cbnz	r5, 8001f7a <HAL_PCD_EP_Close+0xae>
    if (ep->is_in)
 8001f0c:	b1fc      	cbz	r4, 8001f4e <HAL_PCD_EP_Close+0x82>
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001f0e:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8001f12:	0665      	lsls	r5, r4, #25
 8001f14:	d509      	bpl.n	8001f2a <HAL_PCD_EP_Close+0x5e>
 8001f16:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8001f1a:	0524      	lsls	r4, r4, #20
 8001f1c:	0d24      	lsrs	r4, r4, #20
 8001f1e:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 8001f22:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 8001f26:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS) 
 8001f2a:	7809      	ldrb	r1, [r1, #0]
 8001f2c:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001f30:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8001f34:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    }
    else
    {
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001f38:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001f3c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
      PCD_RX_DTOG(hpcd->Instance, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001f40:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8001f44:	2300      	movs	r3, #0
 8001f46:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  return HAL_OK;
 8001f4a:	4618      	mov	r0, r3
 8001f4c:	bd30      	pop	{r4, r5, pc}
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001f4e:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8001f52:	0465      	lsls	r5, r4, #17
 8001f54:	d509      	bpl.n	8001f6a <HAL_PCD_EP_Close+0x9e>
 8001f56:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8001f5a:	0524      	lsls	r4, r4, #20
 8001f5c:	0d24      	lsrs	r4, r4, #20
 8001f5e:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8001f62:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8001f66:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001f6a:	7809      	ldrb	r1, [r1, #0]
 8001f6c:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001f70:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001f74:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001f78:	e7de      	b.n	8001f38 <HAL_PCD_EP_Close+0x6c>
    if (ep->is_in==0U)
 8001f7a:	2c00      	cmp	r4, #0
 8001f7c:	d13e      	bne.n	8001ffc <HAL_PCD_EP_Close+0x130>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001f7e:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8001f82:	0465      	lsls	r5, r4, #17
 8001f84:	d509      	bpl.n	8001f9a <HAL_PCD_EP_Close+0xce>
 8001f86:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8001f8a:	0524      	lsls	r4, r4, #20
 8001f8c:	0d24      	lsrs	r4, r4, #20
 8001f8e:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8001f92:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8001f96:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8001f9a:	780c      	ldrb	r4, [r1, #0]
 8001f9c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001fa0:	0655      	lsls	r5, r2, #25
 8001fa2:	d509      	bpl.n	8001fb8 <HAL_PCD_EP_Close+0xec>
 8001fa4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001fa8:	0512      	lsls	r2, r2, #20
 8001faa:	0d12      	lsrs	r2, r2, #20
 8001fac:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001fb0:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8001fb4:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 8001fb8:	780c      	ldrb	r4, [r1, #0]
 8001fba:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8001fbe:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001fc2:	0512      	lsls	r2, r2, #20
 8001fc4:	0d12      	lsrs	r2, r2, #20
 8001fc6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001fca:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8001fce:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001fd2:	780d      	ldrb	r5, [r1, #0]
 8001fd4:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8001fd8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001fdc:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001fe0:	f248 0480 	movw	r4, #32896	; 0x8080
 8001fe4:	4322      	orrs	r2, r4
 8001fe6:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8001fea:	7809      	ldrb	r1, [r1, #0]
 8001fec:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8001ff0:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8001ff4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8001ff8:	4322      	orrs	r2, r4
 8001ffa:	e7a1      	b.n	8001f40 <HAL_PCD_EP_Close+0x74>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8001ffc:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8002000:	0465      	lsls	r5, r4, #17
 8002002:	d509      	bpl.n	8002018 <HAL_PCD_EP_Close+0x14c>
 8002004:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8002008:	0524      	lsls	r4, r4, #20
 800200a:	0d24      	lsrs	r4, r4, #20
 800200c:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8002010:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8002014:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8002018:	780c      	ldrb	r4, [r1, #0]
 800201a:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800201e:	0655      	lsls	r5, r2, #25
 8002020:	d509      	bpl.n	8002036 <HAL_PCD_EP_Close+0x16a>
 8002022:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002026:	0512      	lsls	r2, r2, #20
 8002028:	0d12      	lsrs	r2, r2, #20
 800202a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800202e:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8002032:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8002036:	780c      	ldrb	r4, [r1, #0]
 8002038:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800203c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8002040:	0512      	lsls	r2, r2, #20
 8002042:	0d12      	lsrs	r2, r2, #20
 8002044:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8002048:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800204c:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8002050:	780d      	ldrb	r5, [r1, #0]
 8002052:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8002056:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 800205a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800205e:	f248 0480 	movw	r4, #32896	; 0x8080
 8002062:	4322      	orrs	r2, r4
 8002064:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8002068:	7809      	ldrb	r1, [r1, #0]
 800206a:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 800206e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8002072:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8002076:	e7bf      	b.n	8001ff8 <HAL_PCD_EP_Close+0x12c>
  __HAL_LOCK(hpcd); 
 8002078:	2002      	movs	r0, #2
}
 800207a:	bd30      	pop	{r4, r5, pc}

0800207c <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer   
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800207c:	b570      	push	{r4, r5, r6, lr}
 800207e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 PCD_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8002082:	241c      	movs	r4, #28
 8002084:	fb04 0501 	mla	r5, r4, r1, r0
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 8002088:	2600      	movs	r6, #0
  ep->xfer_buff = pBuf;  
 800208a:	f8c5 21dc 	str.w	r2, [r5, #476]	; 0x1dc
  ep->is_in = 0U;
  ep->num = ep_addr & 0x7FU;

  /* Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 800208e:	f8d5 21d8 	ldr.w	r2, [r5, #472]	; 0x1d8
  ep->xfer_len = len;
 8002092:	f8c5 31e0 	str.w	r3, [r5, #480]	; 0x1e0
  if (ep->xfer_len > ep->maxpacket)
 8002096:	4293      	cmp	r3, r2
  {
    len=ep->maxpacket;
    ep->xfer_len-=len; 
 8002098:	bf86      	itte	hi
 800209a:	1a9b      	subhi	r3, r3, r2
 800209c:	f8c5 31e0 	strhi.w	r3, [r5, #480]	; 0x1e0
  }
  else
  {
    len=ep->xfer_len;
    ep->xfer_len =0U;
 80020a0:	461a      	movls	r2, r3
  }
  
  /* configure and validate Rx endpoint */
  if (ep->doublebuffer == 0U) 
 80020a2:	fb04 0301 	mla	r3, r4, r1, r0
  ep->xfer_count = 0U;
 80020a6:	f8c5 61e4 	str.w	r6, [r5, #484]	; 0x1e4
  ep->is_in = 0U;
 80020aa:	f885 61cd 	strb.w	r6, [r5, #461]	; 0x1cd
  ep->num = ep_addr & 0x7FU;
 80020ae:	f885 11cc 	strb.w	r1, [r5, #460]	; 0x1cc
    ep->xfer_len =0U;
 80020b2:	bf98      	it	ls
 80020b4:	f8c5 61e0 	strls.w	r6, [r5, #480]	; 0x1e0
  if (ep->doublebuffer == 0U) 
 80020b8:	f893 51d6 	ldrb.w	r5, [r3, #470]	; 0x1d6
 80020bc:	6804      	ldr	r4, [r0, #0]
 80020be:	bb7d      	cbnz	r5, 8002120 <HAL_PCD_EP_Receive+0xa4>
    PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, len)
  }
  else
  {
    /*Set the Double buffer counter*/
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len)
 80020c0:	f8b4 5050 	ldrh.w	r5, [r4, #80]	; 0x50
 80020c4:	f893 31cc 	ldrb.w	r3, [r3, #460]	; 0x1cc
 80020c8:	b2ad      	uxth	r5, r5
 80020ca:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 80020ce:	2a3e      	cmp	r2, #62	; 0x3e
 80020d0:	f103 0306 	add.w	r3, r3, #6
 80020d4:	f504 6680 	add.w	r6, r4, #1024	; 0x400
 80020d8:	d934      	bls.n	8002144 <HAL_PCD_EP_Receive+0xc8>
 80020da:	f3c2 154f 	ubfx	r5, r2, #5, #16
 80020de:	06d2      	lsls	r2, r2, #27
 80020e0:	bf08      	it	eq
 80020e2:	f105 35ff 	addeq.w	r5, r5, #4294967295
 80020e6:	4a1b      	ldr	r2, [pc, #108]	; (8002154 <HAL_PCD_EP_Receive+0xd8>)
 80020e8:	bf08      	it	eq
 80020ea:	b2ad      	uxtheq	r5, r5
 80020ec:	ea42 2585 	orr.w	r5, r2, r5, lsl #10
 80020f0:	f826 5013 	strh.w	r5, [r6, r3, lsl #1]
  } 
  
  PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 80020f4:	231c      	movs	r3, #28
 80020f6:	fb03 0001 	mla	r0, r3, r1, r0
 80020fa:	f890 21cc 	ldrb.w	r2, [r0, #460]	; 0x1cc
 80020fe:	f834 3022 	ldrh.w	r3, [r4, r2, lsl #2]
 8002102:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002106:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800210a:	b29b      	uxth	r3, r3
 800210c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8002110:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002114:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002118:	f824 3022 	strh.w	r3, [r4, r2, lsl #2]

  return HAL_OK;
}
 800211c:	2000      	movs	r0, #0
 800211e:	bd70      	pop	{r4, r5, r6, pc}
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len)
 8002120:	f893 51cd 	ldrb.w	r5, [r3, #461]	; 0x1cd
 8002124:	2d00      	cmp	r5, #0
 8002126:	d0cb      	beq.n	80020c0 <HAL_PCD_EP_Receive+0x44>
 8002128:	2d01      	cmp	r5, #1
 800212a:	d1e3      	bne.n	80020f4 <HAL_PCD_EP_Receive+0x78>
 800212c:	f8b4 5050 	ldrh.w	r5, [r4, #80]	; 0x50
 8002130:	f893 31cc 	ldrb.w	r3, [r3, #460]	; 0x1cc
 8002134:	b2ad      	uxth	r5, r5
 8002136:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 800213a:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 800213e:	f8a3 240c 	strh.w	r2, [r3, #1036]	; 0x40c
 8002142:	e7d7      	b.n	80020f4 <HAL_PCD_EP_Receive+0x78>
 8002144:	f3c2 054f 	ubfx	r5, r2, #1, #16
 8002148:	07d2      	lsls	r2, r2, #31
 800214a:	bf44      	itt	mi
 800214c:	3501      	addmi	r5, #1
 800214e:	b2ad      	uxthmi	r5, r5
 8002150:	02ad      	lsls	r5, r5, #10
 8002152:	e7cd      	b.n	80020f0 <HAL_PCD_EP_Receive+0x74>
 8002154:	ffff8000 	.word	0xffff8000

08002158 <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7F].xfer_count;
 8002158:	231c      	movs	r3, #28
 800215a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800215e:	fb03 0101 	mla	r1, r3, r1, r0
}
 8002162:	f8b1 01e4 	ldrh.w	r0, [r1, #484]	; 0x1e4
 8002166:	4770      	bx	lr

08002168 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer   
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8002168:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800216a:	f001 077f 	and.w	r7, r1, #127	; 0x7f
  uint16_t pmabuffer = 0U;
    
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 800216e:	241c      	movs	r4, #28
 8002170:	fb04 0107 	mla	r1, r4, r7, r0
{
 8002174:	4605      	mov	r5, r0
  ep->xfer_count = 0U;
  ep->is_in = 1U;
  ep->num = ep_addr & 0x7FU;

  /*Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 8002176:	6b4e      	ldr	r6, [r1, #52]	; 0x34
  ep->xfer_len = len;
 8002178:	63cb      	str	r3, [r1, #60]	; 0x3c
  if (ep->xfer_len > ep->maxpacket)
 800217a:	42b3      	cmp	r3, r6
  {
    len=ep->maxpacket;
    ep->xfer_len-=len; 
 800217c:	bf88      	it	hi
 800217e:	1b9b      	subhi	r3, r3, r6
  ep->xfer_buff = pBuf;  
 8002180:	638a      	str	r2, [r1, #56]	; 0x38
  ep->is_in = 1U;
 8002182:	f04f 0001 	mov.w	r0, #1
  ep->xfer_count = 0U;
 8002186:	f04f 0200 	mov.w	r2, #0
    len=ep->xfer_len;
    ep->xfer_len =0U;
  }
  
  /* configure and validate Tx endpoint */
  if (ep->doublebuffer == 0U) 
 800218a:	fb04 5407 	mla	r4, r4, r7, r5
  ep->xfer_count = 0U;
 800218e:	640a      	str	r2, [r1, #64]	; 0x40
  ep->is_in = 1U;
 8002190:	f881 0029 	strb.w	r0, [r1, #41]	; 0x29
  ep->num = ep_addr & 0x7FU;
 8002194:	f881 7028 	strb.w	r7, [r1, #40]	; 0x28
    ep->xfer_len-=len; 
 8002198:	bf8e      	itee	hi
 800219a:	63cb      	strhi	r3, [r1, #60]	; 0x3c
    ep->xfer_len =0U;
 800219c:	63ca      	strls	r2, [r1, #60]	; 0x3c
 800219e:	461e      	movls	r6, r3
  if (ep->doublebuffer == 0U) 
 80021a0:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
 80021a4:	b2b6      	uxth	r6, r6
 80021a6:	bb43      	cbnz	r3, 80021fa <HAL_PCD_EP_Transmit+0x92>
  {
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, len);
 80021a8:	4633      	mov	r3, r6
 80021aa:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80021ac:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80021ae:	6828      	ldr	r0, [r5, #0]
 80021b0:	f000 fb62 	bl	8002878 <PCD_WritePMA>
    PCD_SET_EP_TX_CNT(hpcd->Instance, ep->num, len);
 80021b4:	682a      	ldr	r2, [r5, #0]
 80021b6:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 80021ba:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 80021be:	b29b      	uxth	r3, r3
 80021c0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80021c4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80021c8:	f8a3 6404 	strh.w	r6, [r3, #1028]	; 0x404
    }
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in)
  }

  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID)
 80021cc:	231c      	movs	r3, #28
 80021ce:	fb03 5707 	mla	r7, r3, r7, r5
 80021d2:	682a      	ldr	r2, [r5, #0]
 80021d4:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 80021d8:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80021dc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80021e0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80021e4:	b29b      	uxth	r3, r3
 80021e6:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 80021ea:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80021ee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80021f2:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]

  return HAL_OK;
}
 80021f6:	2000      	movs	r0, #0
 80021f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 80021fa:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80021fe:	6828      	ldr	r0, [r5, #0]
 8002200:	f830 3023 	ldrh.w	r3, [r0, r3, lsl #2]
 8002204:	065b      	lsls	r3, r3, #25
      pmabuffer = ep->pmaaddr1;
 8002206:	bf4c      	ite	mi
 8002208:	8e22      	ldrhmi	r2, [r4, #48]	; 0x30
      pmabuffer = ep->pmaaddr0;
 800220a:	8de2      	ldrhpl	r2, [r4, #46]	; 0x2e
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
 800220c:	241c      	movs	r4, #28
 800220e:	fb04 5407 	mla	r4, r4, r7, r5
 8002212:	4633      	mov	r3, r6
 8002214:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8002216:	f000 fb2f 	bl	8002878 <PCD_WritePMA>
    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in)
 800221a:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 800221e:	682a      	ldr	r2, [r5, #0]
 8002220:	b973      	cbnz	r3, 8002240 <HAL_PCD_EP_Transmit+0xd8>
 8002222:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8002226:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 800222a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800222e:	051b      	lsls	r3, r3, #20
 8002230:	0d1b      	lsrs	r3, r3, #20
 8002232:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002236:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800223a:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 800223e:	e7c5      	b.n	80021cc <HAL_PCD_EP_Transmit+0x64>
 8002240:	2b01      	cmp	r3, #1
 8002242:	d1c3      	bne.n	80021cc <HAL_PCD_EP_Transmit+0x64>
 8002244:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8002248:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 800224c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002250:	051b      	lsls	r3, r3, #20
 8002252:	0d1b      	lsrs	r3, r3, #20
 8002254:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8002258:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800225c:	e7ed      	b.n	800223a <HAL_PCD_EP_Transmit+0xd2>
	...

08002260 <HAL_PCD_IRQHandler>:
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 8002260:	6803      	ldr	r3, [r0, #0]
 8002262:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8002266:	041b      	lsls	r3, r3, #16
{
 8002268:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800226c:	4604      	mov	r4, r0
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 800226e:	d472      	bmi.n	8002356 <HAL_PCD_IRQHandler+0xf6>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
 8002270:	6823      	ldr	r3, [r4, #0]
 8002272:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8002276:	0557      	lsls	r7, r2, #21
 8002278:	d50a      	bpl.n	8002290 <HAL_PCD_IRQHandler+0x30>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 800227a:	f64f 32ff 	movw	r2, #64511	; 0xfbff
    HAL_PCD_ResetCallback(hpcd);
 800227e:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8002280:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 8002284:	f004 fdcf 	bl	8006e26 <HAL_PCD_ResetCallback>
    HAL_PCD_SetAddress(hpcd, 0U);
 8002288:	2100      	movs	r1, #0
 800228a:	4620      	mov	r0, r4
 800228c:	f7ff fc89 	bl	8001ba2 <HAL_PCD_SetAddress>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 8002290:	6823      	ldr	r3, [r4, #0]
 8002292:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8002296:	0452      	lsls	r2, r2, #17
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 8002298:	bf44      	itt	mi
 800229a:	f64b 72ff 	movwmi	r2, #49151	; 0xbfff
 800229e:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 80022a2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 80022a6:	0497      	lsls	r7, r2, #18
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 80022a8:	bf44      	itt	mi
 80022aa:	f64d 72ff 	movwmi	r2, #57343	; 0xdfff
 80022ae:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
 80022b2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 80022b6:	04d6      	lsls	r6, r2, #19
 80022b8:	d517      	bpl.n	80022ea <HAL_PCD_IRQHandler+0x8a>
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 80022ba:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 80022be:	f022 0204 	bic.w	r2, r2, #4
 80022c2:	0412      	lsls	r2, r2, #16
 80022c4:	0c12      	lsrs	r2, r2, #16
 80022c6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 80022ca:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 80022ce:	f022 0208 	bic.w	r2, r2, #8
 80022d2:	0412      	lsls	r2, r2, #16
 80022d4:	0c12      	lsrs	r2, r2, #16
 80022d6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    HAL_PCD_ResumeCallback(hpcd);
 80022da:	4620      	mov	r0, r4
 80022dc:	f004 fdc0 	bl	8006e60 <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
 80022e0:	6823      	ldr	r3, [r4, #0]
 80022e2:	f64e 72ff 	movw	r2, #61439	; 0xefff
 80022e6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
 80022ea:	6823      	ldr	r3, [r4, #0]
 80022ec:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 80022f0:	0515      	lsls	r5, r2, #20
 80022f2:	d518      	bpl.n	8002326 <HAL_PCD_IRQHandler+0xc6>
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 80022f4:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 80022f8:	b292      	uxth	r2, r2
 80022fa:	f042 0208 	orr.w	r2, r2, #8
 80022fe:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 8002302:	f24f 72ff 	movw	r2, #63487	; 0xf7ff
 8002306:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    hpcd->Instance->CNTR |= USB_CNTR_LPMODE;
 800230a:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 800230e:	b292      	uxth	r2, r2
 8002310:	f042 0204 	orr.w	r2, r2, #4
 8002314:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0U)
 8002318:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 800231c:	04d8      	lsls	r0, r3, #19
 800231e:	d402      	bmi.n	8002326 <HAL_PCD_IRQHandler+0xc6>
      HAL_PCD_SuspendCallback(hpcd);
 8002320:	4620      	mov	r0, r4
 8002322:	f004 fd8d 	bl	8006e40 <HAL_PCD_SuspendCallback>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
 8002326:	6823      	ldr	r3, [r4, #0]
 8002328:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 800232c:	0591      	lsls	r1, r2, #22
 800232e:	d506      	bpl.n	800233e <HAL_PCD_IRQHandler+0xde>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 8002330:	f64f 52ff 	movw	r2, #65023	; 0xfdff
 8002334:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 8002338:	4620      	mov	r0, r4
 800233a:	f004 fd70 	bl	8006e1e <HAL_PCD_SOFCallback>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
 800233e:	6823      	ldr	r3, [r4, #0]
 8002340:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8002344:	05d2      	lsls	r2, r2, #23
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
 8002346:	bf44      	itt	mi
 8002348:	f64f 62ff 	movwmi	r2, #65279	; 0xfeff
 800234c:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
}
 8002350:	b002      	add	sp, #8
 8002352:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __IO uint16_t wEPVal = 0U;
 8002356:	2300      	movs	r3, #0
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8002358:	4fc3      	ldr	r7, [pc, #780]	; (8002668 <HAL_PCD_IRQHandler+0x408>)
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID)
 800235a:	f8df 8310 	ldr.w	r8, [pc, #784]	; 800266c <HAL_PCD_IRQHandler+0x40c>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 800235e:	f8df 9310 	ldr.w	r9, [pc, #784]	; 8002670 <HAL_PCD_IRQHandler+0x410>
  __IO uint16_t wEPVal = 0U;
 8002362:	f8ad 3006 	strh.w	r3, [sp, #6]
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0U)
 8002366:	6820      	ldr	r0, [r4, #0]
 8002368:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 800236c:	b29b      	uxth	r3, r3
 800236e:	0419      	lsls	r1, r3, #16
 8002370:	f8ad 3004 	strh.w	r3, [sp, #4]
 8002374:	f57f af7c 	bpl.w	8002270 <HAL_PCD_IRQHandler+0x10>
    EPindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8002378:	f8bd 6004 	ldrh.w	r6, [sp, #4]
    if (EPindex == 0U)
 800237c:	f016 060f 	ands.w	r6, r6, #15
 8002380:	f040 80a9 	bne.w	80024d6 <HAL_PCD_IRQHandler+0x276>
      if ((wIstr & USB_ISTR_DIR) == 0U)
 8002384:	f8bd 1004 	ldrh.w	r1, [sp, #4]
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8002388:	8803      	ldrh	r3, [r0, #0]
      if ((wIstr & USB_ISTR_DIR) == 0U)
 800238a:	f011 0110 	ands.w	r1, r1, #16
 800238e:	d126      	bne.n	80023de <HAL_PCD_IRQHandler+0x17e>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8002390:	403b      	ands	r3, r7
 8002392:	8003      	strh	r3, [r0, #0]
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8002394:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002398:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 800239c:	b29b      	uxth	r3, r3
 800239e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80023a2:	eb00 0043 	add.w	r0, r0, r3, lsl #1
        ep->xfer_buff += ep->xfer_count;
 80023a6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80023a8:	f8b0 3404 	ldrh.w	r3, [r0, #1028]	; 0x404
 80023ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80023b0:	6423      	str	r3, [r4, #64]	; 0x40
        ep->xfer_buff += ep->xfer_count;
 80023b2:	4413      	add	r3, r2
 80023b4:	63a3      	str	r3, [r4, #56]	; 0x38
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 80023b6:	4620      	mov	r0, r4
 80023b8:	f004 fd29 	bl	8006e0e <HAL_PCD_DataInStageCallback>
        if((hpcd->USB_Address > 0U)&& ( ep->xfer_len == 0U))
 80023bc:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d0d0      	beq.n	8002366 <HAL_PCD_IRQHandler+0x106>
 80023c4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80023c6:	2a00      	cmp	r2, #0
 80023c8:	d1cd      	bne.n	8002366 <HAL_PCD_IRQHandler+0x106>
          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
 80023ca:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 80023ce:	6821      	ldr	r1, [r4, #0]
 80023d0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80023d4:	f8a1 304c 	strh.w	r3, [r1, #76]	; 0x4c
          hpcd->USB_Address = 0U;
 80023d8:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
 80023dc:	e7c3      	b.n	8002366 <HAL_PCD_IRQHandler+0x106>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 80023de:	b29b      	uxth	r3, r3
 80023e0:	f8ad 3006 	strh.w	r3, [sp, #6]
        if ((wEPVal & USB_EP_SETUP) != 0U)
 80023e4:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80023e8:	051e      	lsls	r6, r3, #20
 80023ea:	d51f      	bpl.n	800242c <HAL_PCD_IRQHandler+0x1cc>
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 80023ec:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 80023f0:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
 80023f4:	b29b      	uxth	r3, r3
 80023f6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80023fa:	eb00 0343 	add.w	r3, r0, r3, lsl #1
          PCD_ReadPMA(hpcd->Instance, (uint8_t*)(void*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);
 80023fe:	f8b4 21d0 	ldrh.w	r2, [r4, #464]	; 0x1d0
 8002402:	f8b3 340c 	ldrh.w	r3, [r3, #1036]	; 0x40c
 8002406:	f3c3 0309 	ubfx	r3, r3, #0, #10
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 800240a:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
          PCD_ReadPMA(hpcd->Instance, (uint8_t*)(void*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);
 800240e:	f504 715d 	add.w	r1, r4, #884	; 0x374
 8002412:	f000 fa44 	bl	800289e <PCD_ReadPMA>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8002416:	6822      	ldr	r2, [r4, #0]
 8002418:	8813      	ldrh	r3, [r2, #0]
 800241a:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800241e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002422:	8013      	strh	r3, [r2, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 8002424:	4620      	mov	r0, r4
 8002426:	f004 fce3 	bl	8006df0 <HAL_PCD_SetupStageCallback>
 800242a:	e79c      	b.n	8002366 <HAL_PCD_IRQHandler+0x106>
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 800242c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8002430:	041d      	lsls	r5, r3, #16
 8002432:	d598      	bpl.n	8002366 <HAL_PCD_IRQHandler+0x106>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8002434:	8803      	ldrh	r3, [r0, #0]
 8002436:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 800243a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800243e:	8003      	strh	r3, [r0, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002440:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002444:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
 8002448:	b29b      	uxth	r3, r3
 800244a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800244e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002452:	f8b3 340c 	ldrh.w	r3, [r3, #1036]	; 0x40c
 8002456:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800245a:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
          if (ep->xfer_count != 0U)
 800245e:	b163      	cbz	r3, 800247a <HAL_PCD_IRQHandler+0x21a>
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 8002460:	f8b4 21d0 	ldrh.w	r2, [r4, #464]	; 0x1d0
 8002464:	f8d4 11dc 	ldr.w	r1, [r4, #476]	; 0x1dc
 8002468:	f000 fa19 	bl	800289e <PCD_ReadPMA>
            ep->xfer_buff+=ep->xfer_count;
 800246c:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
 8002470:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
 8002474:	4413      	add	r3, r2
 8002476:	f8c4 31dc 	str.w	r3, [r4, #476]	; 0x1dc
           HAL_PCD_DataOutStageCallback(hpcd, 0U);
 800247a:	2100      	movs	r1, #0
 800247c:	4620      	mov	r0, r4
 800247e:	f004 fcbd 	bl	8006dfc <HAL_PCD_DataOutStageCallback>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 8002482:	6822      	ldr	r2, [r4, #0]
 8002484:	f8d4 01d8 	ldr.w	r0, [r4, #472]	; 0x1d8
 8002488:	f8b2 1050 	ldrh.w	r1, [r2, #80]	; 0x50
 800248c:	283e      	cmp	r0, #62	; 0x3e
 800248e:	b289      	uxth	r1, r1
 8002490:	f101 0106 	add.w	r1, r1, #6
 8002494:	f502 6580 	add.w	r5, r2, #1024	; 0x400
 8002498:	d915      	bls.n	80024c6 <HAL_PCD_IRQHandler+0x266>
 800249a:	f3c0 134f 	ubfx	r3, r0, #5, #16
 800249e:	06c0      	lsls	r0, r0, #27
 80024a0:	bf04      	itt	eq
 80024a2:	f103 33ff 	addeq.w	r3, r3, #4294967295
 80024a6:	b29b      	uxtheq	r3, r3
 80024a8:	ea49 2383 	orr.w	r3, r9, r3, lsl #10
 80024ac:	f825 3011 	strh.w	r3, [r5, r1, lsl #1]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID)
 80024b0:	8813      	ldrh	r3, [r2, #0]
 80024b2:	ea08 0303 	and.w	r3, r8, r3
 80024b6:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 80024ba:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80024be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80024c2:	8013      	strh	r3, [r2, #0]
 80024c4:	e74f      	b.n	8002366 <HAL_PCD_IRQHandler+0x106>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 80024c6:	f3c0 034f 	ubfx	r3, r0, #1, #16
 80024ca:	07c6      	lsls	r6, r0, #31
 80024cc:	bf44      	itt	mi
 80024ce:	3301      	addmi	r3, #1
 80024d0:	b29b      	uxthmi	r3, r3
 80024d2:	029b      	lsls	r3, r3, #10
 80024d4:	e7ea      	b.n	80024ac <HAL_PCD_IRQHandler+0x24c>
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, EPindex);
 80024d6:	fa0f fa86 	sxth.w	sl, r6
 80024da:	f830 302a 	ldrh.w	r3, [r0, sl, lsl #2]
 80024de:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 80024e2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80024e6:	0415      	lsls	r5, r2, #16
 80024e8:	d53e      	bpl.n	8002568 <HAL_PCD_IRQHandler+0x308>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
 80024ea:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 80024ee:	f023 0370 	bic.w	r3, r3, #112	; 0x70
        if (ep->doublebuffer == 0U)
 80024f2:	211c      	movs	r1, #28
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
 80024f4:	f820 302a 	strh.w	r3, [r0, sl, lsl #2]
        if (ep->doublebuffer == 0U)
 80024f8:	fb01 4106 	mla	r1, r1, r6, r4
 80024fc:	f891 31d6 	ldrb.w	r3, [r1, #470]	; 0x1d6
 8002500:	2b00      	cmp	r3, #0
 8002502:	d172      	bne.n	80025ea <HAL_PCD_IRQHandler+0x38a>
          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8002504:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002508:	f891 21cc 	ldrb.w	r2, [r1, #460]	; 0x1cc
 800250c:	b29b      	uxth	r3, r3
 800250e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8002512:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 8002516:	f8b3 540c 	ldrh.w	r5, [r3, #1036]	; 0x40c
 800251a:	f3c5 0509 	ubfx	r5, r5, #0, #10
          if (count != 0U)
 800251e:	b135      	cbz	r5, 800252e <HAL_PCD_IRQHandler+0x2ce>
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 8002520:	f8b1 21d0 	ldrh.w	r2, [r1, #464]	; 0x1d0
 8002524:	f8d1 11dc 	ldr.w	r1, [r1, #476]	; 0x1dc
 8002528:	462b      	mov	r3, r5
 800252a:	f000 f9b8 	bl	800289e <PCD_ReadPMA>
        ep->xfer_count+=count;
 800252e:	211c      	movs	r1, #28
 8002530:	fb01 4106 	mla	r1, r1, r6, r4
 8002534:	f8d1 31e4 	ldr.w	r3, [r1, #484]	; 0x1e4
        ep->xfer_buff+=count;
 8002538:	f8d1 21dc 	ldr.w	r2, [r1, #476]	; 0x1dc
        ep->xfer_count+=count;
 800253c:	442b      	add	r3, r5
 800253e:	f8c1 31e4 	str.w	r3, [r1, #484]	; 0x1e4
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 8002542:	f8d1 31e0 	ldr.w	r3, [r1, #480]	; 0x1e0
        ep->xfer_buff+=count;
 8002546:	442a      	add	r2, r5
 8002548:	f8c1 21dc 	str.w	r2, [r1, #476]	; 0x1dc
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 800254c:	b123      	cbz	r3, 8002558 <HAL_PCD_IRQHandler+0x2f8>
 800254e:	f8d1 01d8 	ldr.w	r0, [r1, #472]	; 0x1d8
 8002552:	4285      	cmp	r5, r0
 8002554:	f080 8082 	bcs.w	800265c <HAL_PCD_IRQHandler+0x3fc>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 8002558:	231c      	movs	r3, #28
 800255a:	fb03 4306 	mla	r3, r3, r6, r4
 800255e:	4620      	mov	r0, r4
 8002560:	f893 11cc 	ldrb.w	r1, [r3, #460]	; 0x1cc
 8002564:	f004 fc4a 	bl	8006dfc <HAL_PCD_DataOutStageCallback>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 8002568:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800256c:	0618      	lsls	r0, r3, #24
 800256e:	f57f aefa 	bpl.w	8002366 <HAL_PCD_IRQHandler+0x106>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8002572:	6820      	ldr	r0, [r4, #0]
 8002574:	f830 302a 	ldrh.w	r3, [r0, sl, lsl #2]
        if (ep->doublebuffer == 0U)
 8002578:	211c      	movs	r1, #28
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 800257a:	403b      	ands	r3, r7
 800257c:	f820 302a 	strh.w	r3, [r0, sl, lsl #2]
        if (ep->doublebuffer == 0U)
 8002580:	fb01 4106 	mla	r1, r1, r6, r4
 8002584:	f891 3032 	ldrb.w	r3, [r1, #50]	; 0x32
 8002588:	2b00      	cmp	r3, #0
 800258a:	d173      	bne.n	8002674 <HAL_PCD_IRQHandler+0x414>
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 800258c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8002590:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
 8002594:	b29b      	uxth	r3, r3
 8002596:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800259a:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 800259e:	f8b3 3404 	ldrh.w	r3, [r3, #1028]	; 0x404
 80025a2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80025a6:	640b      	str	r3, [r1, #64]	; 0x40
          if (ep->xfer_count != 0U)
 80025a8:	b11b      	cbz	r3, 80025b2 <HAL_PCD_IRQHandler+0x352>
            PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 80025aa:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 80025ac:	6b89      	ldr	r1, [r1, #56]	; 0x38
 80025ae:	f000 f963 	bl	8002878 <PCD_WritePMA>
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80025b2:	6822      	ldr	r2, [r4, #0]
 80025b4:	211c      	movs	r1, #28
 80025b6:	fb01 4606 	mla	r6, r1, r6, r4
 80025ba:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 80025be:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
 80025c2:	b29b      	uxth	r3, r3
 80025c4:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80025c8:	eb02 0343 	add.w	r3, r2, r3, lsl #1
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80025cc:	4620      	mov	r0, r4
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80025ce:	f8b3 2404 	ldrh.w	r2, [r3, #1028]	; 0x404
        ep->xfer_buff+=ep->xfer_count;
 80025d2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 80025d4:	f3c2 0209 	ubfx	r2, r2, #0, #10
 80025d8:	6432      	str	r2, [r6, #64]	; 0x40
        ep->xfer_buff+=ep->xfer_count;
 80025da:	441a      	add	r2, r3
        if (ep->xfer_len == 0U)
 80025dc:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
        ep->xfer_buff+=ep->xfer_count;
 80025de:	63b2      	str	r2, [r6, #56]	; 0x38
        if (ep->xfer_len == 0U)
 80025e0:	2b00      	cmp	r3, #0
 80025e2:	d17d      	bne.n	80026e0 <HAL_PCD_IRQHandler+0x480>
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 80025e4:	f004 fc13 	bl	8006e0e <HAL_PCD_DataInStageCallback>
 80025e8:	e6bd      	b.n	8002366 <HAL_PCD_IRQHandler+0x106>
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 80025ea:	f891 51cc 	ldrb.w	r5, [r1, #460]	; 0x1cc
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80025ee:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 80025f2:	f830 3025 	ldrh.w	r3, [r0, r5, lsl #2]
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80025f6:	b292      	uxth	r2, r2
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 80025f8:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80025fc:	f04f 0308 	mov.w	r3, #8
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002600:	fb13 2305 	smlabb	r3, r3, r5, r2
 8002604:	eb00 0343 	add.w	r3, r0, r3, lsl #1
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 8002608:	d01e      	beq.n	8002648 <HAL_PCD_IRQHandler+0x3e8>
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800260a:	f8b3 5404 	ldrh.w	r5, [r3, #1028]	; 0x404
 800260e:	f3c5 0509 	ubfx	r5, r5, #0, #10
            if (count != 0U)
 8002612:	b135      	cbz	r5, 8002622 <HAL_PCD_IRQHandler+0x3c2>
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 8002614:	f8b1 21d2 	ldrh.w	r2, [r1, #466]	; 0x1d2
 8002618:	462b      	mov	r3, r5
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800261a:	f8d1 11dc 	ldr.w	r1, [r1, #476]	; 0x1dc
 800261e:	f000 f93e 	bl	800289e <PCD_ReadPMA>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT)  
 8002622:	231c      	movs	r3, #28
 8002624:	fb03 4306 	mla	r3, r3, r6, r4
 8002628:	6822      	ldr	r2, [r4, #0]
 800262a:	f893 11cc 	ldrb.w	r1, [r3, #460]	; 0x1cc
 800262e:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8002632:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002636:	051b      	lsls	r3, r3, #20
 8002638:	0d1b      	lsrs	r3, r3, #20
 800263a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800263e:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8002642:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 8002646:	e772      	b.n	800252e <HAL_PCD_IRQHandler+0x2ce>
            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8002648:	f8b3 540c 	ldrh.w	r5, [r3, #1036]	; 0x40c
 800264c:	f3c5 0509 	ubfx	r5, r5, #0, #10
            if (count != 0U)
 8002650:	2d00      	cmp	r5, #0
 8002652:	d0e6      	beq.n	8002622 <HAL_PCD_IRQHandler+0x3c2>
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8002654:	462b      	mov	r3, r5
 8002656:	f8b1 21d4 	ldrh.w	r2, [r1, #468]	; 0x1d4
 800265a:	e7de      	b.n	800261a <HAL_PCD_IRQHandler+0x3ba>
          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 800265c:	f891 11cc 	ldrb.w	r1, [r1, #460]	; 0x1cc
 8002660:	4620      	mov	r0, r4
 8002662:	f7ff fd0b 	bl	800207c <HAL_PCD_EP_Receive>
 8002666:	e77f      	b.n	8002568 <HAL_PCD_IRQHandler+0x308>
 8002668:	ffff8f0f 	.word	0xffff8f0f
 800266c:	ffffbf8f 	.word	0xffffbf8f
 8002670:	ffff8000 	.word	0xffff8000
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 8002674:	f891 5028 	ldrb.w	r5, [r1, #40]	; 0x28
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002678:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 800267c:	f830 3025 	ldrh.w	r3, [r0, r5, lsl #2]
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8002680:	b292      	uxth	r2, r2
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 8002682:	f013 0f40 	tst.w	r3, #64	; 0x40
 8002686:	f04f 0308 	mov.w	r3, #8
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800268a:	fb13 2305 	smlabb	r3, r3, r5, r2
 800268e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 8002692:	d01c      	beq.n	80026ce <HAL_PCD_IRQHandler+0x46e>
 8002694:	f8b3 3404 	ldrh.w	r3, [r3, #1028]	; 0x404
 8002698:	f3c3 0309 	ubfx	r3, r3, #0, #10
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800269c:	640b      	str	r3, [r1, #64]	; 0x40
            if (ep->xfer_count != 0U)
 800269e:	b11b      	cbz	r3, 80026a8 <HAL_PCD_IRQHandler+0x448>
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
 80026a0:	8dca      	ldrh	r2, [r1, #46]	; 0x2e
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80026a2:	6b89      	ldr	r1, [r1, #56]	; 0x38
 80026a4:	f000 f8e8 	bl	8002878 <PCD_WritePMA>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN)  
 80026a8:	231c      	movs	r3, #28
 80026aa:	fb03 4306 	mla	r3, r3, r6, r4
 80026ae:	6822      	ldr	r2, [r4, #0]
 80026b0:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80026b4:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80026b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80026bc:	051b      	lsls	r3, r3, #20
 80026be:	0d1b      	lsrs	r3, r3, #20
 80026c0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80026c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80026c8:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 80026cc:	e771      	b.n	80025b2 <HAL_PCD_IRQHandler+0x352>
 80026ce:	f8b3 340c 	ldrh.w	r3, [r3, #1036]	; 0x40c
 80026d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80026d6:	640b      	str	r3, [r1, #64]	; 0x40
            if (ep->xfer_count != 0U)
 80026d8:	2b00      	cmp	r3, #0
 80026da:	d0e5      	beq.n	80026a8 <HAL_PCD_IRQHandler+0x448>
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80026dc:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
 80026de:	e7e0      	b.n	80026a2 <HAL_PCD_IRQHandler+0x442>
          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 80026e0:	f7ff fd42 	bl	8002168 <HAL_PCD_EP_Transmit>
 80026e4:	e63f      	b.n	8002366 <HAL_PCD_IRQHandler+0x106>
 80026e6:	bf00      	nop

080026e8 <HAL_PCD_EP_SetStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  PCD_EPTypeDef *ep;
   
  __HAL_LOCK(hpcd); 
 80026e8:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 80026ec:	2b01      	cmp	r3, #1
{
 80026ee:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 80026f0:	d045      	beq.n	800277e <HAL_PCD_EP_SetStall+0x96>
   
  if ((0x80U & ep_addr) == 0x80U)
 80026f2:	b24c      	sxtb	r4, r1
  __HAL_LOCK(hpcd); 
 80026f4:	2301      	movs	r3, #1
 80026f6:	221c      	movs	r2, #28
 80026f8:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  if ((0x80U & ep_addr) == 0x80U)
 80026fc:	2c00      	cmp	r4, #0
 80026fe:	f001 037f 	and.w	r3, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8002702:	bfb5      	itete	lt
 8002704:	fb02 0203 	mlalt	r2, r2, r3, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002708:	fb02 0201 	mlage	r2, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800270c:	3228      	addlt	r2, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 800270e:	f502 72e6 	addge.w	r2, r2, #460	; 0x1cc
  }
  
  ep->is_stall = 1U;
 8002712:	2101      	movs	r1, #1
 8002714:	7091      	strb	r1, [r2, #2]
  ep->num   = ep_addr & 0x7FU;
 8002716:	b2d9      	uxtb	r1, r3
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002718:	0fe3      	lsrs	r3, r4, #31
  ep->num   = ep_addr & 0x7FU;
 800271a:	7011      	strb	r1, [r2, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 800271c:	7053      	strb	r3, [r2, #1]
 800271e:	6802      	ldr	r2, [r0, #0]
  
  if (ep->num == 0U)
 8002720:	b991      	cbnz	r1, 8002748 <HAL_PCD_EP_SetStall+0x60>
  {
    /* This macro sets STALL status for RX & TX*/ 
    PCD_SET_EP_TXRX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL) 
 8002722:	8813      	ldrh	r3, [r2, #0]
 8002724:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002728:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800272c:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8002730:	f083 0310 	eor.w	r3, r3, #16
 8002734:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002738:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800273c:	8013      	strh	r3, [r2, #0]
    else
    {
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
    }
  }
  __HAL_UNLOCK(hpcd); 
 800273e:	2300      	movs	r3, #0
 8002740:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  
  return HAL_OK;
 8002744:	4618      	mov	r0, r3
 8002746:	bd10      	pop	{r4, pc}
 8002748:	b209      	sxth	r1, r1
    if (ep->is_in)
 800274a:	2c00      	cmp	r4, #0
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 800274c:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8002750:	bfb5      	itete	lt
 8002752:	f423 43e0 	biclt.w	r3, r3, #28672	; 0x7000
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
 8002756:	f423 4380 	bicge.w	r3, r3, #16384	; 0x4000
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 800275a:	f023 0340 	biclt.w	r3, r3, #64	; 0x40
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
 800275e:	f023 0370 	bicge.w	r3, r3, #112	; 0x70
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 8002762:	bfb5      	itete	lt
 8002764:	b29b      	uxthlt	r3, r3
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
 8002766:	b29b      	uxthge	r3, r3
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 8002768:	f083 0310 	eorlt.w	r3, r3, #16
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
 800276c:	f483 5380 	eorge.w	r3, r3, #4096	; 0x1000
 8002770:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002774:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002778:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 800277c:	e7df      	b.n	800273e <HAL_PCD_EP_SetStall+0x56>
  __HAL_LOCK(hpcd); 
 800277e:	2002      	movs	r0, #2
}
 8002780:	bd10      	pop	{r4, pc}

08002782 <HAL_PCD_EP_ClrStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  PCD_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8002782:	b24b      	sxtb	r3, r1
 8002784:	2b00      	cmp	r3, #0
{
 8002786:	b510      	push	{r4, lr}
 8002788:	f04f 021c 	mov.w	r2, #28
 800278c:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8002790:	bfb5      	itete	lt
 8002792:	fb02 0104 	mlalt	r1, r2, r4, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002796:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800279a:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 800279c:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80027a0:	0fdb      	lsrs	r3, r3, #31
  ep->is_stall = 0U;
 80027a2:	2200      	movs	r2, #0
 80027a4:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 80027a6:	700c      	strb	r4, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80027a8:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 80027aa:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 80027ae:	2b01      	cmp	r3, #1
 80027b0:	d045      	beq.n	800283e <HAL_PCD_EP_ClrStall+0xbc>
 80027b2:	2301      	movs	r3, #1
 80027b4:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 80027b8:	780b      	ldrb	r3, [r1, #0]
  
  if (ep->is_in)
 80027ba:	784c      	ldrb	r4, [r1, #1]
 80027bc:	6802      	ldr	r2, [r0, #0]
  {
    PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80027be:	b21b      	sxth	r3, r3
  if (ep->is_in)
 80027c0:	b31c      	cbz	r4, 800280a <HAL_PCD_EP_ClrStall+0x88>
    PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80027c2:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 80027c6:	f014 0f40 	tst.w	r4, #64	; 0x40
 80027ca:	d009      	beq.n	80027e0 <HAL_PCD_EP_ClrStall+0x5e>
 80027cc:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 80027d0:	0524      	lsls	r4, r4, #20
 80027d2:	0d24      	lsrs	r4, r4, #20
 80027d4:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 80027d8:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 80027dc:	f822 4023 	strh.w	r4, [r2, r3, lsl #2]
    PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID)
 80027e0:	7809      	ldrb	r1, [r1, #0]
 80027e2:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80027e6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80027ea:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80027ee:	b29b      	uxth	r3, r3
 80027f0:	f083 0330 	eor.w	r3, r3, #48	; 0x30
  }
  else
  {
    PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
    PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 80027f4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80027f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80027fc:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
  }
  __HAL_UNLOCK(hpcd); 
 8002800:	2300      	movs	r3, #0
 8002802:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
    
  return HAL_OK;
 8002806:	4618      	mov	r0, r3
 8002808:	bd10      	pop	{r4, pc}
    PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 800280a:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 800280e:	f414 4f80 	tst.w	r4, #16384	; 0x4000
 8002812:	d009      	beq.n	8002828 <HAL_PCD_EP_ClrStall+0xa6>
 8002814:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8002818:	0524      	lsls	r4, r4, #20
 800281a:	0d24      	lsrs	r4, r4, #20
 800281c:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8002820:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8002824:	f822 4023 	strh.w	r4, [r2, r3, lsl #2]
    PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8002828:	7809      	ldrb	r1, [r1, #0]
 800282a:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 800282e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002832:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002836:	b29b      	uxth	r3, r3
 8002838:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800283c:	e7da      	b.n	80027f4 <HAL_PCD_EP_ClrStall+0x72>
  __HAL_LOCK(hpcd); 
 800283e:	2002      	movs	r0, #2
}
 8002840:	bd10      	pop	{r4, pc}

08002842 <HAL_PCDEx_PMAConfig>:

{
  PCD_EPTypeDef *ep;
  
  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 8002842:	f011 0f80 	tst.w	r1, #128	; 0x80
{
 8002846:	b510      	push	{r4, lr}
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002848:	bf18      	it	ne
 800284a:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 800284e:	f04f 041c 	mov.w	r4, #28
 8002852:	bf15      	itete	ne
 8002854:	fb04 0001 	mlane	r0, r4, r1, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002858:	fb04 0001 	mlaeq	r0, r4, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 800285c:	3028      	addne	r0, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 800285e:	f500 70e6 	addeq.w	r0, r0, #460	; 0x1cc
  }
  
  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 8002862:	b91a      	cbnz	r2, 800286c <HAL_PCDEx_PMAConfig+0x2a>
  {
    /*Single Buffer*/
    ep->doublebuffer = 0U;
 8002864:	7282      	strb	r2, [r0, #10]
    /*Configure the PMA*/
    ep->pmaadress = (uint16_t)pmaadress;
 8002866:	8083      	strh	r3, [r0, #4]
    ep->pmaaddr0 =  pmaadress & 0xFFFFU;
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
  }
  
  return HAL_OK; 
}
 8002868:	2000      	movs	r0, #0
 800286a:	bd10      	pop	{r4, pc}
    ep->doublebuffer = 1;
 800286c:	2201      	movs	r2, #1
    ep->pmaaddr0 =  pmaadress & 0xFFFFU;
 800286e:	80c3      	strh	r3, [r0, #6]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
 8002870:	0c1b      	lsrs	r3, r3, #16
    ep->doublebuffer = 1;
 8002872:	7282      	strb	r2, [r0, #10]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
 8002874:	8103      	strh	r3, [r0, #8]
 8002876:	e7f7      	b.n	8002868 <HAL_PCDEx_PMAConfig+0x26>

08002878 <PCD_WritePMA>:
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
void PCD_WritePMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
  uint32_t n =  ((uint32_t)((uint32_t)wNBytes + 1U)) >> 1U;
 8002878:	3301      	adds	r3, #1
  
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400U));
 800287a:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800287e:	f023 0301 	bic.w	r3, r3, #1
{
 8002882:	b530      	push	{r4, r5, lr}
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400U));
 8002884:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8002888:	440b      	add	r3, r1
  
  for (i = n; i != 0; i--)
 800288a:	460c      	mov	r4, r1
 800288c:	429c      	cmp	r4, r3
 800288e:	d100      	bne.n	8002892 <PCD_WritePMA+0x1a>
    temp2 = temp1 | ((uint16_t)((uint16_t)  * pbUsrBuf << 8U)) ;
    *pdwVal++ = temp2;
    pdwVal++;
    pbUsrBuf++;
  }
}
 8002890:	bd30      	pop	{r4, r5, pc}
    *pdwVal++ = temp2;
 8002892:	1a60      	subs	r0, r4, r1
 8002894:	8825      	ldrh	r5, [r4, #0]
 8002896:	f822 5010 	strh.w	r5, [r2, r0, lsl #1]
 800289a:	3402      	adds	r4, #2
 800289c:	e7f6      	b.n	800288c <PCD_WritePMA+0x14>

0800289e <PCD_ReadPMA>:
  * @param   wPMABufAddr: address into PMA.
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
void PCD_ReadPMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 800289e:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = (uint32_t)wNBytes >> 1U;
  uint32_t i;
  uint16_t *pdwVal;
  uint32_t temp;
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400U));
 80028a0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  uint32_t n = (uint32_t)wNBytes >> 1U;
 80028a4:	085d      	lsrs	r5, r3, #1
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr * 2 + (uint32_t)USBx + 0x400U));
 80028a6:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 80028aa:	1c8c      	adds	r4, r1, #2
  
  for (i = n; i != 0U; i--)
 80028ac:	462e      	mov	r6, r5
 80028ae:	b936      	cbnz	r6, 80028be <PCD_ReadPMA+0x20>
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
    *pbUsrBuf++ = ((temp >> 8) & 0xFF);
    pdwVal++;
  }

  if (wNBytes % 2)
 80028b0:	07db      	lsls	r3, r3, #31
  {
    temp = *pdwVal++;
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
 80028b2:	bf44      	itt	mi
 80028b4:	f832 3025 	ldrhmi.w	r3, [r2, r5, lsl #2]
 80028b8:	f801 3015 	strbmi.w	r3, [r1, r5, lsl #1]
 80028bc:	bd70      	pop	{r4, r5, r6, pc}
    temp = *pdwVal++;
 80028be:	1a60      	subs	r0, r4, r1
 80028c0:	eb02 0040 	add.w	r0, r2, r0, lsl #1
  for (i = n; i != 0U; i--)
 80028c4:	3e01      	subs	r6, #1
    temp = *pdwVal++;
 80028c6:	f830 0c04 	ldrh.w	r0, [r0, #-4]
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
 80028ca:	f804 0c02 	strb.w	r0, [r4, #-2]
    *pbUsrBuf++ = ((temp >> 8) & 0xFF);
 80028ce:	0a00      	lsrs	r0, r0, #8
 80028d0:	f804 0c01 	strb.w	r0, [r4, #-1]
 80028d4:	3402      	adds	r4, #2
 80028d6:	e7ea      	b.n	80028ae <PCD_ReadPMA+0x10>

080028d8 <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80028d8:	6803      	ldr	r3, [r0, #0]
 80028da:	07da      	lsls	r2, r3, #31
{
 80028dc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80028e0:	4605      	mov	r5, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80028e2:	d411      	bmi.n	8002908 <HAL_RCC_OscConfig+0x30>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80028e4:	682b      	ldr	r3, [r5, #0]
 80028e6:	079b      	lsls	r3, r3, #30
 80028e8:	f100 8088 	bmi.w	80029fc <HAL_RCC_OscConfig+0x124>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80028ec:	682b      	ldr	r3, [r5, #0]
 80028ee:	071c      	lsls	r4, r3, #28
 80028f0:	f100 80f8 	bmi.w	8002ae4 <HAL_RCC_OscConfig+0x20c>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80028f4:	682b      	ldr	r3, [r5, #0]
 80028f6:	0758      	lsls	r0, r3, #29
 80028f8:	f100 8141 	bmi.w	8002b7e <HAL_RCC_OscConfig+0x2a6>
  }

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80028fc:	69ea      	ldr	r2, [r5, #28]
 80028fe:	2a00      	cmp	r2, #0
 8002900:	f040 81d7 	bne.w	8002cb2 <HAL_RCC_OscConfig+0x3da>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8002904:	2000      	movs	r0, #0
 8002906:	e021      	b.n	800294c <HAL_RCC_OscConfig+0x74>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8002908:	4cba      	ldr	r4, [pc, #744]	; (8002bf4 <HAL_RCC_OscConfig+0x31c>)
 800290a:	6863      	ldr	r3, [r4, #4]
 800290c:	f003 030c 	and.w	r3, r3, #12
 8002910:	2b04      	cmp	r3, #4
 8002912:	d007      	beq.n	8002924 <HAL_RCC_OscConfig+0x4c>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002914:	6863      	ldr	r3, [r4, #4]
 8002916:	f003 030c 	and.w	r3, r3, #12
 800291a:	2b08      	cmp	r3, #8
 800291c:	d119      	bne.n	8002952 <HAL_RCC_OscConfig+0x7a>
 800291e:	6863      	ldr	r3, [r4, #4]
 8002920:	03df      	lsls	r7, r3, #15
 8002922:	d516      	bpl.n	8002952 <HAL_RCC_OscConfig+0x7a>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002924:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8002928:	fa93 f2a3 	rbit	r2, r3
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800292c:	6821      	ldr	r1, [r4, #0]
 800292e:	fa93 f3a3 	rbit	r3, r3
 8002932:	fab3 f383 	clz	r3, r3
 8002936:	f003 031f 	and.w	r3, r3, #31
 800293a:	2201      	movs	r2, #1
 800293c:	fa02 f303 	lsl.w	r3, r2, r3
 8002940:	420b      	tst	r3, r1
 8002942:	d0cf      	beq.n	80028e4 <HAL_RCC_OscConfig+0xc>
 8002944:	686b      	ldr	r3, [r5, #4]
 8002946:	2b00      	cmp	r3, #0
 8002948:	d1cc      	bne.n	80028e4 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 800294a:	2001      	movs	r0, #1
}
 800294c:	b002      	add	sp, #8
 800294e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002952:	686a      	ldr	r2, [r5, #4]
 8002954:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8002958:	d125      	bne.n	80029a6 <HAL_RCC_OscConfig+0xce>
 800295a:	6823      	ldr	r3, [r4, #0]
 800295c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002960:	6023      	str	r3, [r4, #0]
      __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8002962:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002964:	68a9      	ldr	r1, [r5, #8]
 8002966:	f023 030f 	bic.w	r3, r3, #15
 800296a:	430b      	orrs	r3, r1
 800296c:	62e3      	str	r3, [r4, #44]	; 0x2c
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800296e:	b352      	cbz	r2, 80029c6 <HAL_RCC_OscConfig+0xee>
        tickstart = HAL_GetTick();
 8002970:	f7fd fcac 	bl	80002cc <HAL_GetTick>
 8002974:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 8002978:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800297a:	2701      	movs	r7, #1
 800297c:	fa96 f3a6 	rbit	r3, r6
 8002980:	6822      	ldr	r2, [r4, #0]
 8002982:	fa96 f3a6 	rbit	r3, r6
 8002986:	fab3 f383 	clz	r3, r3
 800298a:	f003 031f 	and.w	r3, r3, #31
 800298e:	fa07 f303 	lsl.w	r3, r7, r3
 8002992:	4213      	tst	r3, r2
 8002994:	d1a6      	bne.n	80028e4 <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002996:	f7fd fc99 	bl	80002cc <HAL_GetTick>
 800299a:	eba0 0008 	sub.w	r0, r0, r8
 800299e:	2864      	cmp	r0, #100	; 0x64
 80029a0:	d9ec      	bls.n	800297c <HAL_RCC_OscConfig+0xa4>
            return HAL_TIMEOUT;
 80029a2:	2003      	movs	r0, #3
 80029a4:	e7d2      	b.n	800294c <HAL_RCC_OscConfig+0x74>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80029a6:	6823      	ldr	r3, [r4, #0]
 80029a8:	b932      	cbnz	r2, 80029b8 <HAL_RCC_OscConfig+0xe0>
 80029aa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80029ae:	6023      	str	r3, [r4, #0]
 80029b0:	6823      	ldr	r3, [r4, #0]
 80029b2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80029b6:	e7d3      	b.n	8002960 <HAL_RCC_OscConfig+0x88>
 80029b8:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 80029bc:	d1f5      	bne.n	80029aa <HAL_RCC_OscConfig+0xd2>
 80029be:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80029c2:	6023      	str	r3, [r4, #0]
 80029c4:	e7c9      	b.n	800295a <HAL_RCC_OscConfig+0x82>
        tickstart = HAL_GetTick();
 80029c6:	f7fd fc81 	bl	80002cc <HAL_GetTick>
 80029ca:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 80029ce:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80029d0:	2701      	movs	r7, #1
 80029d2:	fa96 f3a6 	rbit	r3, r6
 80029d6:	6822      	ldr	r2, [r4, #0]
 80029d8:	fa96 f3a6 	rbit	r3, r6
 80029dc:	fab3 f383 	clz	r3, r3
 80029e0:	f003 031f 	and.w	r3, r3, #31
 80029e4:	fa07 f303 	lsl.w	r3, r7, r3
 80029e8:	4213      	tst	r3, r2
 80029ea:	f43f af7b 	beq.w	80028e4 <HAL_RCC_OscConfig+0xc>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80029ee:	f7fd fc6d 	bl	80002cc <HAL_GetTick>
 80029f2:	eba0 0008 	sub.w	r0, r0, r8
 80029f6:	2864      	cmp	r0, #100	; 0x64
 80029f8:	d9eb      	bls.n	80029d2 <HAL_RCC_OscConfig+0xfa>
 80029fa:	e7d2      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80029fc:	4c7d      	ldr	r4, [pc, #500]	; (8002bf4 <HAL_RCC_OscConfig+0x31c>)
 80029fe:	6863      	ldr	r3, [r4, #4]
 8002a00:	f013 0f0c 	tst.w	r3, #12
 8002a04:	d007      	beq.n	8002a16 <HAL_RCC_OscConfig+0x13e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8002a06:	6863      	ldr	r3, [r4, #4]
 8002a08:	f003 030c 	and.w	r3, r3, #12
 8002a0c:	2b08      	cmp	r3, #8
 8002a0e:	d121      	bne.n	8002a54 <HAL_RCC_OscConfig+0x17c>
 8002a10:	6863      	ldr	r3, [r4, #4]
 8002a12:	03de      	lsls	r6, r3, #15
 8002a14:	d41e      	bmi.n	8002a54 <HAL_RCC_OscConfig+0x17c>
 8002a16:	2302      	movs	r3, #2
 8002a18:	fa93 f2a3 	rbit	r2, r3
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002a1c:	6821      	ldr	r1, [r4, #0]
 8002a1e:	fa93 f3a3 	rbit	r3, r3
 8002a22:	fab3 f383 	clz	r3, r3
 8002a26:	f003 031f 	and.w	r3, r3, #31
 8002a2a:	2201      	movs	r2, #1
 8002a2c:	fa02 f303 	lsl.w	r3, r2, r3
 8002a30:	420b      	tst	r3, r1
 8002a32:	d002      	beq.n	8002a3a <HAL_RCC_OscConfig+0x162>
 8002a34:	692b      	ldr	r3, [r5, #16]
 8002a36:	4293      	cmp	r3, r2
 8002a38:	d187      	bne.n	800294a <HAL_RCC_OscConfig+0x72>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002a3a:	6821      	ldr	r1, [r4, #0]
 8002a3c:	23f8      	movs	r3, #248	; 0xf8
 8002a3e:	fa93 f3a3 	rbit	r3, r3
 8002a42:	fab3 f283 	clz	r2, r3
 8002a46:	696b      	ldr	r3, [r5, #20]
 8002a48:	4093      	lsls	r3, r2
 8002a4a:	f021 02f8 	bic.w	r2, r1, #248	; 0xf8
 8002a4e:	4313      	orrs	r3, r2
 8002a50:	6023      	str	r3, [r4, #0]
 8002a52:	e74b      	b.n	80028ec <HAL_RCC_OscConfig+0x14>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8002a54:	692a      	ldr	r2, [r5, #16]
 8002a56:	2601      	movs	r6, #1
 8002a58:	b30a      	cbz	r2, 8002a9e <HAL_RCC_OscConfig+0x1c6>
 8002a5a:	fa96 f3a6 	rbit	r3, r6
        __HAL_RCC_HSI_ENABLE();
 8002a5e:	fab3 f383 	clz	r3, r3
 8002a62:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8002a66:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8002a6a:	009b      	lsls	r3, r3, #2
 8002a6c:	2702      	movs	r7, #2
 8002a6e:	601e      	str	r6, [r3, #0]
        tickstart = HAL_GetTick();
 8002a70:	f7fd fc2c 	bl	80002cc <HAL_GetTick>
 8002a74:	4680      	mov	r8, r0
 8002a76:	fa97 f3a7 	rbit	r3, r7
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002a7a:	6822      	ldr	r2, [r4, #0]
 8002a7c:	fa97 f3a7 	rbit	r3, r7
 8002a80:	fab3 f383 	clz	r3, r3
 8002a84:	f003 031f 	and.w	r3, r3, #31
 8002a88:	fa06 f303 	lsl.w	r3, r6, r3
 8002a8c:	4213      	tst	r3, r2
 8002a8e:	d1d4      	bne.n	8002a3a <HAL_RCC_OscConfig+0x162>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002a90:	f7fd fc1c 	bl	80002cc <HAL_GetTick>
 8002a94:	eba0 0008 	sub.w	r0, r0, r8
 8002a98:	2802      	cmp	r0, #2
 8002a9a:	d9ec      	bls.n	8002a76 <HAL_RCC_OscConfig+0x19e>
 8002a9c:	e781      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
 8002a9e:	fa96 f3a6 	rbit	r3, r6
        __HAL_RCC_HSI_DISABLE();
 8002aa2:	fab3 f383 	clz	r3, r3
 8002aa6:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8002aaa:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8002aae:	009b      	lsls	r3, r3, #2
 8002ab0:	2702      	movs	r7, #2
 8002ab2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002ab4:	f7fd fc0a 	bl	80002cc <HAL_GetTick>
 8002ab8:	4680      	mov	r8, r0
 8002aba:	fa97 f3a7 	rbit	r3, r7
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002abe:	6822      	ldr	r2, [r4, #0]
 8002ac0:	fa97 f3a7 	rbit	r3, r7
 8002ac4:	fab3 f383 	clz	r3, r3
 8002ac8:	f003 031f 	and.w	r3, r3, #31
 8002acc:	fa06 f303 	lsl.w	r3, r6, r3
 8002ad0:	4213      	tst	r3, r2
 8002ad2:	f43f af0b 	beq.w	80028ec <HAL_RCC_OscConfig+0x14>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002ad6:	f7fd fbf9 	bl	80002cc <HAL_GetTick>
 8002ada:	eba0 0008 	sub.w	r0, r0, r8
 8002ade:	2802      	cmp	r0, #2
 8002ae0:	d9eb      	bls.n	8002aba <HAL_RCC_OscConfig+0x1e2>
 8002ae2:	e75e      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002ae4:	69aa      	ldr	r2, [r5, #24]
 8002ae6:	4e43      	ldr	r6, [pc, #268]	; (8002bf4 <HAL_RCC_OscConfig+0x31c>)
 8002ae8:	4943      	ldr	r1, [pc, #268]	; (8002bf8 <HAL_RCC_OscConfig+0x320>)
 8002aea:	2401      	movs	r4, #1
 8002aec:	b31a      	cbz	r2, 8002b36 <HAL_RCC_OscConfig+0x25e>
 8002aee:	fa94 f3a4 	rbit	r3, r4
      __HAL_RCC_LSI_ENABLE();
 8002af2:	fab3 f383 	clz	r3, r3
 8002af6:	440b      	add	r3, r1
 8002af8:	009b      	lsls	r3, r3, #2
 8002afa:	2702      	movs	r7, #2
 8002afc:	601c      	str	r4, [r3, #0]
      tickstart = HAL_GetTick();
 8002afe:	f7fd fbe5 	bl	80002cc <HAL_GetTick>
 8002b02:	4680      	mov	r8, r0
 8002b04:	fa97 f3a7 	rbit	r3, r7
 8002b08:	fa97 f3a7 	rbit	r3, r7
 8002b0c:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002b10:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8002b12:	fa97 f3a7 	rbit	r3, r7
 8002b16:	fab3 f383 	clz	r3, r3
 8002b1a:	f003 031f 	and.w	r3, r3, #31
 8002b1e:	fa04 f303 	lsl.w	r3, r4, r3
 8002b22:	4213      	tst	r3, r2
 8002b24:	f47f aee6 	bne.w	80028f4 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002b28:	f7fd fbd0 	bl	80002cc <HAL_GetTick>
 8002b2c:	eba0 0008 	sub.w	r0, r0, r8
 8002b30:	2802      	cmp	r0, #2
 8002b32:	d9e7      	bls.n	8002b04 <HAL_RCC_OscConfig+0x22c>
 8002b34:	e735      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
 8002b36:	fa94 f3a4 	rbit	r3, r4
      __HAL_RCC_LSI_DISABLE();
 8002b3a:	fab3 f383 	clz	r3, r3
 8002b3e:	440b      	add	r3, r1
 8002b40:	009b      	lsls	r3, r3, #2
 8002b42:	2702      	movs	r7, #2
 8002b44:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002b46:	f7fd fbc1 	bl	80002cc <HAL_GetTick>
 8002b4a:	4680      	mov	r8, r0
 8002b4c:	fa97 f3a7 	rbit	r3, r7
 8002b50:	fa97 f3a7 	rbit	r3, r7
 8002b54:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002b58:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8002b5a:	fa97 f3a7 	rbit	r3, r7
 8002b5e:	fab3 f383 	clz	r3, r3
 8002b62:	f003 031f 	and.w	r3, r3, #31
 8002b66:	fa04 f303 	lsl.w	r3, r4, r3
 8002b6a:	4213      	tst	r3, r2
 8002b6c:	f43f aec2 	beq.w	80028f4 <HAL_RCC_OscConfig+0x1c>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002b70:	f7fd fbac 	bl	80002cc <HAL_GetTick>
 8002b74:	eba0 0008 	sub.w	r0, r0, r8
 8002b78:	2802      	cmp	r0, #2
 8002b7a:	d9e7      	bls.n	8002b4c <HAL_RCC_OscConfig+0x274>
 8002b7c:	e711      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002b7e:	4c1d      	ldr	r4, [pc, #116]	; (8002bf4 <HAL_RCC_OscConfig+0x31c>)
 8002b80:	69e3      	ldr	r3, [r4, #28]
 8002b82:	00d9      	lsls	r1, r3, #3
 8002b84:	d434      	bmi.n	8002bf0 <HAL_RCC_OscConfig+0x318>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002b86:	69e3      	ldr	r3, [r4, #28]
 8002b88:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002b8c:	61e3      	str	r3, [r4, #28]
 8002b8e:	69e3      	ldr	r3, [r4, #28]
 8002b90:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002b94:	9301      	str	r3, [sp, #4]
 8002b96:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002b98:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002b9a:	4f18      	ldr	r7, [pc, #96]	; (8002bfc <HAL_RCC_OscConfig+0x324>)
 8002b9c:	683b      	ldr	r3, [r7, #0]
 8002b9e:	05da      	lsls	r2, r3, #23
 8002ba0:	d52e      	bpl.n	8002c00 <HAL_RCC_OscConfig+0x328>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002ba2:	68eb      	ldr	r3, [r5, #12]
 8002ba4:	2b01      	cmp	r3, #1
 8002ba6:	d13c      	bne.n	8002c22 <HAL_RCC_OscConfig+0x34a>
 8002ba8:	6a23      	ldr	r3, [r4, #32]
 8002baa:	f043 0301 	orr.w	r3, r3, #1
 8002bae:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 8002bb0:	f7fd fb8c 	bl	80002cc <HAL_GetTick>
 8002bb4:	2702      	movs	r7, #2
 8002bb6:	4682      	mov	sl, r0
 8002bb8:	46b9      	mov	r9, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002bba:	f04f 0801 	mov.w	r8, #1
 8002bbe:	fa97 f3a7 	rbit	r3, r7
 8002bc2:	fa97 f3a7 	rbit	r3, r7
 8002bc6:	2b00      	cmp	r3, #0
 8002bc8:	d06b      	beq.n	8002ca2 <HAL_RCC_OscConfig+0x3ca>
 8002bca:	6a22      	ldr	r2, [r4, #32]
 8002bcc:	fa99 f3a9 	rbit	r3, r9
 8002bd0:	fab3 f383 	clz	r3, r3
 8002bd4:	f003 031f 	and.w	r3, r3, #31
 8002bd8:	fa08 f303 	lsl.w	r3, r8, r3
 8002bdc:	4213      	tst	r3, r2
 8002bde:	d057      	beq.n	8002c90 <HAL_RCC_OscConfig+0x3b8>
    if(pwrclkchanged == SET)
 8002be0:	2e00      	cmp	r6, #0
 8002be2:	f43f ae8b 	beq.w	80028fc <HAL_RCC_OscConfig+0x24>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002be6:	69e3      	ldr	r3, [r4, #28]
 8002be8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002bec:	61e3      	str	r3, [r4, #28]
 8002bee:	e685      	b.n	80028fc <HAL_RCC_OscConfig+0x24>
    FlagStatus       pwrclkchanged = RESET;
 8002bf0:	2600      	movs	r6, #0
 8002bf2:	e7d2      	b.n	8002b9a <HAL_RCC_OscConfig+0x2c2>
 8002bf4:	40021000 	.word	0x40021000
 8002bf8:	10908120 	.word	0x10908120
 8002bfc:	40007000 	.word	0x40007000
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002c00:	683b      	ldr	r3, [r7, #0]
 8002c02:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c06:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8002c08:	f7fd fb60 	bl	80002cc <HAL_GetTick>
 8002c0c:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002c0e:	683b      	ldr	r3, [r7, #0]
 8002c10:	05db      	lsls	r3, r3, #23
 8002c12:	d4c6      	bmi.n	8002ba2 <HAL_RCC_OscConfig+0x2ca>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002c14:	f7fd fb5a 	bl	80002cc <HAL_GetTick>
 8002c18:	eba0 0008 	sub.w	r0, r0, r8
 8002c1c:	2864      	cmp	r0, #100	; 0x64
 8002c1e:	d9f6      	bls.n	8002c0e <HAL_RCC_OscConfig+0x336>
 8002c20:	e6bf      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002c22:	bb3b      	cbnz	r3, 8002c74 <HAL_RCC_OscConfig+0x39c>
 8002c24:	6a23      	ldr	r3, [r4, #32]
 8002c26:	f023 0301 	bic.w	r3, r3, #1
 8002c2a:	6223      	str	r3, [r4, #32]
 8002c2c:	6a23      	ldr	r3, [r4, #32]
 8002c2e:	f023 0304 	bic.w	r3, r3, #4
 8002c32:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 8002c34:	f7fd fb4a 	bl	80002cc <HAL_GetTick>
 8002c38:	2702      	movs	r7, #2
 8002c3a:	4682      	mov	sl, r0
 8002c3c:	46b9      	mov	r9, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002c3e:	f04f 0801 	mov.w	r8, #1
 8002c42:	fa97 f3a7 	rbit	r3, r7
 8002c46:	fa97 f3a7 	rbit	r3, r7
 8002c4a:	b373      	cbz	r3, 8002caa <HAL_RCC_OscConfig+0x3d2>
 8002c4c:	6a22      	ldr	r2, [r4, #32]
 8002c4e:	fa99 f3a9 	rbit	r3, r9
 8002c52:	fab3 f383 	clz	r3, r3
 8002c56:	f003 031f 	and.w	r3, r3, #31
 8002c5a:	fa08 f303 	lsl.w	r3, r8, r3
 8002c5e:	4213      	tst	r3, r2
 8002c60:	d0be      	beq.n	8002be0 <HAL_RCC_OscConfig+0x308>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002c62:	f7fd fb33 	bl	80002cc <HAL_GetTick>
 8002c66:	f241 3388 	movw	r3, #5000	; 0x1388
 8002c6a:	eba0 000a 	sub.w	r0, r0, sl
 8002c6e:	4298      	cmp	r0, r3
 8002c70:	d9e7      	bls.n	8002c42 <HAL_RCC_OscConfig+0x36a>
 8002c72:	e696      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002c74:	2b05      	cmp	r3, #5
 8002c76:	6a23      	ldr	r3, [r4, #32]
 8002c78:	d103      	bne.n	8002c82 <HAL_RCC_OscConfig+0x3aa>
 8002c7a:	f043 0304 	orr.w	r3, r3, #4
 8002c7e:	6223      	str	r3, [r4, #32]
 8002c80:	e792      	b.n	8002ba8 <HAL_RCC_OscConfig+0x2d0>
 8002c82:	f023 0301 	bic.w	r3, r3, #1
 8002c86:	6223      	str	r3, [r4, #32]
 8002c88:	6a23      	ldr	r3, [r4, #32]
 8002c8a:	f023 0304 	bic.w	r3, r3, #4
 8002c8e:	e78e      	b.n	8002bae <HAL_RCC_OscConfig+0x2d6>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002c90:	f7fd fb1c 	bl	80002cc <HAL_GetTick>
 8002c94:	f241 3388 	movw	r3, #5000	; 0x1388
 8002c98:	eba0 000a 	sub.w	r0, r0, sl
 8002c9c:	4298      	cmp	r0, r3
 8002c9e:	d98e      	bls.n	8002bbe <HAL_RCC_OscConfig+0x2e6>
 8002ca0:	e67f      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
 8002ca2:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002ca6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002ca8:	e790      	b.n	8002bcc <HAL_RCC_OscConfig+0x2f4>
 8002caa:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002cae:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002cb0:	e7cd      	b.n	8002c4e <HAL_RCC_OscConfig+0x376>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002cb2:	4c41      	ldr	r4, [pc, #260]	; (8002db8 <HAL_RCC_OscConfig+0x4e0>)
 8002cb4:	6863      	ldr	r3, [r4, #4]
 8002cb6:	f003 030c 	and.w	r3, r3, #12
 8002cba:	2b08      	cmp	r3, #8
 8002cbc:	f43f ae45 	beq.w	800294a <HAL_RCC_OscConfig+0x72>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002cc0:	2a02      	cmp	r2, #2
 8002cc2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002cc6:	d152      	bne.n	8002d6e <HAL_RCC_OscConfig+0x496>
 8002cc8:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_DISABLE();
 8002ccc:	fab3 f383 	clz	r3, r3
 8002cd0:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8002cd4:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8002cd8:	009b      	lsls	r3, r3, #2
 8002cda:	2200      	movs	r2, #0
 8002cdc:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002cde:	f7fd faf5 	bl	80002cc <HAL_GetTick>
 8002ce2:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 8002ce6:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002ce8:	2601      	movs	r6, #1
 8002cea:	fa97 f3a7 	rbit	r3, r7
 8002cee:	6822      	ldr	r2, [r4, #0]
 8002cf0:	fa97 f3a7 	rbit	r3, r7
 8002cf4:	fab3 f383 	clz	r3, r3
 8002cf8:	f003 031f 	and.w	r3, r3, #31
 8002cfc:	fa06 f303 	lsl.w	r3, r6, r3
 8002d00:	4213      	tst	r3, r2
 8002d02:	d12d      	bne.n	8002d60 <HAL_RCC_OscConfig+0x488>
      __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002d04:	6862      	ldr	r2, [r4, #4]
 8002d06:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002d08:	6a29      	ldr	r1, [r5, #32]
 8002d0a:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
 8002d0e:	430b      	orrs	r3, r1
 8002d10:	4313      	orrs	r3, r2
 8002d12:	6063      	str	r3, [r4, #4]
 8002d14:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8002d18:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_ENABLE();
 8002d1c:	fab3 f383 	clz	r3, r3
 8002d20:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8002d24:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8002d28:	009b      	lsls	r3, r3, #2
 8002d2a:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 8002d2e:	601e      	str	r6, [r3, #0]
        tickstart = HAL_GetTick();
 8002d30:	f7fd facc 	bl	80002cc <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8002d34:	2601      	movs	r6, #1
        tickstart = HAL_GetTick();
 8002d36:	4607      	mov	r7, r0
 8002d38:	fa95 f3a5 	rbit	r3, r5
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8002d3c:	6822      	ldr	r2, [r4, #0]
 8002d3e:	fa95 f3a5 	rbit	r3, r5
 8002d42:	fab3 f383 	clz	r3, r3
 8002d46:	f003 031f 	and.w	r3, r3, #31
 8002d4a:	fa06 f303 	lsl.w	r3, r6, r3
 8002d4e:	4213      	tst	r3, r2
 8002d50:	f47f add8 	bne.w	8002904 <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002d54:	f7fd faba 	bl	80002cc <HAL_GetTick>
 8002d58:	1bc0      	subs	r0, r0, r7
 8002d5a:	2802      	cmp	r0, #2
 8002d5c:	d9ec      	bls.n	8002d38 <HAL_RCC_OscConfig+0x460>
 8002d5e:	e620      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002d60:	f7fd fab4 	bl	80002cc <HAL_GetTick>
 8002d64:	eba0 0008 	sub.w	r0, r0, r8
 8002d68:	2802      	cmp	r0, #2
 8002d6a:	d9be      	bls.n	8002cea <HAL_RCC_OscConfig+0x412>
 8002d6c:	e619      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
 8002d6e:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_DISABLE();
 8002d72:	fab3 f383 	clz	r3, r3
 8002d76:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8002d7a:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8002d7e:	009b      	lsls	r3, r3, #2
 8002d80:	2200      	movs	r2, #0
 8002d82:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002d84:	f7fd faa2 	bl	80002cc <HAL_GetTick>
 8002d88:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 8002d8c:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002d8e:	2601      	movs	r6, #1
 8002d90:	fa95 f3a5 	rbit	r3, r5
 8002d94:	6822      	ldr	r2, [r4, #0]
 8002d96:	fa95 f3a5 	rbit	r3, r5
 8002d9a:	fab3 f383 	clz	r3, r3
 8002d9e:	f003 031f 	and.w	r3, r3, #31
 8002da2:	fa06 f303 	lsl.w	r3, r6, r3
 8002da6:	4213      	tst	r3, r2
 8002da8:	f43f adac 	beq.w	8002904 <HAL_RCC_OscConfig+0x2c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002dac:	f7fd fa8e 	bl	80002cc <HAL_GetTick>
 8002db0:	1bc0      	subs	r0, r0, r7
 8002db2:	2802      	cmp	r0, #2
 8002db4:	d9ec      	bls.n	8002d90 <HAL_RCC_OscConfig+0x4b8>
 8002db6:	e5f4      	b.n	80029a2 <HAL_RCC_OscConfig+0xca>
 8002db8:	40021000 	.word	0x40021000

08002dbc <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8002dbc:	b510      	push	{r4, lr}
  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
 8002dbe:	4c13      	ldr	r4, [pc, #76]	; (8002e0c <HAL_RCC_GetSysClockFreq+0x50>)
 8002dc0:	6861      	ldr	r1, [r4, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 8002dc2:	f001 030c 	and.w	r3, r1, #12
 8002dc6:	2b08      	cmp	r3, #8
 8002dc8:	d11e      	bne.n	8002e08 <HAL_RCC_GetSysClockFreq+0x4c>
 8002dca:	f44f 1370 	mov.w	r3, #3932160	; 0x3c0000
 8002dce:	fa93 f3a3 	rbit	r3, r3
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 8002dd2:	f401 1270 	and.w	r2, r1, #3932160	; 0x3c0000
 8002dd6:	fab3 f383 	clz	r3, r3
 8002dda:	fa22 f303 	lsr.w	r3, r2, r3
 8002dde:	4a0c      	ldr	r2, [pc, #48]	; (8002e10 <HAL_RCC_GetSysClockFreq+0x54>)
 8002de0:	5cd0      	ldrb	r0, [r2, r3]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> POSITION_VAL(RCC_CFGR2_PREDIV)];
 8002de2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002de4:	220f      	movs	r2, #15
 8002de6:	fa92 f2a2 	rbit	r2, r2
 8002dea:	fab2 f282 	clz	r2, r2
 8002dee:	f003 030f 	and.w	r3, r3, #15
 8002df2:	40d3      	lsrs	r3, r2
 8002df4:	4a07      	ldr	r2, [pc, #28]	; (8002e14 <HAL_RCC_GetSysClockFreq+0x58>)
 8002df6:	5cd2      	ldrb	r2, [r2, r3]
#if defined(RCC_CFGR_PLLSRC_HSI_DIV2)
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI)
 8002df8:	03cb      	lsls	r3, r1, #15
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (HSE_VALUE / prediv) * pllmul;
 8002dfa:	bf4a      	itet	mi
 8002dfc:	4b06      	ldrmi	r3, [pc, #24]	; (8002e18 <HAL_RCC_GetSysClockFreq+0x5c>)
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (HSI_VALUE >> 1U) * pllmul;
 8002dfe:	4b07      	ldrpl	r3, [pc, #28]	; (8002e1c <HAL_RCC_GetSysClockFreq+0x60>)
        pllclk = (HSE_VALUE / prediv) * pllmul;
 8002e00:	fbb3 f3f2 	udivmi	r3, r3, r2
        pllclk = (HSI_VALUE >> 1U) * pllmul;
 8002e04:	4358      	muls	r0, r3
 8002e06:	bd10      	pop	{r4, pc}
      sysclockfreq = HSE_VALUE;
 8002e08:	4803      	ldr	r0, [pc, #12]	; (8002e18 <HAL_RCC_GetSysClockFreq+0x5c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002e0a:	bd10      	pop	{r4, pc}
 8002e0c:	40021000 	.word	0x40021000
 8002e10:	08007a14 	.word	0x08007a14
 8002e14:	08007a24 	.word	0x08007a24
 8002e18:	007a1200 	.word	0x007a1200
 8002e1c:	003d0900 	.word	0x003d0900

08002e20 <HAL_RCC_ClockConfig>:
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002e20:	4a5c      	ldr	r2, [pc, #368]	; (8002f94 <HAL_RCC_ClockConfig+0x174>)
 8002e22:	6813      	ldr	r3, [r2, #0]
 8002e24:	f003 0307 	and.w	r3, r3, #7
 8002e28:	428b      	cmp	r3, r1
{
 8002e2a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002e2e:	4606      	mov	r6, r0
 8002e30:	460d      	mov	r5, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002e32:	d330      	bcc.n	8002e96 <HAL_RCC_ClockConfig+0x76>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002e34:	6832      	ldr	r2, [r6, #0]
 8002e36:	0791      	lsls	r1, r2, #30
 8002e38:	d43a      	bmi.n	8002eb0 <HAL_RCC_ClockConfig+0x90>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002e3a:	07d2      	lsls	r2, r2, #31
 8002e3c:	d440      	bmi.n	8002ec0 <HAL_RCC_ClockConfig+0xa0>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 8002e3e:	4a55      	ldr	r2, [pc, #340]	; (8002f94 <HAL_RCC_ClockConfig+0x174>)
 8002e40:	6813      	ldr	r3, [r2, #0]
 8002e42:	f003 0307 	and.w	r3, r3, #7
 8002e46:	429d      	cmp	r5, r3
 8002e48:	f0c0 8092 	bcc.w	8002f70 <HAL_RCC_ClockConfig+0x150>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002e4c:	6832      	ldr	r2, [r6, #0]
 8002e4e:	4c52      	ldr	r4, [pc, #328]	; (8002f98 <HAL_RCC_ClockConfig+0x178>)
 8002e50:	f012 0f04 	tst.w	r2, #4
 8002e54:	f040 8097 	bne.w	8002f86 <HAL_RCC_ClockConfig+0x166>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002e58:	0713      	lsls	r3, r2, #28
 8002e5a:	d506      	bpl.n	8002e6a <HAL_RCC_ClockConfig+0x4a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8002e5c:	6863      	ldr	r3, [r4, #4]
 8002e5e:	6932      	ldr	r2, [r6, #16]
 8002e60:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002e64:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002e68:	6063      	str	r3, [r4, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8002e6a:	f7ff ffa7 	bl	8002dbc <HAL_RCC_GetSysClockFreq>
 8002e6e:	6863      	ldr	r3, [r4, #4]
 8002e70:	22f0      	movs	r2, #240	; 0xf0
 8002e72:	fa92 f2a2 	rbit	r2, r2
 8002e76:	fab2 f282 	clz	r2, r2
 8002e7a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002e7e:	40d3      	lsrs	r3, r2
 8002e80:	4a46      	ldr	r2, [pc, #280]	; (8002f9c <HAL_RCC_ClockConfig+0x17c>)
 8002e82:	5cd3      	ldrb	r3, [r2, r3]
 8002e84:	40d8      	lsrs	r0, r3
 8002e86:	4b46      	ldr	r3, [pc, #280]	; (8002fa0 <HAL_RCC_ClockConfig+0x180>)
 8002e88:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 8002e8a:	200f      	movs	r0, #15
 8002e8c:	f7fd f9f0 	bl	8000270 <HAL_InitTick>
  return HAL_OK;
 8002e90:	2000      	movs	r0, #0
}
 8002e92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002e96:	6813      	ldr	r3, [r2, #0]
 8002e98:	f023 0307 	bic.w	r3, r3, #7
 8002e9c:	430b      	orrs	r3, r1
 8002e9e:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002ea0:	6813      	ldr	r3, [r2, #0]
 8002ea2:	f003 0307 	and.w	r3, r3, #7
 8002ea6:	4299      	cmp	r1, r3
 8002ea8:	d0c4      	beq.n	8002e34 <HAL_RCC_ClockConfig+0x14>
      return HAL_ERROR;
 8002eaa:	2001      	movs	r0, #1
 8002eac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002eb0:	4939      	ldr	r1, [pc, #228]	; (8002f98 <HAL_RCC_ClockConfig+0x178>)
 8002eb2:	68b0      	ldr	r0, [r6, #8]
 8002eb4:	684b      	ldr	r3, [r1, #4]
 8002eb6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002eba:	4303      	orrs	r3, r0
 8002ebc:	604b      	str	r3, [r1, #4]
 8002ebe:	e7bc      	b.n	8002e3a <HAL_RCC_ClockConfig+0x1a>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002ec0:	6872      	ldr	r2, [r6, #4]
 8002ec2:	4c35      	ldr	r4, [pc, #212]	; (8002f98 <HAL_RCC_ClockConfig+0x178>)
 8002ec4:	2a01      	cmp	r2, #1
 8002ec6:	d128      	bne.n	8002f1a <HAL_RCC_ClockConfig+0xfa>
 8002ec8:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8002ecc:	fa93 f1a3 	rbit	r1, r3
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002ed0:	6821      	ldr	r1, [r4, #0]
 8002ed2:	fa93 f3a3 	rbit	r3, r3
 8002ed6:	fab3 f383 	clz	r3, r3
 8002eda:	f003 031f 	and.w	r3, r3, #31
 8002ede:	fa02 f303 	lsl.w	r3, r2, r3
 8002ee2:	420b      	tst	r3, r1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002ee4:	d0e1      	beq.n	8002eaa <HAL_RCC_ClockConfig+0x8a>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002ee6:	6863      	ldr	r3, [r4, #4]
 8002ee8:	f023 0303 	bic.w	r3, r3, #3
 8002eec:	431a      	orrs	r2, r3
 8002eee:	6062      	str	r2, [r4, #4]
    tickstart = HAL_GetTick();
 8002ef0:	f7fd f9ec 	bl	80002cc <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002ef4:	6873      	ldr	r3, [r6, #4]
 8002ef6:	2b01      	cmp	r3, #1
    tickstart = HAL_GetTick();
 8002ef8:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002efa:	f241 3888 	movw	r8, #5000	; 0x1388
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002efe:	d11f      	bne.n	8002f40 <HAL_RCC_ClockConfig+0x120>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002f00:	6863      	ldr	r3, [r4, #4]
 8002f02:	f003 030c 	and.w	r3, r3, #12
 8002f06:	2b04      	cmp	r3, #4
 8002f08:	d099      	beq.n	8002e3e <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002f0a:	f7fd f9df 	bl	80002cc <HAL_GetTick>
 8002f0e:	1bc0      	subs	r0, r0, r7
 8002f10:	4540      	cmp	r0, r8
 8002f12:	d9f5      	bls.n	8002f00 <HAL_RCC_ClockConfig+0xe0>
          return HAL_TIMEOUT;
 8002f14:	2003      	movs	r0, #3
 8002f16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002f1a:	2a02      	cmp	r2, #2
 8002f1c:	bf0c      	ite	eq
 8002f1e:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
 8002f22:	2302      	movne	r3, #2
 8002f24:	fa93 f1a3 	rbit	r1, r3
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002f28:	6820      	ldr	r0, [r4, #0]
 8002f2a:	fa93 f3a3 	rbit	r3, r3
 8002f2e:	fab3 f383 	clz	r3, r3
 8002f32:	f003 031f 	and.w	r3, r3, #31
 8002f36:	2101      	movs	r1, #1
 8002f38:	fa01 f303 	lsl.w	r3, r1, r3
 8002f3c:	4203      	tst	r3, r0
 8002f3e:	e7d1      	b.n	8002ee4 <HAL_RCC_ClockConfig+0xc4>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002f40:	2b02      	cmp	r3, #2
 8002f42:	d110      	bne.n	8002f66 <HAL_RCC_ClockConfig+0x146>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002f44:	6863      	ldr	r3, [r4, #4]
 8002f46:	f003 030c 	and.w	r3, r3, #12
 8002f4a:	2b08      	cmp	r3, #8
 8002f4c:	f43f af77 	beq.w	8002e3e <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002f50:	f7fd f9bc 	bl	80002cc <HAL_GetTick>
 8002f54:	1bc0      	subs	r0, r0, r7
 8002f56:	4540      	cmp	r0, r8
 8002f58:	d9f4      	bls.n	8002f44 <HAL_RCC_ClockConfig+0x124>
 8002f5a:	e7db      	b.n	8002f14 <HAL_RCC_ClockConfig+0xf4>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002f5c:	f7fd f9b6 	bl	80002cc <HAL_GetTick>
 8002f60:	1bc0      	subs	r0, r0, r7
 8002f62:	4540      	cmp	r0, r8
 8002f64:	d8d6      	bhi.n	8002f14 <HAL_RCC_ClockConfig+0xf4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8002f66:	6863      	ldr	r3, [r4, #4]
 8002f68:	f013 0f0c 	tst.w	r3, #12
 8002f6c:	d1f6      	bne.n	8002f5c <HAL_RCC_ClockConfig+0x13c>
 8002f6e:	e766      	b.n	8002e3e <HAL_RCC_ClockConfig+0x1e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002f70:	6813      	ldr	r3, [r2, #0]
 8002f72:	f023 0307 	bic.w	r3, r3, #7
 8002f76:	432b      	orrs	r3, r5
 8002f78:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8002f7a:	6813      	ldr	r3, [r2, #0]
 8002f7c:	f003 0307 	and.w	r3, r3, #7
 8002f80:	429d      	cmp	r5, r3
 8002f82:	d192      	bne.n	8002eaa <HAL_RCC_ClockConfig+0x8a>
 8002f84:	e762      	b.n	8002e4c <HAL_RCC_ClockConfig+0x2c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002f86:	6863      	ldr	r3, [r4, #4]
 8002f88:	68f1      	ldr	r1, [r6, #12]
 8002f8a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002f8e:	430b      	orrs	r3, r1
 8002f90:	6063      	str	r3, [r4, #4]
 8002f92:	e761      	b.n	8002e58 <HAL_RCC_ClockConfig+0x38>
 8002f94:	40022000 	.word	0x40022000
 8002f98:	40021000 	.word	0x40021000
 8002f9c:	08007ab6 	.word	0x08007ab6
 8002fa0:	20000120 	.word	0x20000120

08002fa4 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8002fa4:	4b01      	ldr	r3, [pc, #4]	; (8002fac <HAL_RCC_GetHCLKFreq+0x8>)
 8002fa6:	6818      	ldr	r0, [r3, #0]
 8002fa8:	4770      	bx	lr
 8002faa:	bf00      	nop
 8002fac:	20000120 	.word	0x20000120

08002fb0 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
 8002fb0:	4b08      	ldr	r3, [pc, #32]	; (8002fd4 <HAL_RCC_GetPCLK1Freq+0x24>)
 8002fb2:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8002fb6:	685b      	ldr	r3, [r3, #4]
 8002fb8:	fa92 f2a2 	rbit	r2, r2
 8002fbc:	fab2 f282 	clz	r2, r2
 8002fc0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002fc4:	40d3      	lsrs	r3, r2
 8002fc6:	4a04      	ldr	r2, [pc, #16]	; (8002fd8 <HAL_RCC_GetPCLK1Freq+0x28>)
 8002fc8:	5cd3      	ldrb	r3, [r2, r3]
 8002fca:	4a04      	ldr	r2, [pc, #16]	; (8002fdc <HAL_RCC_GetPCLK1Freq+0x2c>)
 8002fcc:	6810      	ldr	r0, [r2, #0]
}    
 8002fce:	40d8      	lsrs	r0, r3
 8002fd0:	4770      	bx	lr
 8002fd2:	bf00      	nop
 8002fd4:	40021000 	.word	0x40021000
 8002fd8:	08007ac6 	.word	0x08007ac6
 8002fdc:	20000120 	.word	0x20000120

08002fe0 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
 8002fe0:	4b08      	ldr	r3, [pc, #32]	; (8003004 <HAL_RCC_GetPCLK2Freq+0x24>)
 8002fe2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002fe6:	685b      	ldr	r3, [r3, #4]
 8002fe8:	fa92 f2a2 	rbit	r2, r2
 8002fec:	fab2 f282 	clz	r2, r2
 8002ff0:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8002ff4:	40d3      	lsrs	r3, r2
 8002ff6:	4a04      	ldr	r2, [pc, #16]	; (8003008 <HAL_RCC_GetPCLK2Freq+0x28>)
 8002ff8:	5cd3      	ldrb	r3, [r2, r3]
 8002ffa:	4a04      	ldr	r2, [pc, #16]	; (800300c <HAL_RCC_GetPCLK2Freq+0x2c>)
 8002ffc:	6810      	ldr	r0, [r2, #0]
} 
 8002ffe:	40d8      	lsrs	r0, r3
 8003000:	4770      	bx	lr
 8003002:	bf00      	nop
 8003004:	40021000 	.word	0x40021000
 8003008:	08007ac6 	.word	0x08007ac6
 800300c:	20000120 	.word	0x20000120

08003010 <HAL_RCCEx_PeriphCLKConfig>:
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8003010:	6803      	ldr	r3, [r0, #0]
{
 8003012:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8003016:	03dd      	lsls	r5, r3, #15
{
 8003018:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800301a:	d523      	bpl.n	8003064 <HAL_RCCEx_PeriphCLKConfig+0x54>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800301c:	4d7c      	ldr	r5, [pc, #496]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 800301e:	69eb      	ldr	r3, [r5, #28]
 8003020:	00d8      	lsls	r0, r3, #3
 8003022:	f100 8098 	bmi.w	8003156 <HAL_RCCEx_PeriphCLKConfig+0x146>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8003026:	69eb      	ldr	r3, [r5, #28]
 8003028:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800302c:	61eb      	str	r3, [r5, #28]
 800302e:	69eb      	ldr	r3, [r5, #28]
 8003030:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003034:	9301      	str	r3, [sp, #4]
 8003036:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8003038:	2601      	movs	r6, #1
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800303a:	4f76      	ldr	r7, [pc, #472]	; (8003214 <HAL_RCCEx_PeriphCLKConfig+0x204>)
 800303c:	683b      	ldr	r3, [r7, #0]
 800303e:	05d9      	lsls	r1, r3, #23
 8003040:	f140 808b 	bpl.w	800315a <HAL_RCCEx_PeriphCLKConfig+0x14a>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8003044:	6a2b      	ldr	r3, [r5, #32]
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003046:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 800304a:	f040 809b 	bne.w	8003184 <HAL_RCCEx_PeriphCLKConfig+0x174>
            return HAL_TIMEOUT;
          }      
        }  
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 800304e:	6a2b      	ldr	r3, [r5, #32]
 8003050:	6862      	ldr	r2, [r4, #4]
 8003052:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003056:	4313      	orrs	r3, r2
 8003058:	622b      	str	r3, [r5, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 800305a:	b11e      	cbz	r6, 8003064 <HAL_RCCEx_PeriphCLKConfig+0x54>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800305c:	69eb      	ldr	r3, [r5, #28]
 800305e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003062:	61eb      	str	r3, [r5, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8003064:	6820      	ldr	r0, [r4, #0]
 8003066:	07c7      	lsls	r7, r0, #31
 8003068:	d506      	bpl.n	8003078 <HAL_RCCEx_PeriphCLKConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800306a:	4a69      	ldr	r2, [pc, #420]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 800306c:	68a1      	ldr	r1, [r4, #8]
 800306e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003070:	f023 0303 	bic.w	r3, r3, #3
 8003074:	430b      	orrs	r3, r1
 8003076:	6313      	str	r3, [r2, #48]	; 0x30
  }

#if defined(RCC_CFGR3_USART2SW)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8003078:	0786      	lsls	r6, r0, #30
 800307a:	d506      	bpl.n	800308a <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 800307c:	4a64      	ldr	r2, [pc, #400]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 800307e:	68e1      	ldr	r1, [r4, #12]
 8003080:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003082:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8003086:	430b      	orrs	r3, r1
 8003088:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* RCC_CFGR3_USART2SW */

#if defined(RCC_CFGR3_USART3SW)
  /*------------------------------ USART3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 800308a:	0745      	lsls	r5, r0, #29
 800308c:	d506      	bpl.n	800309c <HAL_RCCEx_PeriphCLKConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800308e:	4a60      	ldr	r2, [pc, #384]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 8003090:	6921      	ldr	r1, [r4, #16]
 8003092:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003094:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8003098:	430b      	orrs	r3, r1
 800309a:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* RCC_CFGR3_USART3SW */

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800309c:	0681      	lsls	r1, r0, #26
 800309e:	d506      	bpl.n	80030ae <HAL_RCCEx_PeriphCLKConfig+0x9e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80030a0:	4a5b      	ldr	r2, [pc, #364]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030a2:	69e1      	ldr	r1, [r4, #28]
 80030a4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80030a6:	f023 0310 	bic.w	r3, r3, #16
 80030aa:	430b      	orrs	r3, r1
 80030ac:	6313      	str	r3, [r2, #48]	; 0x30
#if defined(STM32F302xE) || defined(STM32F303xE)\
 || defined(STM32F302xC) || defined(STM32F303xC)\
 || defined(STM32F302x8)                        \
 || defined(STM32F373xC)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 80030ae:	0382      	lsls	r2, r0, #14
 80030b0:	d506      	bpl.n	80030c0 <HAL_RCCEx_PeriphCLKConfig+0xb0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->USBClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->USBClockSelection);
 80030b2:	4a57      	ldr	r2, [pc, #348]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030b4:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80030b6:	6853      	ldr	r3, [r2, #4]
 80030b8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80030bc:	430b      	orrs	r3, r1
 80030be:	6053      	str	r3, [r2, #4]
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)\
 || defined(STM32F373xC) || defined(STM32F378xx)

  /*------------------------------ I2C2 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80030c0:	0643      	lsls	r3, r0, #25
 80030c2:	d506      	bpl.n	80030d2 <HAL_RCCEx_PeriphCLKConfig+0xc2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80030c4:	4a52      	ldr	r2, [pc, #328]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030c6:	6a21      	ldr	r1, [r4, #32]
 80030c8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80030ca:	f023 0320 	bic.w	r3, r3, #32
 80030ce:	430b      	orrs	r3, r1
 80030d0:	6313      	str	r3, [r2, #48]	; 0x30
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ UART4 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80030d2:	0707      	lsls	r7, r0, #28
 80030d4:	d506      	bpl.n	80030e4 <HAL_RCCEx_PeriphCLKConfig+0xd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80030d6:	4a4e      	ldr	r2, [pc, #312]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030d8:	6961      	ldr	r1, [r4, #20]
 80030da:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80030dc:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80030e0:	430b      	orrs	r3, r1
 80030e2:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ UART5 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80030e4:	06c6      	lsls	r6, r0, #27
 80030e6:	d506      	bpl.n	80030f6 <HAL_RCCEx_PeriphCLKConfig+0xe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80030e8:	4a49      	ldr	r2, [pc, #292]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030ea:	69a1      	ldr	r1, [r4, #24]
 80030ec:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80030ee:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 80030f2:	430b      	orrs	r3, r1
 80030f4:	6313      	str	r3, [r2, #48]	; 0x30

#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)
  /*------------------------------ I2S Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 80030f6:	0585      	lsls	r5, r0, #22
 80030f8:	d506      	bpl.n	8003108 <HAL_RCCEx_PeriphCLKConfig+0xf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure the I2S clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80030fa:	4a45      	ldr	r2, [pc, #276]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 80030fc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80030fe:	6853      	ldr	r3, [r2, #4]
 8003100:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8003104:	430b      	orrs	r3, r1
 8003106:	6053      	str	r3, [r2, #4]
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
      
  /*------------------------------ ADC1 & ADC2 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8003108:	0601      	lsls	r1, r0, #24
 800310a:	d506      	bpl.n	800311a <HAL_RCCEx_PeriphCLKConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12PLLCLK_DIV(PeriphClkInit->Adc12ClockSelection));
    
    /* Configure the ADC12 clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 800310c:	4a40      	ldr	r2, [pc, #256]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 800310e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003110:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8003112:	f423 73f8 	bic.w	r3, r3, #496	; 0x1f0
 8003116:	430b      	orrs	r3, r1
 8003118:	62d3      	str	r3, [r2, #44]	; 0x2c
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ ADC3 & ADC4 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC34) == RCC_PERIPHCLK_ADC34)
 800311a:	05c2      	lsls	r2, r0, #23
 800311c:	d506      	bpl.n	800312c <HAL_RCCEx_PeriphCLKConfig+0x11c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC34PLLCLK_DIV(PeriphClkInit->Adc34ClockSelection));
    
    /* Configure the ADC34 clock source */
    __HAL_RCC_ADC34_CONFIG(PeriphClkInit->Adc34ClockSelection);
 800311e:	4a3c      	ldr	r2, [pc, #240]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 8003120:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003122:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8003124:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
 8003128:	430b      	orrs	r3, r1
 800312a:	62d3      	str	r3, [r2, #44]	; 0x2c
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)

  /*------------------------------ TIM1 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM1) == RCC_PERIPHCLK_TIM1)
 800312c:	04c3      	lsls	r3, r0, #19
 800312e:	d506      	bpl.n	800313e <HAL_RCCEx_PeriphCLKConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM1CLKSOURCE(PeriphClkInit->Tim1ClockSelection));
    
    /* Configure the TIM1 clock source */
    __HAL_RCC_TIM1_CONFIG(PeriphClkInit->Tim1ClockSelection);
 8003130:	4a37      	ldr	r2, [pc, #220]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 8003132:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003134:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8003136:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800313a:	430b      	orrs	r3, r1
 800313c:	6313      	str	r3, [r2, #48]	; 0x30
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ TIM8 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM8) == RCC_PERIPHCLK_TIM8)
 800313e:	f410 5000 	ands.w	r0, r0, #8192	; 0x2000
 8003142:	d01c      	beq.n	800317e <HAL_RCCEx_PeriphCLKConfig+0x16e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM8CLKSOURCE(PeriphClkInit->Tim8ClockSelection));
    
    /* Configure the TIM8 clock source */
    __HAL_RCC_TIM8_CONFIG(PeriphClkInit->Tim8ClockSelection);
 8003144:	4a32      	ldr	r2, [pc, #200]	; (8003210 <HAL_RCCEx_PeriphCLKConfig+0x200>)
 8003146:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8003148:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800314a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800314e:	430b      	orrs	r3, r1
 8003150:	6313      	str	r3, [r2, #48]	; 0x30
    __HAL_RCC_TIM20_CONFIG(PeriphClkInit->Tim20ClockSelection);
  }
#endif /* STM32F303xE || STM32F398xx */  

  
  return HAL_OK;
 8003152:	2000      	movs	r0, #0
 8003154:	e013      	b.n	800317e <HAL_RCCEx_PeriphCLKConfig+0x16e>
    FlagStatus       pwrclkchanged = RESET;
 8003156:	2600      	movs	r6, #0
 8003158:	e76f      	b.n	800303a <HAL_RCCEx_PeriphCLKConfig+0x2a>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800315a:	683b      	ldr	r3, [r7, #0]
 800315c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003160:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8003162:	f7fd f8b3 	bl	80002cc <HAL_GetTick>
 8003166:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003168:	683b      	ldr	r3, [r7, #0]
 800316a:	05da      	lsls	r2, r3, #23
 800316c:	f53f af6a 	bmi.w	8003044 <HAL_RCCEx_PeriphCLKConfig+0x34>
          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003170:	f7fd f8ac 	bl	80002cc <HAL_GetTick>
 8003174:	eba0 0008 	sub.w	r0, r0, r8
 8003178:	2864      	cmp	r0, #100	; 0x64
 800317a:	d9f5      	bls.n	8003168 <HAL_RCCEx_PeriphCLKConfig+0x158>
          return HAL_TIMEOUT;
 800317c:	2003      	movs	r0, #3
}
 800317e:	b002      	add	sp, #8
 8003180:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003184:	6862      	ldr	r2, [r4, #4]
 8003186:	f402 7240 	and.w	r2, r2, #768	; 0x300
 800318a:	4293      	cmp	r3, r2
 800318c:	f43f af5f 	beq.w	800304e <HAL_RCCEx_PeriphCLKConfig+0x3e>
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003190:	6a29      	ldr	r1, [r5, #32]
 8003192:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003196:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 800319a:	fa93 f2a3 	rbit	r2, r3
      __HAL_RCC_BACKUPRESET_FORCE();
 800319e:	f8df e078 	ldr.w	lr, [pc, #120]	; 8003218 <HAL_RCCEx_PeriphCLKConfig+0x208>
 80031a2:	fab2 f282 	clz	r2, r2
 80031a6:	4472      	add	r2, lr
 80031a8:	0092      	lsls	r2, r2, #2
 80031aa:	2701      	movs	r7, #1
 80031ac:	6017      	str	r7, [r2, #0]
 80031ae:	fa93 f3a3 	rbit	r3, r3
      __HAL_RCC_BACKUPRESET_RELEASE();
 80031b2:	fab3 f383 	clz	r3, r3
 80031b6:	4473      	add	r3, lr
 80031b8:	009b      	lsls	r3, r3, #2
 80031ba:	2200      	movs	r2, #0
 80031bc:	601a      	str	r2, [r3, #0]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 80031be:	07cb      	lsls	r3, r1, #31
      RCC->BDCR = temp_reg;
 80031c0:	6228      	str	r0, [r5, #32]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 80031c2:	f57f af44 	bpl.w	800304e <HAL_RCCEx_PeriphCLKConfig+0x3e>
        tickstart = HAL_GetTick();
 80031c6:	f7fd f881 	bl	80002cc <HAL_GetTick>
 80031ca:	f04f 0802 	mov.w	r8, #2
 80031ce:	4682      	mov	sl, r0
 80031d0:	46c1      	mov	r9, r8
 80031d2:	fa98 f3a8 	rbit	r3, r8
 80031d6:	fa98 f3a8 	rbit	r3, r8
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80031da:	b1a3      	cbz	r3, 8003206 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
 80031dc:	6a2a      	ldr	r2, [r5, #32]
 80031de:	fa99 f3a9 	rbit	r3, r9
 80031e2:	fab3 f383 	clz	r3, r3
 80031e6:	f003 031f 	and.w	r3, r3, #31
 80031ea:	fa07 f303 	lsl.w	r3, r7, r3
 80031ee:	4213      	tst	r3, r2
 80031f0:	f47f af2d 	bne.w	800304e <HAL_RCCEx_PeriphCLKConfig+0x3e>
            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80031f4:	f7fd f86a 	bl	80002cc <HAL_GetTick>
 80031f8:	f241 3388 	movw	r3, #5000	; 0x1388
 80031fc:	eba0 000a 	sub.w	r0, r0, sl
 8003200:	4298      	cmp	r0, r3
 8003202:	d9e6      	bls.n	80031d2 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
 8003204:	e7ba      	b.n	800317c <HAL_RCCEx_PeriphCLKConfig+0x16c>
 8003206:	fa98 f3a8 	rbit	r3, r8
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800320a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800320c:	e7e7      	b.n	80031de <HAL_RCCEx_PeriphCLKConfig+0x1ce>
 800320e:	bf00      	nop
 8003210:	40021000 	.word	0x40021000
 8003214:	40007000 	.word	0x40007000
 8003218:	10908100 	.word	0x10908100

0800321c <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 800321c:	b570      	push	{r4, r5, r6, lr}
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 800321e:	4604      	mov	r4, r0
 8003220:	2800      	cmp	r0, #0
 8003222:	d04e      	beq.n	80032c2 <HAL_SPI_Init+0xa6>
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003224:	2300      	movs	r3, #0
 8003226:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8003228:	f890 305d 	ldrb.w	r3, [r0, #93]	; 0x5d
 800322c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003230:	b91b      	cbnz	r3, 800323a <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8003232:	f880 205c 	strb.w	r2, [r0, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8003236:	f003 fb25 	bl	8006884 <HAL_SPI_MspInit>
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 800323a:	2302      	movs	r3, #2

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800323c:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 800323e:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d
  __HAL_SPI_DISABLE(hspi);
 8003242:	680b      	ldr	r3, [r1, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003244:	68e2      	ldr	r2, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 8003246:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800324a:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
  __HAL_SPI_DISABLE(hspi);
 800324e:	600b      	str	r3, [r1, #0]
 8003250:	f04f 0300 	mov.w	r3, #0
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003254:	d932      	bls.n	80032bc <HAL_SPI_Init+0xa0>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8003256:	4618      	mov	r0, r3
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8003258:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800325c:	bf18      	it	ne
 800325e:	62a3      	strne	r3, [r4, #40]	; 0x28
  }

  /* Align the CRC Length on the data size */
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8003260:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003262:	b92b      	cbnz	r3, 8003270 <HAL_SPI_Init+0x54>
  {
    /* CRC Length aligned on the data size : value set by default */
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8003264:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8003268:	bf8c      	ite	hi
 800326a:	2302      	movhi	r3, #2
    }
    else
    {
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 800326c:	2301      	movls	r3, #1
 800326e:	6323      	str	r3, [r4, #48]	; 0x30
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8003270:	68a6      	ldr	r6, [r4, #8]
 8003272:	6863      	ldr	r3, [r4, #4]
 8003274:	69a5      	ldr	r5, [r4, #24]
 8003276:	4333      	orrs	r3, r6
 8003278:	6926      	ldr	r6, [r4, #16]
 800327a:	4333      	orrs	r3, r6
 800327c:	6966      	ldr	r6, [r4, #20]
 800327e:	4333      	orrs	r3, r6
 8003280:	69e6      	ldr	r6, [r4, #28]
 8003282:	4333      	orrs	r3, r6
 8003284:	6a26      	ldr	r6, [r4, #32]
 8003286:	4333      	orrs	r3, r6
 8003288:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800328a:	4333      	orrs	r3, r6
 800328c:	f405 7600 	and.w	r6, r5, #512	; 0x200
 8003290:	4333      	orrs	r3, r6
 8003292:	600b      	str	r3, [r1, #0]
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo Threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8003294:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003296:	431a      	orrs	r2, r3
 8003298:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800329a:	0c2d      	lsrs	r5, r5, #16
 800329c:	431a      	orrs	r2, r3
 800329e:	f005 0504 	and.w	r5, r5, #4
 80032a2:	432a      	orrs	r2, r5
 80032a4:	4302      	orrs	r2, r0
 80032a6:	604a      	str	r2, [r1, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80032a8:	69cb      	ldr	r3, [r1, #28]
 80032aa:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80032ae:	61cb      	str	r3, [r1, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80032b0:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 80032b2:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80032b4:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80032b6:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
 80032ba:	bd70      	pop	{r4, r5, r6, pc}
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80032bc:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80032c0:	e7cc      	b.n	800325c <HAL_SPI_Init+0x40>
    return HAL_ERROR;
 80032c2:	2001      	movs	r0, #1
}
 80032c4:	bd70      	pop	{r4, r5, r6, pc}

080032c6 <HAL_SPI_ErrorCallback>:
 80032c6:	4770      	bx	lr

080032c8 <HAL_SPI_IRQHandler>:
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
  uint32_t itsource = hspi->Instance->CR2;
 80032c8:	6803      	ldr	r3, [r0, #0]
{
 80032ca:	b530      	push	{r4, r5, lr}
  uint32_t itsource = hspi->Instance->CR2;
 80032cc:	6859      	ldr	r1, [r3, #4]
  uint32_t itflag   = hspi->Instance->SR;
 80032ce:	689a      	ldr	r2, [r3, #8]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if (((itflag & SPI_FLAG_OVR) == RESET) &&
 80032d0:	f002 0541 	and.w	r5, r2, #65	; 0x41
 80032d4:	2d01      	cmp	r5, #1
{
 80032d6:	b085      	sub	sp, #20
 80032d8:	4604      	mov	r4, r0
  if (((itflag & SPI_FLAG_OVR) == RESET) &&
 80032da:	d105      	bne.n	80032e8 <HAL_SPI_IRQHandler+0x20>
      ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
 80032dc:	064d      	lsls	r5, r1, #25
 80032de:	d503      	bpl.n	80032e8 <HAL_SPI_IRQHandler+0x20>
  {
    hspi->RxISR(hspi);
 80032e0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if (((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
  {
    hspi->TxISR(hspi);
 80032e2:	4798      	blx	r3
        HAL_SPI_ErrorCallback(hspi);
      }
    }
    return;
  }
}
 80032e4:	b005      	add	sp, #20
 80032e6:	bd30      	pop	{r4, r5, pc}
  if (((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
 80032e8:	0795      	lsls	r5, r2, #30
 80032ea:	d504      	bpl.n	80032f6 <HAL_SPI_IRQHandler+0x2e>
 80032ec:	0608      	lsls	r0, r1, #24
 80032ee:	d502      	bpl.n	80032f6 <HAL_SPI_IRQHandler+0x2e>
    hspi->TxISR(hspi);
 80032f0:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80032f2:	4620      	mov	r0, r4
 80032f4:	e7f5      	b.n	80032e2 <HAL_SPI_IRQHandler+0x1a>
  if (((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET) && ((itsource & SPI_IT_ERR) != RESET))
 80032f6:	f412 7fb0 	tst.w	r2, #352	; 0x160
 80032fa:	d0f3      	beq.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
 80032fc:	068d      	lsls	r5, r1, #26
 80032fe:	d5f1      	bpl.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
    if ((itflag & SPI_FLAG_OVR) != RESET)
 8003300:	0650      	lsls	r0, r2, #25
 8003302:	d50f      	bpl.n	8003324 <HAL_SPI_IRQHandler+0x5c>
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8003304:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 8003308:	2803      	cmp	r0, #3
 800330a:	f04f 0500 	mov.w	r5, #0
 800330e:	d041      	beq.n	8003394 <HAL_SPI_IRQHandler+0xcc>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8003310:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8003312:	f040 0004 	orr.w	r0, r0, #4
 8003316:	6620      	str	r0, [r4, #96]	; 0x60
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8003318:	9500      	str	r5, [sp, #0]
 800331a:	68d8      	ldr	r0, [r3, #12]
 800331c:	9000      	str	r0, [sp, #0]
 800331e:	6898      	ldr	r0, [r3, #8]
 8003320:	9000      	str	r0, [sp, #0]
 8003322:	9800      	ldr	r0, [sp, #0]
    if ((itflag & SPI_FLAG_MODF) != RESET)
 8003324:	0695      	lsls	r5, r2, #26
 8003326:	d50c      	bpl.n	8003342 <HAL_SPI_IRQHandler+0x7a>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8003328:	6e20      	ldr	r0, [r4, #96]	; 0x60
 800332a:	f040 0001 	orr.w	r0, r0, #1
 800332e:	6620      	str	r0, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8003330:	2000      	movs	r0, #0
 8003332:	9002      	str	r0, [sp, #8]
 8003334:	6898      	ldr	r0, [r3, #8]
 8003336:	9002      	str	r0, [sp, #8]
 8003338:	6818      	ldr	r0, [r3, #0]
 800333a:	f020 0040 	bic.w	r0, r0, #64	; 0x40
 800333e:	6018      	str	r0, [r3, #0]
 8003340:	9802      	ldr	r0, [sp, #8]
    if ((itflag & SPI_FLAG_FRE) != RESET)
 8003342:	05d0      	lsls	r0, r2, #23
 8003344:	d508      	bpl.n	8003358 <HAL_SPI_IRQHandler+0x90>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8003346:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8003348:	f042 0208 	orr.w	r2, r2, #8
 800334c:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 800334e:	2200      	movs	r2, #0
 8003350:	9203      	str	r2, [sp, #12]
 8003352:	689a      	ldr	r2, [r3, #8]
 8003354:	9203      	str	r2, [sp, #12]
 8003356:	9a03      	ldr	r2, [sp, #12]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8003358:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800335a:	2a00      	cmp	r2, #0
 800335c:	d0c2      	beq.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 800335e:	685a      	ldr	r2, [r3, #4]
 8003360:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 8003364:	605a      	str	r2, [r3, #4]
      hspi->State = HAL_SPI_STATE_READY;
 8003366:	2201      	movs	r2, #1
 8003368:	f884 205d 	strb.w	r2, [r4, #93]	; 0x5d
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 800336c:	078a      	lsls	r2, r1, #30
 800336e:	d018      	beq.n	80033a2 <HAL_SPI_IRQHandler+0xda>
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8003370:	685a      	ldr	r2, [r3, #4]
        if (hspi->hdmarx != NULL)
 8003372:	6da0      	ldr	r0, [r4, #88]	; 0x58
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8003374:	f022 0203 	bic.w	r2, r2, #3
 8003378:	605a      	str	r2, [r3, #4]
        if (hspi->hdmarx != NULL)
 800337a:	b118      	cbz	r0, 8003384 <HAL_SPI_IRQHandler+0xbc>
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 800337c:	4b0b      	ldr	r3, [pc, #44]	; (80033ac <HAL_SPI_IRQHandler+0xe4>)
 800337e:	6343      	str	r3, [r0, #52]	; 0x34
          HAL_DMA_Abort_IT(hspi->hdmarx);
 8003380:	f7fd ff00 	bl	8001184 <HAL_DMA_Abort_IT>
        if (hspi->hdmatx != NULL)
 8003384:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8003386:	2800      	cmp	r0, #0
 8003388:	d0ac      	beq.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 800338a:	4b08      	ldr	r3, [pc, #32]	; (80033ac <HAL_SPI_IRQHandler+0xe4>)
 800338c:	6343      	str	r3, [r0, #52]	; 0x34
          HAL_DMA_Abort_IT(hspi->hdmatx);
 800338e:	f7fd fef9 	bl	8001184 <HAL_DMA_Abort_IT>
 8003392:	e7a7      	b.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8003394:	9501      	str	r5, [sp, #4]
 8003396:	68da      	ldr	r2, [r3, #12]
 8003398:	9201      	str	r2, [sp, #4]
 800339a:	689b      	ldr	r3, [r3, #8]
 800339c:	9301      	str	r3, [sp, #4]
 800339e:	9b01      	ldr	r3, [sp, #4]
        return;
 80033a0:	e7a0      	b.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
        HAL_SPI_ErrorCallback(hspi);
 80033a2:	4620      	mov	r0, r4
 80033a4:	f7ff ff8f 	bl	80032c6 <HAL_SPI_ErrorCallback>
 80033a8:	e79c      	b.n	80032e4 <HAL_SPI_IRQHandler+0x1c>
 80033aa:	bf00      	nop
 80033ac:	080033b1 	.word	0x080033b1

080033b0 <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 80033b0:	b508      	push	{r3, lr}
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80033b2:	6a40      	ldr	r0, [r0, #36]	; 0x24
  hspi->RxXferCount = 0U;
 80033b4:	2300      	movs	r3, #0
 80033b6:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  hspi->TxXferCount = 0U;
 80033ba:	87c3      	strh	r3, [r0, #62]	; 0x3e

  HAL_SPI_ErrorCallback(hspi);
 80033bc:	f7ff ff83 	bl	80032c6 <HAL_SPI_ErrorCallback>
 80033c0:	bd08      	pop	{r3, pc}
	...

080033c4 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 80033c4:	b538      	push	{r3, r4, r5, lr}
   *  the UART Word Length, Parity, Mode and oversampling:
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033c6:	6882      	ldr	r2, [r0, #8]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80033c8:	6805      	ldr	r5, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033ca:	69c3      	ldr	r3, [r0, #28]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80033cc:	6829      	ldr	r1, [r5, #0]
{
 80033ce:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033d0:	6900      	ldr	r0, [r0, #16]
 80033d2:	4302      	orrs	r2, r0
 80033d4:	6960      	ldr	r0, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80033d6:	f421 4116 	bic.w	r1, r1, #38400	; 0x9600
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033da:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80033dc:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033e0:	431a      	orrs	r2, r3
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 80033e2:	430a      	orrs	r2, r1
 80033e4:	602a      	str	r2, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80033e6:	686a      	ldr	r2, [r5, #4]
 80033e8:	68e1      	ldr	r1, [r4, #12]
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 80033ea:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80033ec:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80033f0:	430a      	orrs	r2, r1
 80033f2:	606a      	str	r2, [r5, #4]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 80033f4:	68a9      	ldr	r1, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 80033f6:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 80033f8:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 80033fc:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 80033fe:	430a      	orrs	r2, r1
 8003400:	60aa      	str	r2, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003402:	4a6e      	ldr	r2, [pc, #440]	; (80035bc <UART_SetConfig+0x1f8>)
 8003404:	4295      	cmp	r5, r2
 8003406:	d112      	bne.n	800342e <UART_SetConfig+0x6a>
 8003408:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
 800340c:	496c      	ldr	r1, [pc, #432]	; (80035c0 <UART_SetConfig+0x1fc>)
 800340e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8003410:	f002 0203 	and.w	r2, r2, #3

  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003414:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003418:	5c8a      	ldrb	r2, [r1, r2]
 800341a:	d066      	beq.n	80034ea <UART_SetConfig+0x126>
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
    huart->Instance->BRR = brrtemp;
  }
  else
  {
    switch (clocksource)
 800341c:	2a08      	cmp	r2, #8
 800341e:	d819      	bhi.n	8003454 <UART_SetConfig+0x90>
 8003420:	e8df f002 	tbb	[pc, r2]
 8003424:	189e92c2 	.word	0x189e92c2
 8003428:	181818a9 	.word	0x181818a9
 800342c:	ac          	.byte	0xac
 800342d:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 800342e:	4a65      	ldr	r2, [pc, #404]	; (80035c4 <UART_SetConfig+0x200>)
 8003430:	4295      	cmp	r5, r2
 8003432:	d124      	bne.n	800347e <UART_SetConfig+0xba>
 8003434:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 8003438:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800343a:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800343e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8003442:	f000 80a0 	beq.w	8003586 <UART_SetConfig+0x1c2>
 8003446:	d807      	bhi.n	8003458 <UART_SetConfig+0x94>
 8003448:	2a00      	cmp	r2, #0
 800344a:	f000 80aa 	beq.w	80035a2 <UART_SetConfig+0x1de>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800344e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003452:	d076      	beq.n	8003542 <UART_SetConfig+0x17e>
      case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
        break;
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8003454:	2001      	movs	r0, #1
        break;
    }
  }

  return ret;
 8003456:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003458:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 800345c:	f000 8099 	beq.w	8003592 <UART_SetConfig+0x1ce>
 8003460:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 8003464:	d1f3      	bne.n	800344e <UART_SetConfig+0x8a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003466:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800346a:	d179      	bne.n	8003560 <UART_SetConfig+0x19c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800346c:	6860      	ldr	r0, [r4, #4]
 800346e:	0843      	lsrs	r3, r0, #1
 8003470:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8003474:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8003478:	fbb3 f3f0 	udiv	r3, r3, r0
 800347c:	e054      	b.n	8003528 <UART_SetConfig+0x164>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800347e:	4a52      	ldr	r2, [pc, #328]	; (80035c8 <UART_SetConfig+0x204>)
 8003480:	4295      	cmp	r5, r2
 8003482:	d10e      	bne.n	80034a2 <UART_SetConfig+0xde>
 8003484:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 8003488:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800348a:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
 800348e:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 8003492:	d078      	beq.n	8003586 <UART_SetConfig+0x1c2>
 8003494:	d9d8      	bls.n	8003448 <UART_SetConfig+0x84>
 8003496:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 800349a:	d07a      	beq.n	8003592 <UART_SetConfig+0x1ce>
 800349c:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
 80034a0:	e7e0      	b.n	8003464 <UART_SetConfig+0xa0>
 80034a2:	4a4a      	ldr	r2, [pc, #296]	; (80035cc <UART_SetConfig+0x208>)
 80034a4:	4295      	cmp	r5, r2
 80034a6:	d10e      	bne.n	80034c6 <UART_SetConfig+0x102>
 80034a8:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 80034ac:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80034ae:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80034b2:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80034b6:	d066      	beq.n	8003586 <UART_SetConfig+0x1c2>
 80034b8:	d9c6      	bls.n	8003448 <UART_SetConfig+0x84>
 80034ba:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 80034be:	d068      	beq.n	8003592 <UART_SetConfig+0x1ce>
 80034c0:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 80034c4:	e7ce      	b.n	8003464 <UART_SetConfig+0xa0>
 80034c6:	4a42      	ldr	r2, [pc, #264]	; (80035d0 <UART_SetConfig+0x20c>)
 80034c8:	4295      	cmp	r5, r2
 80034ca:	d1c0      	bne.n	800344e <UART_SetConfig+0x8a>
 80034cc:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 80034d0:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80034d2:	f402 0240 	and.w	r2, r2, #12582912	; 0xc00000
 80034d6:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 80034da:	d054      	beq.n	8003586 <UART_SetConfig+0x1c2>
 80034dc:	d9b4      	bls.n	8003448 <UART_SetConfig+0x84>
 80034de:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 80034e2:	d056      	beq.n	8003592 <UART_SetConfig+0x1ce>
 80034e4:	f5b2 0f40 	cmp.w	r2, #12582912	; 0xc00000
 80034e8:	e7bc      	b.n	8003464 <UART_SetConfig+0xa0>
    switch (clocksource)
 80034ea:	2a08      	cmp	r2, #8
 80034ec:	d829      	bhi.n	8003542 <UART_SetConfig+0x17e>
 80034ee:	a301      	add	r3, pc, #4	; (adr r3, 80034f4 <UART_SetConfig+0x130>)
 80034f0:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 80034f4:	08003519 	.word	0x08003519
 80034f8:	0800353d 	.word	0x0800353d
 80034fc:	0800346d 	.word	0x0800346d
 8003500:	08003543 	.word	0x08003543
 8003504:	0800358d 	.word	0x0800358d
 8003508:	08003543 	.word	0x08003543
 800350c:	08003543 	.word	0x08003543
 8003510:	08003543 	.word	0x08003543
 8003514:	08003599 	.word	0x08003599
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8003518:	f7ff fd4a 	bl	8002fb0 <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800351c:	6861      	ldr	r1, [r4, #4]
 800351e:	084a      	lsrs	r2, r1, #1
 8003520:	eb02 0340 	add.w	r3, r2, r0, lsl #1
 8003524:	fbb3 f3f1 	udiv	r3, r3, r1
 8003528:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 800352a:	2000      	movs	r0, #0
    brrtemp = usartdiv & 0xFFF0U;
 800352c:	f023 020f 	bic.w	r2, r3, #15
    huart->Instance->BRR = brrtemp;
 8003530:	6821      	ldr	r1, [r4, #0]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8003532:	f3c3 0342 	ubfx	r3, r3, #1, #3
    huart->Instance->BRR = brrtemp;
 8003536:	4313      	orrs	r3, r2
 8003538:	60cb      	str	r3, [r1, #12]
 800353a:	bd38      	pop	{r3, r4, r5, pc}
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800353c:	f7ff fd50 	bl	8002fe0 <HAL_RCC_GetPCLK2Freq>
 8003540:	e7ec      	b.n	800351c <UART_SetConfig+0x158>
        ret = HAL_ERROR;
 8003542:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000U;
 8003544:	2300      	movs	r3, #0
 8003546:	e7f1      	b.n	800352c <UART_SetConfig+0x168>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8003548:	f7ff fd4a 	bl	8002fe0 <HAL_RCC_GetPCLK2Freq>
 800354c:	6863      	ldr	r3, [r4, #4]
 800354e:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8003552:	fbb0 f0f3 	udiv	r0, r0, r3
 8003556:	4b19      	ldr	r3, [pc, #100]	; (80035bc <UART_SetConfig+0x1f8>)
 8003558:	b280      	uxth	r0, r0
 800355a:	60d8      	str	r0, [r3, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 800355c:	2000      	movs	r0, #0
        break;
 800355e:	bd38      	pop	{r3, r4, r5, pc}
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8003560:	6862      	ldr	r2, [r4, #4]
 8003562:	0853      	lsrs	r3, r2, #1
 8003564:	f503 03f4 	add.w	r3, r3, #7995392	; 0x7a0000
 8003568:	f503 5390 	add.w	r3, r3, #4608	; 0x1200
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800356c:	fbb3 f3f2 	udiv	r3, r3, r2
 8003570:	b29b      	uxth	r3, r3
 8003572:	60eb      	str	r3, [r5, #12]
 8003574:	e7f2      	b.n	800355c <UART_SetConfig+0x198>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8003576:	f7ff fc21 	bl	8002dbc <HAL_RCC_GetSysClockFreq>
 800357a:	e017      	b.n	80035ac <UART_SetConfig+0x1e8>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800357c:	6862      	ldr	r2, [r4, #4]
 800357e:	0853      	lsrs	r3, r2, #1
 8003580:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 8003584:	e7f2      	b.n	800356c <UART_SetConfig+0x1a8>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003586:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800358a:	d1f4      	bne.n	8003576 <UART_SetConfig+0x1b2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800358c:	f7ff fc16 	bl	8002dbc <HAL_RCC_GetSysClockFreq>
 8003590:	e7c4      	b.n	800351c <UART_SetConfig+0x158>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003592:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8003596:	d1f1      	bne.n	800357c <UART_SetConfig+0x1b8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8003598:	6860      	ldr	r0, [r4, #4]
 800359a:	0843      	lsrs	r3, r0, #1
 800359c:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80035a0:	e76a      	b.n	8003478 <UART_SetConfig+0xb4>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80035a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80035a6:	d0b7      	beq.n	8003518 <UART_SetConfig+0x154>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80035a8:	f7ff fd02 	bl	8002fb0 <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80035ac:	6863      	ldr	r3, [r4, #4]
 80035ae:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80035b2:	fbb0 f0f3 	udiv	r0, r0, r3
 80035b6:	b280      	uxth	r0, r0
 80035b8:	60e8      	str	r0, [r5, #12]
 80035ba:	e7cf      	b.n	800355c <UART_SetConfig+0x198>
 80035bc:	40013800 	.word	0x40013800
 80035c0:	08007a34 	.word	0x08007a34
 80035c4:	40004400 	.word	0x40004400
 80035c8:	40004800 	.word	0x40004800
 80035cc:	40004c00 	.word	0x40004c00
 80035d0:	40005000 	.word	0x40005000

080035d4 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80035d4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80035d6:	07da      	lsls	r2, r3, #31
{
 80035d8:	b510      	push	{r4, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80035da:	d506      	bpl.n	80035ea <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80035dc:	6801      	ldr	r1, [r0, #0]
 80035de:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80035e0:	684a      	ldr	r2, [r1, #4]
 80035e2:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80035e6:	4322      	orrs	r2, r4
 80035e8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80035ea:	079c      	lsls	r4, r3, #30
 80035ec:	d506      	bpl.n	80035fc <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80035ee:	6801      	ldr	r1, [r0, #0]
 80035f0:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80035f2:	684a      	ldr	r2, [r1, #4]
 80035f4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80035f8:	4322      	orrs	r2, r4
 80035fa:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80035fc:	0759      	lsls	r1, r3, #29
 80035fe:	d506      	bpl.n	800360e <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8003600:	6801      	ldr	r1, [r0, #0]
 8003602:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8003604:	684a      	ldr	r2, [r1, #4]
 8003606:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800360a:	4322      	orrs	r2, r4
 800360c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800360e:	071a      	lsls	r2, r3, #28
 8003610:	d506      	bpl.n	8003620 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8003612:	6801      	ldr	r1, [r0, #0]
 8003614:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003616:	684a      	ldr	r2, [r1, #4]
 8003618:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800361c:	4322      	orrs	r2, r4
 800361e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8003620:	06dc      	lsls	r4, r3, #27
 8003622:	d506      	bpl.n	8003632 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8003624:	6801      	ldr	r1, [r0, #0]
 8003626:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8003628:	688a      	ldr	r2, [r1, #8]
 800362a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800362e:	4322      	orrs	r2, r4
 8003630:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8003632:	0699      	lsls	r1, r3, #26
 8003634:	d506      	bpl.n	8003644 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8003636:	6801      	ldr	r1, [r0, #0]
 8003638:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800363a:	688a      	ldr	r2, [r1, #8]
 800363c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003640:	4322      	orrs	r2, r4
 8003642:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8003644:	065a      	lsls	r2, r3, #25
 8003646:	d50f      	bpl.n	8003668 <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003648:	6801      	ldr	r1, [r0, #0]
 800364a:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800364c:	684a      	ldr	r2, [r1, #4]
 800364e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8003652:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003654:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003658:	604a      	str	r2, [r1, #4]
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800365a:	d105      	bne.n	8003668 <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800365c:	684a      	ldr	r2, [r1, #4]
 800365e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8003660:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8003664:	4322      	orrs	r2, r4
 8003666:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8003668:	061b      	lsls	r3, r3, #24
 800366a:	d506      	bpl.n	800367a <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800366c:	6802      	ldr	r2, [r0, #0]
 800366e:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8003670:	6853      	ldr	r3, [r2, #4]
 8003672:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003676:	430b      	orrs	r3, r1
 8003678:	6053      	str	r3, [r2, #4]
 800367a:	bd10      	pop	{r4, pc}

0800367c <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 800367c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003680:	9d06      	ldr	r5, [sp, #24]
 8003682:	4604      	mov	r4, r0
 8003684:	460f      	mov	r7, r1
 8003686:	4616      	mov	r6, r2
 8003688:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800368a:	6821      	ldr	r1, [r4, #0]
 800368c:	69ca      	ldr	r2, [r1, #28]
 800368e:	ea37 0302 	bics.w	r3, r7, r2
 8003692:	bf0c      	ite	eq
 8003694:	2201      	moveq	r2, #1
 8003696:	2200      	movne	r2, #0
 8003698:	42b2      	cmp	r2, r6
 800369a:	d002      	beq.n	80036a2 <UART_WaitOnFlagUntilTimeout+0x26>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 800369c:	2000      	movs	r0, #0
}
 800369e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 80036a2:	1c6b      	adds	r3, r5, #1
 80036a4:	d0f2      	beq.n	800368c <UART_WaitOnFlagUntilTimeout+0x10>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80036a6:	b99d      	cbnz	r5, 80036d0 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80036a8:	6823      	ldr	r3, [r4, #0]
 80036aa:	681a      	ldr	r2, [r3, #0]
 80036ac:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 80036b0:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80036b2:	689a      	ldr	r2, [r3, #8]
 80036b4:	f022 0201 	bic.w	r2, r2, #1
 80036b8:	609a      	str	r2, [r3, #8]
        huart->gState  = HAL_UART_STATE_READY;
 80036ba:	2320      	movs	r3, #32
 80036bc:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
        huart->RxState = HAL_UART_STATE_READY;
 80036c0:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
        __HAL_UNLOCK(huart);
 80036c4:	2300      	movs	r3, #0
 80036c6:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 80036ca:	2003      	movs	r0, #3
 80036cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80036d0:	f7fc fdfc 	bl	80002cc <HAL_GetTick>
 80036d4:	eba0 0008 	sub.w	r0, r0, r8
 80036d8:	4285      	cmp	r5, r0
 80036da:	d2d6      	bcs.n	800368a <UART_WaitOnFlagUntilTimeout+0xe>
 80036dc:	e7e4      	b.n	80036a8 <UART_WaitOnFlagUntilTimeout+0x2c>

080036de <UART_CheckIdleState>:
{
 80036de:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80036e0:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80036e2:	2600      	movs	r6, #0
 80036e4:	66c6      	str	r6, [r0, #108]	; 0x6c
  tickstart = HAL_GetTick();
 80036e6:	f7fc fdf1 	bl	80002cc <HAL_GetTick>
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80036ea:	6823      	ldr	r3, [r4, #0]
 80036ec:	681b      	ldr	r3, [r3, #0]
 80036ee:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 80036f0:	4605      	mov	r5, r0
  if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80036f2:	d417      	bmi.n	8003724 <UART_CheckIdleState+0x46>
  if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80036f4:	6823      	ldr	r3, [r4, #0]
 80036f6:	681b      	ldr	r3, [r3, #0]
 80036f8:	075b      	lsls	r3, r3, #29
 80036fa:	d50a      	bpl.n	8003712 <UART_CheckIdleState+0x34>
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80036fc:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003700:	9300      	str	r3, [sp, #0]
 8003702:	2200      	movs	r2, #0
 8003704:	462b      	mov	r3, r5
 8003706:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800370a:	4620      	mov	r0, r4
 800370c:	f7ff ffb6 	bl	800367c <UART_WaitOnFlagUntilTimeout>
 8003710:	b9a0      	cbnz	r0, 800373c <UART_CheckIdleState+0x5e>
  huart->gState  = HAL_UART_STATE_READY;
 8003712:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8003714:	2000      	movs	r0, #0
  huart->gState  = HAL_UART_STATE_READY;
 8003716:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UNLOCK(huart);
 800371a:	f884 0068 	strb.w	r0, [r4, #104]	; 0x68
  huart->RxState = HAL_UART_STATE_READY;
 800371e:	f884 306a 	strb.w	r3, [r4, #106]	; 0x6a
  return HAL_OK;
 8003722:	e00c      	b.n	800373e <UART_CheckIdleState+0x60>
    if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003724:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003728:	9300      	str	r3, [sp, #0]
 800372a:	4632      	mov	r2, r6
 800372c:	4603      	mov	r3, r0
 800372e:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8003732:	4620      	mov	r0, r4
 8003734:	f7ff ffa2 	bl	800367c <UART_WaitOnFlagUntilTimeout>
 8003738:	2800      	cmp	r0, #0
 800373a:	d0db      	beq.n	80036f4 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 800373c:	2003      	movs	r0, #3
}
 800373e:	b002      	add	sp, #8
 8003740:	bd70      	pop	{r4, r5, r6, pc}

08003742 <HAL_UART_Init>:
{
 8003742:	b510      	push	{r4, lr}
  if(huart == NULL)
 8003744:	4604      	mov	r4, r0
 8003746:	b360      	cbz	r0, 80037a2 <HAL_UART_Init+0x60>
  if(huart->gState == HAL_UART_STATE_RESET)
 8003748:	f890 3069 	ldrb.w	r3, [r0, #105]	; 0x69
 800374c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003750:	b91b      	cbnz	r3, 800375a <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8003752:	f880 2068 	strb.w	r2, [r0, #104]	; 0x68
    HAL_UART_MspInit(huart);
 8003756:	f003 f8c1 	bl	80068dc <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 800375a:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800375c:	2324      	movs	r3, #36	; 0x24
 800375e:	f884 3069 	strb.w	r3, [r4, #105]	; 0x69
  __HAL_UART_DISABLE(huart);
 8003762:	6813      	ldr	r3, [r2, #0]
 8003764:	f023 0301 	bic.w	r3, r3, #1
 8003768:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800376a:	4620      	mov	r0, r4
 800376c:	f7ff fe2a 	bl	80033c4 <UART_SetConfig>
 8003770:	2801      	cmp	r0, #1
 8003772:	d016      	beq.n	80037a2 <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8003774:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003776:	b113      	cbz	r3, 800377e <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
 8003778:	4620      	mov	r0, r4
 800377a:	f7ff ff2b 	bl	80035d4 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800377e:	6823      	ldr	r3, [r4, #0]
 8003780:	685a      	ldr	r2, [r3, #4]
 8003782:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8003786:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003788:	689a      	ldr	r2, [r3, #8]
 800378a:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800378e:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8003790:	681a      	ldr	r2, [r3, #0]
 8003792:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8003796:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8003798:	601a      	str	r2, [r3, #0]
}
 800379a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 800379e:	f7ff bf9e 	b.w	80036de <UART_CheckIdleState>
}
 80037a2:	2001      	movs	r0, #1
 80037a4:	bd10      	pop	{r4, pc}

080037a6 <USBD_CDC_DataIn>:
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80037a6:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if(pdev->pClassData != NULL)
 80037aa:	b11b      	cbz	r3, 80037b4 <USBD_CDC_DataIn+0xe>
  {
    
    hcdc->TxState = 0;
 80037ac:	2000      	movs	r0, #0
 80037ae:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214

    return USBD_OK;
 80037b2:	4770      	bx	lr
  }
  else
  {
    return USBD_FAIL;
 80037b4:	2002      	movs	r0, #2
  }
}
 80037b6:	4770      	bx	lr

080037b8 <USBD_CDC_EP0_RxReady>:
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 80037b8:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
{ 
 80037bc:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80037be:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 80037c2:	b15b      	cbz	r3, 80037dc <USBD_CDC_EP0_RxReady+0x24>
 80037c4:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 80037c8:	28ff      	cmp	r0, #255	; 0xff
 80037ca:	d007      	beq.n	80037dc <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 80037cc:	689b      	ldr	r3, [r3, #8]
 80037ce:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 80037d2:	4621      	mov	r1, r4
 80037d4:	4798      	blx	r3
                                                      (uint8_t *)hcdc->data,
                                                      hcdc->CmdLength);
      hcdc->CmdOpCode = 0xFF; 
 80037d6:	23ff      	movs	r3, #255	; 0xff
 80037d8:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
      
  }
  return USBD_OK;
}
 80037dc:	2000      	movs	r0, #0
 80037de:	bd10      	pop	{r4, pc}

080037e0 <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgFSDesc);
 80037e0:	2343      	movs	r3, #67	; 0x43
 80037e2:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 80037e4:	4800      	ldr	r0, [pc, #0]	; (80037e8 <USBD_CDC_GetFSCfgDesc+0x8>)
 80037e6:	4770      	bx	lr
 80037e8:	20000038 	.word	0x20000038

080037ec <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgHSDesc);
 80037ec:	2343      	movs	r3, #67	; 0x43
 80037ee:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 80037f0:	4800      	ldr	r0, [pc, #0]	; (80037f4 <USBD_CDC_GetHSCfgDesc+0x8>)
 80037f2:	4770      	bx	lr
 80037f4:	2000007c 	.word	0x2000007c

080037f8 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_OtherSpeedCfgDesc);
 80037f8:	2343      	movs	r3, #67	; 0x43
 80037fa:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 80037fc:	4800      	ldr	r0, [pc, #0]	; (8003800 <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 80037fe:	4770      	bx	lr
 8003800:	200000cc 	.word	0x200000cc

08003804 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_CDC_DeviceQualifierDesc);
 8003804:	230a      	movs	r3, #10
 8003806:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 8003808:	4800      	ldr	r0, [pc, #0]	; (800380c <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 800380a:	4770      	bx	lr
 800380c:	200000c0 	.word	0x200000c0

08003810 <USBD_CDC_DataOut>:
{      
 8003810:	b538      	push	{r3, r4, r5, lr}
 8003812:	4605      	mov	r5, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8003814:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8003818:	f003 fbf4 	bl	8007004 <USBD_LL_GetRxDataSize>
  if(pdev->pClassData != NULL)
 800381c:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8003820:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
  if(pdev->pClassData != NULL)
 8003824:	b14b      	cbz	r3, 800383a <USBD_CDC_DataOut+0x2a>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8003826:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 800382a:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 800382e:	68db      	ldr	r3, [r3, #12]
 8003830:	f504 7103 	add.w	r1, r4, #524	; 0x20c
 8003834:	4798      	blx	r3
    return USBD_OK;
 8003836:	2000      	movs	r0, #0
 8003838:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 800383a:	2002      	movs	r0, #2
}
 800383c:	bd38      	pop	{r3, r4, r5, pc}
	...

08003840 <USBD_CDC_Setup>:
{
 8003840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8003842:	780f      	ldrb	r7, [r1, #0]
 8003844:	f017 0360 	ands.w	r3, r7, #96	; 0x60
{
 8003848:	4606      	mov	r6, r0
 800384a:	460c      	mov	r4, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800384c:	d023      	beq.n	8003896 <USBD_CDC_Setup+0x56>
 800384e:	2b20      	cmp	r3, #32
 8003850:	d119      	bne.n	8003886 <USBD_CDC_Setup+0x46>
    if (req->wLength)
 8003852:	88ca      	ldrh	r2, [r1, #6]
 8003854:	784b      	ldrb	r3, [r1, #1]
 8003856:	b1c2      	cbz	r2, 800388a <USBD_CDC_Setup+0x4a>
      if (req->bmRequest & 0x80)
 8003858:	0639      	lsls	r1, r7, #24
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 800385a:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
      if (req->bmRequest & 0x80)
 800385e:	d50b      	bpl.n	8003878 <USBD_CDC_Setup+0x38>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8003860:	f8d0 121c 	ldr.w	r1, [r0, #540]	; 0x21c
 8003864:	4618      	mov	r0, r3
 8003866:	688f      	ldr	r7, [r1, #8]
 8003868:	4629      	mov	r1, r5
 800386a:	47b8      	blx	r7
          USBD_CtlSendData (pdev, 
 800386c:	88e2      	ldrh	r2, [r4, #6]
 800386e:	4629      	mov	r1, r5
 8003870:	4630      	mov	r0, r6
      USBD_CtlSendData (pdev,
 8003872:	f000 fb72 	bl	8003f5a <USBD_CtlSendData>
      break;
 8003876:	e006      	b.n	8003886 <USBD_CDC_Setup+0x46>
        hcdc->CmdOpCode = req->bRequest;
 8003878:	f885 3200 	strb.w	r3, [r5, #512]	; 0x200
        hcdc->CmdLength = req->wLength;
 800387c:	f885 2201 	strb.w	r2, [r5, #513]	; 0x201
        USBD_CtlPrepareRx (pdev, 
 8003880:	4629      	mov	r1, r5
 8003882:	f000 fb7f 	bl	8003f84 <USBD_CtlPrepareRx>
}
 8003886:	2000      	movs	r0, #0
 8003888:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800388a:	f8d0 021c 	ldr.w	r0, [r0, #540]	; 0x21c
 800388e:	6884      	ldr	r4, [r0, #8]
 8003890:	4618      	mov	r0, r3
 8003892:	47a0      	blx	r4
 8003894:	e7f7      	b.n	8003886 <USBD_CDC_Setup+0x46>
    switch (req->bRequest)
 8003896:	784b      	ldrb	r3, [r1, #1]
 8003898:	2b0a      	cmp	r3, #10
 800389a:	d1f4      	bne.n	8003886 <USBD_CDC_Setup+0x46>
      USBD_CtlSendData (pdev,
 800389c:	2201      	movs	r2, #1
 800389e:	4901      	ldr	r1, [pc, #4]	; (80038a4 <USBD_CDC_Setup+0x64>)
 80038a0:	e7e7      	b.n	8003872 <USBD_CDC_Setup+0x32>
 80038a2:	bf00      	nop
 80038a4:	200001f0 	.word	0x200001f0

080038a8 <USBD_CDC_DeInit>:
{
 80038a8:	b510      	push	{r4, lr}
  USBD_LL_CloseEP(pdev,
 80038aa:	2181      	movs	r1, #129	; 0x81
{
 80038ac:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 80038ae:	f003 fb41 	bl	8006f34 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80038b2:	2101      	movs	r1, #1
 80038b4:	4620      	mov	r0, r4
 80038b6:	f003 fb3d 	bl	8006f34 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80038ba:	2182      	movs	r1, #130	; 0x82
 80038bc:	4620      	mov	r0, r4
 80038be:	f003 fb39 	bl	8006f34 <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 80038c2:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 80038c6:	b153      	cbz	r3, 80038de <USBD_CDC_DeInit+0x36>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 80038c8:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 80038cc:	685b      	ldr	r3, [r3, #4]
 80038ce:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 80038d0:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 80038d4:	f003 fba0 	bl	8007018 <USBD_static_free>
    pdev->pClassData = NULL;
 80038d8:	2300      	movs	r3, #0
 80038da:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
}
 80038de:	2000      	movs	r0, #0
 80038e0:	bd10      	pop	{r4, pc}

080038e2 <USBD_CDC_Init>:
{
 80038e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80038e4:	7c03      	ldrb	r3, [r0, #16]
{
 80038e6:	4604      	mov	r4, r0
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80038e8:	bb7b      	cbnz	r3, 800394a <USBD_CDC_Init+0x68>
    USBD_LL_OpenEP(pdev,
 80038ea:	f44f 7300 	mov.w	r3, #512	; 0x200
 80038ee:	2202      	movs	r2, #2
 80038f0:	2181      	movs	r1, #129	; 0x81
 80038f2:	f003 fb0f 	bl	8006f14 <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 80038f6:	f44f 7300 	mov.w	r3, #512	; 0x200
    USBD_LL_OpenEP(pdev,
 80038fa:	2202      	movs	r2, #2
 80038fc:	2101      	movs	r1, #1
 80038fe:	4620      	mov	r0, r4
 8003900:	f003 fb08 	bl	8006f14 <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev,
 8003904:	2308      	movs	r3, #8
 8003906:	2203      	movs	r2, #3
 8003908:	2182      	movs	r1, #130	; 0x82
 800390a:	4620      	mov	r0, r4
 800390c:	f003 fb02 	bl	8006f14 <USBD_LL_OpenEP>
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
 8003910:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8003914:	f003 fb7c 	bl	8007010 <USBD_static_malloc>
 8003918:	4606      	mov	r6, r0
 800391a:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  if(pdev->pClassData == NULL)
 800391e:	b320      	cbz	r0, 800396a <USBD_CDC_Init+0x88>
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8003920:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8003924:	681b      	ldr	r3, [r3, #0]
 8003926:	4798      	blx	r3
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8003928:	7c27      	ldrb	r7, [r4, #16]
    hcdc->TxState =0;
 800392a:	2500      	movs	r5, #0
 800392c:	f8c6 5214 	str.w	r5, [r6, #532]	; 0x214
    hcdc->RxState =0;
 8003930:	f8c6 5218 	str.w	r5, [r6, #536]	; 0x218
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8003934:	b987      	cbnz	r7, 8003958 <USBD_CDC_Init+0x76>
      USBD_LL_PrepareReceive(pdev,
 8003936:	f44f 7300 	mov.w	r3, #512	; 0x200
 800393a:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 800393e:	2101      	movs	r1, #1
 8003940:	4620      	mov	r0, r4
 8003942:	f003 fb51 	bl	8006fe8 <USBD_LL_PrepareReceive>
  uint8_t ret = 0;
 8003946:	4638      	mov	r0, r7
 8003948:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBD_LL_OpenEP(pdev,
 800394a:	2340      	movs	r3, #64	; 0x40
 800394c:	2202      	movs	r2, #2
 800394e:	2181      	movs	r1, #129	; 0x81
 8003950:	f003 fae0 	bl	8006f14 <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 8003954:	2340      	movs	r3, #64	; 0x40
 8003956:	e7d0      	b.n	80038fa <USBD_CDC_Init+0x18>
      USBD_LL_PrepareReceive(pdev,
 8003958:	2340      	movs	r3, #64	; 0x40
 800395a:	f8d6 2204 	ldr.w	r2, [r6, #516]	; 0x204
 800395e:	2101      	movs	r1, #1
 8003960:	4620      	mov	r0, r4
 8003962:	f003 fb41 	bl	8006fe8 <USBD_LL_PrepareReceive>
  uint8_t ret = 0;
 8003966:	4628      	mov	r0, r5
 8003968:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1; 
 800396a:	2001      	movs	r0, #1
}
 800396c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800396e <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
  
  if(fops != NULL)
 800396e:	b119      	cbz	r1, 8003978 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 8003970:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;    
 8003974:	2000      	movs	r0, #0
 8003976:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 8003978:	2002      	movs	r0, #2
  }
  
  return ret;
}
 800397a:	4770      	bx	lr

0800397c <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 800397c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;  
  
  return USBD_OK;  
}
 8003980:	2000      	movs	r0, #0
  hcdc->TxBuffer = pbuff;
 8003982:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;  
 8003986:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
 800398a:	4770      	bx	lr

0800398c <USBD_CDC_SetRxBuffer>:
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 800398c:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  return USBD_OK;
}
 8003990:	2000      	movs	r0, #0
  hcdc->RxBuffer = pbuff;
 8003992:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
}
 8003996:	4770      	bx	lr

08003998 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8003998:	f8d0 2218 	ldr.w	r2, [r0, #536]	; 0x218
{      
 800399c:	b510      	push	{r4, lr}
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
 800399e:	b162      	cbz	r2, 80039ba <USBD_CDC_ReceivePacket+0x22>
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80039a0:	7c04      	ldrb	r4, [r0, #16]
 80039a2:	b944      	cbnz	r4, 80039b6 <USBD_CDC_ReceivePacket+0x1e>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 80039a4:	f44f 7300 	mov.w	r3, #512	; 0x200
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 80039a8:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
 80039ac:	2101      	movs	r1, #1
 80039ae:	f003 fb1b 	bl	8006fe8 <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 80039b2:	2000      	movs	r0, #0
 80039b4:	bd10      	pop	{r4, pc}
      USBD_LL_PrepareReceive(pdev,
 80039b6:	2340      	movs	r3, #64	; 0x40
 80039b8:	e7f6      	b.n	80039a8 <USBD_CDC_ReceivePacket+0x10>
  }
  else
  {
    return USBD_FAIL;
 80039ba:	2002      	movs	r0, #2
  }
}
 80039bc:	bd10      	pop	{r4, pc}

080039be <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 80039be:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 80039c0:	b180      	cbz	r0, 80039e4 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 80039c2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80039c6:	b113      	cbz	r3, 80039ce <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 80039c8:	2300      	movs	r3, #0
 80039ca:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 80039ce:	b109      	cbz	r1, 80039d4 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 80039d0:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 80039d4:	2301      	movs	r3, #1
 80039d6:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 80039da:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 80039dc:	f003 fa44 	bl	8006e68 <USBD_LL_Init>
  
  return USBD_OK; 
 80039e0:	2000      	movs	r0, #0
 80039e2:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 80039e4:	2002      	movs	r0, #2
}
 80039e6:	bd08      	pop	{r3, pc}

080039e8 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 80039e8:	b119      	cbz	r1, 80039f2 <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 80039ea:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 80039ee:	2000      	movs	r0, #0
 80039f0:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 80039f2:	2002      	movs	r0, #2
  }
  
  return status;
}
 80039f4:	4770      	bx	lr

080039f6 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 80039f6:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 80039f8:	f003 fa7e 	bl	8006ef8 <USBD_LL_Start>
  
  return USBD_OK;  
}
 80039fc:	2000      	movs	r0, #0
 80039fe:	bd08      	pop	{r3, pc}

08003a00 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8003a00:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 8003a02:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003a06:	b90b      	cbnz	r3, 8003a0c <USBD_SetClassConfig+0xc>
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8003a08:	2002      	movs	r0, #2
 8003a0a:	bd08      	pop	{r3, pc}
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8003a0c:	681b      	ldr	r3, [r3, #0]
 8003a0e:	4798      	blx	r3
 8003a10:	2800      	cmp	r0, #0
 8003a12:	d1f9      	bne.n	8003a08 <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 8003a14:	bd08      	pop	{r3, pc}

08003a16 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8003a16:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8003a18:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003a1c:	685b      	ldr	r3, [r3, #4]
 8003a1e:	4798      	blx	r3
  return USBD_OK;
}
 8003a20:	2000      	movs	r0, #0
 8003a22:	bd08      	pop	{r3, pc}

08003a24 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8003a24:	b538      	push	{r3, r4, r5, lr}
 8003a26:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8003a28:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8003a2c:	4628      	mov	r0, r5
 8003a2e:	f000 fa64 	bl	8003efa <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8003a32:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 8003a34:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
  pdev->ep0_state = USBD_EP0_SETUP;
 8003a38:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8003a3c:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 8003a40:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  switch (pdev->request.bmRequest & 0x1F) 
 8003a44:	f001 031f 	and.w	r3, r1, #31
 8003a48:	2b01      	cmp	r3, #1
 8003a4a:	d00e      	beq.n	8003a6a <USBD_LL_SetupStage+0x46>
 8003a4c:	d307      	bcc.n	8003a5e <USBD_LL_SetupStage+0x3a>
 8003a4e:	2b02      	cmp	r3, #2
 8003a50:	d010      	beq.n	8003a74 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 8003a52:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8003a56:	4620      	mov	r0, r4
 8003a58:	f003 fa7a 	bl	8006f50 <USBD_LL_StallEP>
    break;
 8003a5c:	e003      	b.n	8003a66 <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 8003a5e:	4629      	mov	r1, r5
 8003a60:	4620      	mov	r0, r4
 8003a62:	f000 f8d5 	bl	8003c10 <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 8003a66:	2000      	movs	r0, #0
 8003a68:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 8003a6a:	4629      	mov	r1, r5
 8003a6c:	4620      	mov	r0, r4
 8003a6e:	f000 f9c9 	bl	8003e04 <USBD_StdItfReq>
    break;
 8003a72:	e7f8      	b.n	8003a66 <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 8003a74:	4629      	mov	r1, r5
 8003a76:	4620      	mov	r0, r4
 8003a78:	f000 f9dc 	bl	8003e34 <USBD_StdEPReq>
    break;
 8003a7c:	e7f3      	b.n	8003a66 <USBD_LL_SetupStage+0x42>

08003a7e <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 8003a7e:	b538      	push	{r3, r4, r5, lr}
 8003a80:	4604      	mov	r4, r0
 8003a82:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8003a84:	bb11      	cbnz	r1, 8003acc <USBD_LL_DataOutStage+0x4e>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8003a86:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8003a8a:	2b03      	cmp	r3, #3
 8003a8c:	d10f      	bne.n	8003aae <USBD_LL_DataOutStage+0x30>
    {
      if(pep->rem_length > pep->maxpacket)
 8003a8e:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 8003a92:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8003a96:	4293      	cmp	r3, r2
 8003a98:	d90b      	bls.n	8003ab2 <USBD_LL_DataOutStage+0x34>
      {
        pep->rem_length -=  pep->maxpacket;
 8003a9a:	1a9b      	subs	r3, r3, r2
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 8003a9c:	429a      	cmp	r2, r3
 8003a9e:	bf28      	it	cs
 8003aa0:	461a      	movcs	r2, r3
        pep->rem_length -=  pep->maxpacket;
 8003aa2:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
        USBD_CtlContinueRx (pdev, 
 8003aa6:	b292      	uxth	r2, r2
 8003aa8:	4629      	mov	r1, r5
 8003aaa:	f000 fa7a 	bl	8003fa2 <USBD_CtlContinueRx>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 8003aae:	2000      	movs	r0, #0
 8003ab0:	bd38      	pop	{r3, r4, r5, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8003ab2:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003ab6:	691b      	ldr	r3, [r3, #16]
 8003ab8:	b123      	cbz	r3, 8003ac4 <USBD_LL_DataOutStage+0x46>
 8003aba:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003abe:	2a03      	cmp	r2, #3
 8003ac0:	d100      	bne.n	8003ac4 <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev); 
 8003ac2:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8003ac4:	4620      	mov	r0, r4
 8003ac6:	f000 fa74 	bl	8003fb2 <USBD_CtlSendStatus>
 8003aca:	e7f0      	b.n	8003aae <USBD_LL_DataOutStage+0x30>
  else if((pdev->pClass->DataOut != NULL)&&
 8003acc:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003ad0:	699b      	ldr	r3, [r3, #24]
 8003ad2:	2b00      	cmp	r3, #0
 8003ad4:	d0eb      	beq.n	8003aae <USBD_LL_DataOutStage+0x30>
 8003ad6:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003ada:	2a03      	cmp	r2, #3
 8003adc:	d1e7      	bne.n	8003aae <USBD_LL_DataOutStage+0x30>
    pdev->pClass->DataOut(pdev, epnum); 
 8003ade:	4798      	blx	r3
 8003ae0:	e7e5      	b.n	8003aae <USBD_LL_DataOutStage+0x30>

08003ae2 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8003ae2:	b570      	push	{r4, r5, r6, lr}
 8003ae4:	4613      	mov	r3, r2
 8003ae6:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8003ae8:	460e      	mov	r6, r1
 8003aea:	2900      	cmp	r1, #0
 8003aec:	d13d      	bne.n	8003b6a <USBD_LL_DataInStage+0x88>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8003aee:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 8003af2:	2a02      	cmp	r2, #2
 8003af4:	d10f      	bne.n	8003b16 <USBD_LL_DataInStage+0x34>
    {
      if(pep->rem_length > pep->maxpacket)
 8003af6:	69c5      	ldr	r5, [r0, #28]
 8003af8:	6a02      	ldr	r2, [r0, #32]
 8003afa:	4295      	cmp	r5, r2
 8003afc:	d914      	bls.n	8003b28 <USBD_LL_DataInStage+0x46>
      {
        pep->rem_length -=  pep->maxpacket;
 8003afe:	1aaa      	subs	r2, r5, r2
 8003b00:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8003b02:	4619      	mov	r1, r3
 8003b04:	b292      	uxth	r2, r2
 8003b06:	f000 fa35 	bl	8003f74 <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8003b0a:	4633      	mov	r3, r6
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
          pdev->ep0_data_len = 0;
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8003b0c:	461a      	mov	r2, r3
 8003b0e:	4619      	mov	r1, r3
 8003b10:	4620      	mov	r0, r4
 8003b12:	f003 fa69 	bl	8006fe8 <USBD_LL_PrepareReceive>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 8003b16:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 8003b1a:	2b01      	cmp	r3, #1
 8003b1c:	d102      	bne.n	8003b24 <USBD_LL_DataInStage+0x42>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 8003b1e:	2300      	movs	r3, #0
 8003b20:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 8003b24:	2000      	movs	r0, #0
 8003b26:	bd70      	pop	{r4, r5, r6, pc}
        if((pep->total_length % pep->maxpacket == 0) &&
 8003b28:	6983      	ldr	r3, [r0, #24]
 8003b2a:	fbb3 f5f2 	udiv	r5, r3, r2
 8003b2e:	fb02 3515 	mls	r5, r2, r5, r3
 8003b32:	b965      	cbnz	r5, 8003b4e <USBD_LL_DataInStage+0x6c>
 8003b34:	429a      	cmp	r2, r3
 8003b36:	d80a      	bhi.n	8003b4e <USBD_LL_DataInStage+0x6c>
           (pep->total_length >= pep->maxpacket) &&
 8003b38:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 8003b3c:	4293      	cmp	r3, r2
 8003b3e:	d206      	bcs.n	8003b4e <USBD_LL_DataInStage+0x6c>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 8003b40:	462a      	mov	r2, r5
 8003b42:	f000 fa17 	bl	8003f74 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8003b46:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
        USBD_LL_PrepareReceive (pdev,
 8003b4a:	462b      	mov	r3, r5
 8003b4c:	e7de      	b.n	8003b0c <USBD_LL_DataInStage+0x2a>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8003b4e:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003b52:	68db      	ldr	r3, [r3, #12]
 8003b54:	b12b      	cbz	r3, 8003b62 <USBD_LL_DataInStage+0x80>
 8003b56:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8003b5a:	2a03      	cmp	r2, #3
 8003b5c:	d101      	bne.n	8003b62 <USBD_LL_DataInStage+0x80>
            pdev->pClass->EP0_TxSent(pdev); 
 8003b5e:	4620      	mov	r0, r4
 8003b60:	4798      	blx	r3
          USBD_CtlReceiveStatus(pdev);
 8003b62:	4620      	mov	r0, r4
 8003b64:	f000 fa30 	bl	8003fc8 <USBD_CtlReceiveStatus>
 8003b68:	e7d5      	b.n	8003b16 <USBD_LL_DataInStage+0x34>
  else if((pdev->pClass->DataIn != NULL)&& 
 8003b6a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003b6e:	695b      	ldr	r3, [r3, #20]
 8003b70:	2b00      	cmp	r3, #0
 8003b72:	d0d7      	beq.n	8003b24 <USBD_LL_DataInStage+0x42>
 8003b74:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003b78:	2a03      	cmp	r2, #3
 8003b7a:	d1d3      	bne.n	8003b24 <USBD_LL_DataInStage+0x42>
    pdev->pClass->DataIn(pdev, epnum); 
 8003b7c:	4798      	blx	r3
 8003b7e:	e7d1      	b.n	8003b24 <USBD_LL_DataInStage+0x42>

08003b80 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8003b80:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 8003b82:	2200      	movs	r2, #0
{
 8003b84:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 8003b86:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8003b88:	2540      	movs	r5, #64	; 0x40
  USBD_LL_OpenEP(pdev,
 8003b8a:	2340      	movs	r3, #64	; 0x40
 8003b8c:	f003 f9c2 	bl	8006f14 <USBD_LL_OpenEP>
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 8003b90:	462b      	mov	r3, r5
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8003b92:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  USBD_LL_OpenEP(pdev,
 8003b96:	2200      	movs	r2, #0
 8003b98:	2180      	movs	r1, #128	; 0x80
 8003b9a:	4620      	mov	r0, r4
 8003b9c:	f003 f9ba 	bl	8006f14 <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8003ba0:	2301      	movs	r3, #1
 8003ba2:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8003ba6:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8003baa:	6225      	str	r5, [r4, #32]
  if (pdev->pClassData) 
 8003bac:	b12b      	cbz	r3, 8003bba <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8003bae:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003bb2:	7921      	ldrb	r1, [r4, #4]
 8003bb4:	685b      	ldr	r3, [r3, #4]
 8003bb6:	4620      	mov	r0, r4
 8003bb8:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8003bba:	2000      	movs	r0, #0
 8003bbc:	bd38      	pop	{r3, r4, r5, pc}

08003bbe <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8003bbe:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8003bc0:	2000      	movs	r0, #0
 8003bc2:	4770      	bx	lr

08003bc4 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8003bc4:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003bc8:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8003bcc:	2304      	movs	r3, #4
 8003bce:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8003bd2:	2000      	movs	r0, #0
 8003bd4:	4770      	bx	lr

08003bd6 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8003bd6:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8003bda:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8003bde:	2000      	movs	r0, #0
 8003be0:	4770      	bx	lr

08003be2 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8003be2:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8003be4:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003be8:	2a03      	cmp	r2, #3
 8003bea:	d104      	bne.n	8003bf6 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8003bec:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003bf0:	69db      	ldr	r3, [r3, #28]
 8003bf2:	b103      	cbz	r3, 8003bf6 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8003bf4:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8003bf6:	2000      	movs	r0, #0
 8003bf8:	bd08      	pop	{r3, pc}

08003bfa <USBD_CtlError.constprop.0>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8003bfa:	b510      	push	{r4, lr}
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 8003bfc:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8003bfe:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8003c00:	f003 f9a6 	bl	8006f50 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8003c04:	4620      	mov	r0, r4
 8003c06:	2100      	movs	r1, #0
}
 8003c08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0);
 8003c0c:	f003 b9a0 	b.w	8006f50 <USBD_LL_StallEP>

08003c10 <USBD_StdDevReq>:
{
 8003c10:	b537      	push	{r0, r1, r2, r4, r5, lr}
  switch (req->bRequest) 
 8003c12:	784b      	ldrb	r3, [r1, #1]
{
 8003c14:	4604      	mov	r4, r0
 8003c16:	460d      	mov	r5, r1
  switch (req->bRequest) 
 8003c18:	2b09      	cmp	r3, #9
 8003c1a:	d879      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
 8003c1c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003c20:	00e500c9 	.word	0x00e500c9
 8003c24:	00d90078 	.word	0x00d90078
 8003c28:	006d0078 	.word	0x006d0078
 8003c2c:	0078000a 	.word	0x0078000a
 8003c30:	008d00b9 	.word	0x008d00b9
  switch (req->wValue >> 8)
 8003c34:	884b      	ldrh	r3, [r1, #2]
 8003c36:	0a1a      	lsrs	r2, r3, #8
 8003c38:	3a01      	subs	r2, #1
 8003c3a:	2a06      	cmp	r2, #6
 8003c3c:	d868      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
 8003c3e:	e8df f002 	tbb	[pc, r2]
 8003c42:	1c04      	.short	0x1c04
 8003c44:	49676729 	.word	0x49676729
 8003c48:	52          	.byte	0x52
 8003c49:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8003c4a:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003c4e:	681b      	ldr	r3, [r3, #0]
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8003c50:	7c20      	ldrb	r0, [r4, #16]
 8003c52:	f10d 0106 	add.w	r1, sp, #6
 8003c56:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 8003c58:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8003c5c:	2a00      	cmp	r2, #0
 8003c5e:	d067      	beq.n	8003d30 <USBD_StdDevReq+0x120>
 8003c60:	88eb      	ldrh	r3, [r5, #6]
 8003c62:	2b00      	cmp	r3, #0
 8003c64:	d064      	beq.n	8003d30 <USBD_StdDevReq+0x120>
    len = MIN(len , req->wLength);
 8003c66:	429a      	cmp	r2, r3
 8003c68:	bf28      	it	cs
 8003c6a:	461a      	movcs	r2, r3
 8003c6c:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 8003c70:	4601      	mov	r1, r0
    USBD_CtlSendData (pdev, 
 8003c72:	4620      	mov	r0, r4
 8003c74:	f000 f971 	bl	8003f5a <USBD_CtlSendData>
 8003c78:	e05a      	b.n	8003d30 <USBD_StdDevReq+0x120>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8003c7a:	7c02      	ldrb	r2, [r0, #16]
 8003c7c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003c80:	b932      	cbnz	r2, 8003c90 <USBD_StdDevReq+0x80>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8003c82:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8003c84:	f10d 0006 	add.w	r0, sp, #6
 8003c88:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8003c8a:	2302      	movs	r3, #2
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8003c8c:	7043      	strb	r3, [r0, #1]
 8003c8e:	e7e3      	b.n	8003c58 <USBD_StdDevReq+0x48>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8003c90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003c92:	e7f7      	b.n	8003c84 <USBD_StdDevReq+0x74>
    switch ((uint8_t)(req->wValue))
 8003c94:	b2db      	uxtb	r3, r3
 8003c96:	2b05      	cmp	r3, #5
 8003c98:	d83a      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
 8003c9a:	e8df f003 	tbb	[pc, r3]
 8003c9e:	0703      	.short	0x0703
 8003ca0:	17130f0b 	.word	0x17130f0b
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8003ca4:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003ca8:	685b      	ldr	r3, [r3, #4]
 8003caa:	e7d1      	b.n	8003c50 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8003cac:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003cb0:	689b      	ldr	r3, [r3, #8]
 8003cb2:	e7cd      	b.n	8003c50 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8003cb4:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003cb8:	68db      	ldr	r3, [r3, #12]
 8003cba:	e7c9      	b.n	8003c50 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8003cbc:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003cc0:	691b      	ldr	r3, [r3, #16]
 8003cc2:	e7c5      	b.n	8003c50 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8003cc4:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003cc8:	695b      	ldr	r3, [r3, #20]
 8003cca:	e7c1      	b.n	8003c50 <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8003ccc:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8003cd0:	699b      	ldr	r3, [r3, #24]
 8003cd2:	e7bd      	b.n	8003c50 <USBD_StdDevReq+0x40>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003cd4:	7c03      	ldrb	r3, [r0, #16]
 8003cd6:	b9db      	cbnz	r3, 8003d10 <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8003cd8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003cdc:	f10d 0006 	add.w	r0, sp, #6
 8003ce0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8003ce2:	4798      	blx	r3
 8003ce4:	e7b8      	b.n	8003c58 <USBD_StdDevReq+0x48>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8003ce6:	7c03      	ldrb	r3, [r0, #16]
 8003ce8:	b993      	cbnz	r3, 8003d10 <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8003cea:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003cee:	f10d 0006 	add.w	r0, sp, #6
 8003cf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003cf4:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8003cf6:	2307      	movs	r3, #7
 8003cf8:	e7c8      	b.n	8003c8c <USBD_StdDevReq+0x7c>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8003cfa:	888b      	ldrh	r3, [r1, #4]
 8003cfc:	b943      	cbnz	r3, 8003d10 <USBD_StdDevReq+0x100>
 8003cfe:	88cb      	ldrh	r3, [r1, #6]
 8003d00:	b933      	cbnz	r3, 8003d10 <USBD_StdDevReq+0x100>
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003d02:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003d06:	788d      	ldrb	r5, [r1, #2]
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003d08:	2b03      	cmp	r3, #3
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8003d0a:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8003d0e:	d103      	bne.n	8003d18 <USBD_StdDevReq+0x108>
    USBD_CtlError(pdev , req);
 8003d10:	4620      	mov	r0, r4
 8003d12:	f7ff ff72 	bl	8003bfa <USBD_CtlError.constprop.0>
    break;
 8003d16:	e00b      	b.n	8003d30 <USBD_StdDevReq+0x120>
      pdev->dev_address = dev_addr;
 8003d18:	f880 51fe 	strb.w	r5, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8003d1c:	4629      	mov	r1, r5
 8003d1e:	f003 f947 	bl	8006fb0 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8003d22:	4620      	mov	r0, r4
 8003d24:	f000 f945 	bl	8003fb2 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 8003d28:	b12d      	cbz	r5, 8003d36 <USBD_StdDevReq+0x126>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8003d2a:	2302      	movs	r3, #2
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8003d2c:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
}
 8003d30:	2000      	movs	r0, #0
 8003d32:	b003      	add	sp, #12
 8003d34:	bd30      	pop	{r4, r5, pc}
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8003d36:	2301      	movs	r3, #1
 8003d38:	e7f8      	b.n	8003d2c <USBD_StdDevReq+0x11c>
  cfgidx = (uint8_t)(req->wValue);                 
 8003d3a:	7889      	ldrb	r1, [r1, #2]
 8003d3c:	4d30      	ldr	r5, [pc, #192]	; (8003e00 <USBD_StdDevReq+0x1f0>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003d3e:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);                 
 8003d40:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8003d42:	d8e5      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
    switch (pdev->dev_state) 
 8003d44:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003d48:	2b02      	cmp	r3, #2
 8003d4a:	d00c      	beq.n	8003d66 <USBD_StdDevReq+0x156>
 8003d4c:	2b03      	cmp	r3, #3
 8003d4e:	d1df      	bne.n	8003d10 <USBD_StdDevReq+0x100>
      if (cfgidx == 0) 
 8003d50:	b9b1      	cbnz	r1, 8003d80 <USBD_StdDevReq+0x170>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8003d52:	2302      	movs	r3, #2
 8003d54:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8003d58:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8003d5a:	f7ff fe5c 	bl	8003a16 <USBD_ClrClassConfig>
      USBD_CtlSendStatus(pdev);
 8003d5e:	4620      	mov	r0, r4
 8003d60:	f000 f927 	bl	8003fb2 <USBD_CtlSendStatus>
 8003d64:	e7e4      	b.n	8003d30 <USBD_StdDevReq+0x120>
      if (cfgidx) 
 8003d66:	2900      	cmp	r1, #0
 8003d68:	d0f9      	beq.n	8003d5e <USBD_StdDevReq+0x14e>
        pdev->dev_config = cfgidx;
 8003d6a:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8003d6c:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 8003d6e:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8003d70:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8003d74:	4620      	mov	r0, r4
 8003d76:	f7ff fe43 	bl	8003a00 <USBD_SetClassConfig>
 8003d7a:	2802      	cmp	r0, #2
 8003d7c:	d1ef      	bne.n	8003d5e <USBD_StdDevReq+0x14e>
 8003d7e:	e7c7      	b.n	8003d10 <USBD_StdDevReq+0x100>
      else  if (cfgidx != pdev->dev_config) 
 8003d80:	6841      	ldr	r1, [r0, #4]
 8003d82:	2901      	cmp	r1, #1
 8003d84:	d0eb      	beq.n	8003d5e <USBD_StdDevReq+0x14e>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8003d86:	b2c9      	uxtb	r1, r1
 8003d88:	f7ff fe45 	bl	8003a16 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8003d8c:	7829      	ldrb	r1, [r5, #0]
 8003d8e:	6061      	str	r1, [r4, #4]
 8003d90:	e7f0      	b.n	8003d74 <USBD_StdDevReq+0x164>
  if (req->wLength != 1) 
 8003d92:	88ca      	ldrh	r2, [r1, #6]
 8003d94:	2a01      	cmp	r2, #1
 8003d96:	d1bb      	bne.n	8003d10 <USBD_StdDevReq+0x100>
    switch (pdev->dev_state )  
 8003d98:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003d9c:	2b02      	cmp	r3, #2
 8003d9e:	d003      	beq.n	8003da8 <USBD_StdDevReq+0x198>
 8003da0:	2b03      	cmp	r3, #3
 8003da2:	d1b5      	bne.n	8003d10 <USBD_StdDevReq+0x100>
      USBD_CtlSendData (pdev, 
 8003da4:	1d01      	adds	r1, r0, #4
 8003da6:	e764      	b.n	8003c72 <USBD_StdDevReq+0x62>
      pdev->dev_default_config = 0;
 8003da8:	4601      	mov	r1, r0
 8003daa:	2300      	movs	r3, #0
 8003dac:	f841 3f08 	str.w	r3, [r1, #8]!
 8003db0:	e75f      	b.n	8003c72 <USBD_StdDevReq+0x62>
  switch (pdev->dev_state) 
 8003db2:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003db6:	3b02      	subs	r3, #2
 8003db8:	2b01      	cmp	r3, #1
 8003dba:	d8a9      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 8003dbc:	2301      	movs	r3, #1
 8003dbe:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 8003dc0:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8003dc4:	b10b      	cbz	r3, 8003dca <USBD_StdDevReq+0x1ba>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8003dc6:	2303      	movs	r3, #3
 8003dc8:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 8003dca:	2202      	movs	r2, #2
 8003dcc:	f104 010c 	add.w	r1, r4, #12
 8003dd0:	e74f      	b.n	8003c72 <USBD_StdDevReq+0x62>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8003dd2:	884b      	ldrh	r3, [r1, #2]
 8003dd4:	2b01      	cmp	r3, #1
 8003dd6:	d1ab      	bne.n	8003d30 <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8003dd8:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8003ddc:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003de0:	4629      	mov	r1, r5
 8003de2:	689b      	ldr	r3, [r3, #8]
 8003de4:	4620      	mov	r0, r4
 8003de6:	4798      	blx	r3
 8003de8:	e7b9      	b.n	8003d5e <USBD_StdDevReq+0x14e>
  switch (pdev->dev_state)
 8003dea:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003dee:	3b02      	subs	r3, #2
 8003df0:	2b01      	cmp	r3, #1
 8003df2:	d88d      	bhi.n	8003d10 <USBD_StdDevReq+0x100>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8003df4:	884b      	ldrh	r3, [r1, #2]
 8003df6:	2b01      	cmp	r3, #1
 8003df8:	d19a      	bne.n	8003d30 <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8003dfa:	2300      	movs	r3, #0
 8003dfc:	e7ec      	b.n	8003dd8 <USBD_StdDevReq+0x1c8>
 8003dfe:	bf00      	nop
 8003e00:	200001f1 	.word	0x200001f1

08003e04 <USBD_StdItfReq>:
{
 8003e04:	b538      	push	{r3, r4, r5, lr}
  switch (pdev->dev_state) 
 8003e06:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8003e0a:	2b03      	cmp	r3, #3
{
 8003e0c:	4604      	mov	r4, r0
 8003e0e:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 8003e10:	d10d      	bne.n	8003e2e <USBD_StdItfReq+0x2a>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 8003e12:	790b      	ldrb	r3, [r1, #4]
 8003e14:	2b01      	cmp	r3, #1
 8003e16:	d80a      	bhi.n	8003e2e <USBD_StdItfReq+0x2a>
      pdev->pClass->Setup (pdev, req); 
 8003e18:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003e1c:	689b      	ldr	r3, [r3, #8]
 8003e1e:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 8003e20:	88eb      	ldrh	r3, [r5, #6]
 8003e22:	b913      	cbnz	r3, 8003e2a <USBD_StdItfReq+0x26>
         USBD_CtlSendStatus(pdev);
 8003e24:	4620      	mov	r0, r4
 8003e26:	f000 f8c4 	bl	8003fb2 <USBD_CtlSendStatus>
}
 8003e2a:	2000      	movs	r0, #0
 8003e2c:	bd38      	pop	{r3, r4, r5, pc}
     USBD_CtlError(pdev , req);
 8003e2e:	f7ff fee4 	bl	8003bfa <USBD_CtlError.constprop.0>
    break;
 8003e32:	e7fa      	b.n	8003e2a <USBD_StdItfReq+0x26>

08003e34 <USBD_StdEPReq>:
{
 8003e34:	b570      	push	{r4, r5, r6, lr}
  if ((req->bmRequest & 0x60) == 0x20)
 8003e36:	780a      	ldrb	r2, [r1, #0]
  ep_addr  = LOBYTE(req->wIndex);   
 8003e38:	888e      	ldrh	r6, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 8003e3a:	f002 0260 	and.w	r2, r2, #96	; 0x60
 8003e3e:	2a20      	cmp	r2, #32
{
 8003e40:	4604      	mov	r4, r0
 8003e42:	460d      	mov	r5, r1
  ep_addr  = LOBYTE(req->wIndex);   
 8003e44:	b2f3      	uxtb	r3, r6
  if ((req->bmRequest & 0x60) == 0x20)
 8003e46:	d105      	bne.n	8003e54 <USBD_StdEPReq+0x20>
    pdev->pClass->Setup (pdev, req);
 8003e48:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8003e4c:	689b      	ldr	r3, [r3, #8]
 8003e4e:	4798      	blx	r3
}
 8003e50:	2000      	movs	r0, #0
 8003e52:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bRequest) 
 8003e54:	784a      	ldrb	r2, [r1, #1]
 8003e56:	2a01      	cmp	r2, #1
 8003e58:	d01c      	beq.n	8003e94 <USBD_StdEPReq+0x60>
 8003e5a:	d32a      	bcc.n	8003eb2 <USBD_StdEPReq+0x7e>
 8003e5c:	2a03      	cmp	r2, #3
 8003e5e:	d1f7      	bne.n	8003e50 <USBD_StdEPReq+0x1c>
    switch (pdev->dev_state) 
 8003e60:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003e64:	2a02      	cmp	r2, #2
 8003e66:	d040      	beq.n	8003eea <USBD_StdEPReq+0xb6>
 8003e68:	2a03      	cmp	r2, #3
 8003e6a:	d002      	beq.n	8003e72 <USBD_StdEPReq+0x3e>
      USBD_CtlError(pdev , req);
 8003e6c:	f7ff fec5 	bl	8003bfa <USBD_CtlError.constprop.0>
      break;
 8003e70:	e7ee      	b.n	8003e50 <USBD_StdEPReq+0x1c>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003e72:	884a      	ldrh	r2, [r1, #2]
 8003e74:	b922      	cbnz	r2, 8003e80 <USBD_StdEPReq+0x4c>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8003e76:	065e      	lsls	r6, r3, #25
 8003e78:	d002      	beq.n	8003e80 <USBD_StdEPReq+0x4c>
          USBD_LL_StallEP(pdev , ep_addr);
 8003e7a:	4619      	mov	r1, r3
 8003e7c:	f003 f868 	bl	8006f50 <USBD_LL_StallEP>
          pdev->pClass->Setup (pdev, req);
 8003e80:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8003e84:	4629      	mov	r1, r5
 8003e86:	689b      	ldr	r3, [r3, #8]
 8003e88:	4620      	mov	r0, r4
 8003e8a:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8003e8c:	4620      	mov	r0, r4
 8003e8e:	f000 f890 	bl	8003fb2 <USBD_CtlSendStatus>
 8003e92:	e7dd      	b.n	8003e50 <USBD_StdEPReq+0x1c>
    switch (pdev->dev_state) 
 8003e94:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003e98:	2a02      	cmp	r2, #2
 8003e9a:	d026      	beq.n	8003eea <USBD_StdEPReq+0xb6>
 8003e9c:	2a03      	cmp	r2, #3
 8003e9e:	d1e5      	bne.n	8003e6c <USBD_StdEPReq+0x38>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8003ea0:	884a      	ldrh	r2, [r1, #2]
 8003ea2:	2a00      	cmp	r2, #0
 8003ea4:	d1d4      	bne.n	8003e50 <USBD_StdEPReq+0x1c>
        if ((ep_addr & 0x7F) != 0x00) 
 8003ea6:	0659      	lsls	r1, r3, #25
 8003ea8:	d0f0      	beq.n	8003e8c <USBD_StdEPReq+0x58>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8003eaa:	4619      	mov	r1, r3
 8003eac:	f003 f85e 	bl	8006f6c <USBD_LL_ClearStallEP>
 8003eb0:	e7e6      	b.n	8003e80 <USBD_StdEPReq+0x4c>
    switch (pdev->dev_state) 
 8003eb2:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8003eb6:	2a02      	cmp	r2, #2
 8003eb8:	d017      	beq.n	8003eea <USBD_StdEPReq+0xb6>
 8003eba:	2a03      	cmp	r2, #3
 8003ebc:	d1d6      	bne.n	8003e6c <USBD_StdEPReq+0x38>
 8003ebe:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003ec2:	f016 0f80 	tst.w	r6, #128	; 0x80
 8003ec6:	eb00 1505 	add.w	r5, r0, r5, lsl #4
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8003eca:	4619      	mov	r1, r3
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8003ecc:	bf14      	ite	ne
 8003ece:	3514      	addne	r5, #20
 8003ed0:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8003ed4:	f003 f858 	bl	8006f88 <USBD_LL_IsStallEP>
 8003ed8:	b168      	cbz	r0, 8003ef6 <USBD_StdEPReq+0xc2>
        pep->status = 0x0001;     
 8003eda:	2301      	movs	r3, #1
 8003edc:	602b      	str	r3, [r5, #0]
      USBD_CtlSendData (pdev,
 8003ede:	2202      	movs	r2, #2
 8003ee0:	4629      	mov	r1, r5
 8003ee2:	4620      	mov	r0, r4
 8003ee4:	f000 f839 	bl	8003f5a <USBD_CtlSendData>
      break;
 8003ee8:	e7b2      	b.n	8003e50 <USBD_StdEPReq+0x1c>
      if ((ep_addr & 0x7F) != 0x00) 
 8003eea:	065a      	lsls	r2, r3, #25
 8003eec:	d0b0      	beq.n	8003e50 <USBD_StdEPReq+0x1c>
        USBD_LL_StallEP(pdev , ep_addr);
 8003eee:	4619      	mov	r1, r3
 8003ef0:	f003 f82e 	bl	8006f50 <USBD_LL_StallEP>
 8003ef4:	e7ac      	b.n	8003e50 <USBD_StdEPReq+0x1c>
        pep->status = 0x0000;  
 8003ef6:	6028      	str	r0, [r5, #0]
 8003ef8:	e7f1      	b.n	8003ede <USBD_StdEPReq+0xaa>

08003efa <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 8003efa:	780b      	ldrb	r3, [r1, #0]
 8003efc:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8003efe:	784b      	ldrb	r3, [r1, #1]
 8003f00:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8003f02:	78ca      	ldrb	r2, [r1, #3]
 8003f04:	788b      	ldrb	r3, [r1, #2]
 8003f06:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003f0a:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8003f0c:	794a      	ldrb	r2, [r1, #5]
 8003f0e:	790b      	ldrb	r3, [r1, #4]
 8003f10:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003f14:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8003f16:	79ca      	ldrb	r2, [r1, #7]
 8003f18:	798b      	ldrb	r3, [r1, #6]
 8003f1a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8003f1e:	80c3      	strh	r3, [r0, #6]
 8003f20:	4770      	bx	lr

08003f22 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8003f22:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8003f24:	b188      	cbz	r0, 8003f4a <USBD_GetString+0x28>
 8003f26:	4605      	mov	r5, r0
 8003f28:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 8003f2a:	f815 4b01 	ldrb.w	r4, [r5], #1
 8003f2e:	b2db      	uxtb	r3, r3
 8003f30:	2c00      	cmp	r4, #0
 8003f32:	d1f9      	bne.n	8003f28 <USBD_GetString+0x6>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8003f34:	005b      	lsls	r3, r3, #1
 8003f36:	3302      	adds	r3, #2
 8003f38:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 8003f3a:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8003f3c:	2303      	movs	r3, #3
 8003f3e:	704b      	strb	r3, [r1, #1]
 8003f40:	3801      	subs	r0, #1
 8003f42:	2302      	movs	r3, #2
    while (*desc != '\0') 
 8003f44:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8003f48:	b905      	cbnz	r5, 8003f4c <USBD_GetString+0x2a>
 8003f4a:	bd30      	pop	{r4, r5, pc}
      unicode[idx++] = *desc++;
 8003f4c:	1c5a      	adds	r2, r3, #1
 8003f4e:	b2d2      	uxtb	r2, r2
 8003f50:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 8003f52:	3302      	adds	r3, #2
 8003f54:	b2db      	uxtb	r3, r3
 8003f56:	548c      	strb	r4, [r1, r2]
 8003f58:	e7f4      	b.n	8003f44 <USBD_GetString+0x22>

08003f5a <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8003f5a:	b510      	push	{r4, lr}
 8003f5c:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8003f5e:	2202      	movs	r2, #2
 8003f60:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8003f64:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003f66:	460a      	mov	r2, r1
  pdev->ep_in[0].rem_length   = len;
 8003f68:	61c3      	str	r3, [r0, #28]
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8003f6a:	2100      	movs	r1, #0
 8003f6c:	f003 f82e 	bl	8006fcc <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003f70:	2000      	movs	r0, #0
 8003f72:	bd10      	pop	{r4, pc}

08003f74 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8003f74:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8003f76:	4613      	mov	r3, r2
 8003f78:	460a      	mov	r2, r1
 8003f7a:	2100      	movs	r1, #0
 8003f7c:	f003 f826 	bl	8006fcc <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003f80:	2000      	movs	r0, #0
 8003f82:	bd08      	pop	{r3, pc}

08003f84 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8003f84:	b510      	push	{r4, lr}
 8003f86:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8003f88:	2203      	movs	r2, #3
 8003f8a:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 8003f8e:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8003f92:	460a      	mov	r2, r1
  pdev->ep_out[0].rem_length   = len;
 8003f94:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  USBD_LL_PrepareReceive (pdev,
 8003f98:	2100      	movs	r1, #0
 8003f9a:	f003 f825 	bl	8006fe8 <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 8003f9e:	2000      	movs	r0, #0
 8003fa0:	bd10      	pop	{r4, pc}

08003fa2 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8003fa2:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8003fa4:	4613      	mov	r3, r2
 8003fa6:	460a      	mov	r2, r1
 8003fa8:	2100      	movs	r1, #0
 8003faa:	f003 f81d 	bl	8006fe8 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8003fae:	2000      	movs	r0, #0
 8003fb0:	bd08      	pop	{r3, pc}

08003fb2 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8003fb2:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8003fb4:	2304      	movs	r3, #4
 8003fb6:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8003fba:	2300      	movs	r3, #0
 8003fbc:	461a      	mov	r2, r3
 8003fbe:	4619      	mov	r1, r3
 8003fc0:	f003 f804 	bl	8006fcc <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8003fc4:	2000      	movs	r0, #0
 8003fc6:	bd08      	pop	{r3, pc}

08003fc8 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8003fc8:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8003fca:	2305      	movs	r3, #5
 8003fcc:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8003fd0:	2300      	movs	r3, #0
 8003fd2:	461a      	mov	r2, r3
 8003fd4:	4619      	mov	r1, r3
 8003fd6:	f003 f807 	bl	8006fe8 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8003fda:	2000      	movs	r0, #0
 8003fdc:	bd08      	pop	{r3, pc}

08003fde <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8003fde:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8003fe0:	f001 f96c 	bl	80052bc <vTaskStartScheduler>
  
  return osOK;
}
 8003fe4:	2000      	movs	r0, #0
 8003fe6:	bd08      	pop	{r3, pc}

08003fe8 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 8003fe8:	b570      	push	{r4, r5, r6, lr}
 8003fea:	4605      	mov	r5, r0
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8003fec:	6946      	ldr	r6, [r0, #20]
 8003fee:	692a      	ldr	r2, [r5, #16]
 8003ff0:	6840      	ldr	r0, [r0, #4]
 8003ff2:	f9b5 4008 	ldrsh.w	r4, [r5, #8]
{
 8003ff6:	460b      	mov	r3, r1
 8003ff8:	b086      	sub	sp, #24
 8003ffa:	6829      	ldr	r1, [r5, #0]
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
 8003ffc:	b176      	cbz	r6, 800401c <osThreadCreate+0x34>
 8003ffe:	69ad      	ldr	r5, [r5, #24]
 8004000:	b165      	cbz	r5, 800401c <osThreadCreate+0x34>
  if (priority != osPriorityError) {
 8004002:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 8004004:	bf14      	ite	ne
 8004006:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8004008:	2400      	moveq	r4, #0
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800400a:	9502      	str	r5, [sp, #8]
 800400c:	e88d 0050 	stmia.w	sp, {r4, r6}
 8004010:	f001 f905 	bl	800521e <xTaskCreateStatic>
 8004014:	9005      	str	r0, [sp, #20]
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 8004016:	9805      	ldr	r0, [sp, #20]
}
 8004018:	b006      	add	sp, #24
 800401a:	bd70      	pop	{r4, r5, r6, pc}
  if (priority != osPriorityError) {
 800401c:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 800401e:	bf14      	ite	ne
 8004020:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8004022:	2400      	moveq	r4, #0
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8004024:	ad05      	add	r5, sp, #20
 8004026:	b292      	uxth	r2, r2
 8004028:	e88d 0030 	stmia.w	sp, {r4, r5}
 800402c:	f001 f919 	bl	8005262 <xTaskCreate>
 8004030:	2801      	cmp	r0, #1
 8004032:	d0f0      	beq.n	8004016 <osThreadCreate+0x2e>
      return NULL;
 8004034:	2000      	movs	r0, #0
 8004036:	e7ef      	b.n	8004018 <osThreadCreate+0x30>

08004038 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 8004038:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800403a:	2800      	cmp	r0, #0
 800403c:	bf08      	it	eq
 800403e:	2001      	moveq	r0, #1
 8004040:	f001 fa98 	bl	8005574 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 8004044:	2000      	movs	r0, #0
 8004046:	bd08      	pop	{r3, pc}

08004048 <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 8004048:	b513      	push	{r0, r1, r4, lr}
 800404a:	4613      	mov	r3, r2
 800404c:	e890 0014 	ldmia.w	r0, {r2, r4}
#if (configUSE_TIMERS == 1)

#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) 
  if(timer_def->controlblock != NULL) {
 8004050:	b154      	cbz	r4, 8004068 <osTimerCreate+0x20>
    return xTimerCreateStatic((const char *)"",
 8004052:	1e48      	subs	r0, r1, #1
 8004054:	e88d 0014 	stmia.w	sp, {r2, r4}
 8004058:	4242      	negs	r2, r0
 800405a:	4142      	adcs	r2, r0
 800405c:	2101      	movs	r1, #1
 800405e:	4807      	ldr	r0, [pc, #28]	; (800407c <osTimerCreate+0x34>)
 8004060:	f001 fd45 	bl	8005aee <xTimerCreateStatic>
#endif

#else 
	return NULL;
#endif
}
 8004064:	b002      	add	sp, #8
 8004066:	bd10      	pop	{r4, pc}
    return xTimerCreate((const char *)"",
 8004068:	3901      	subs	r1, #1
 800406a:	9200      	str	r2, [sp, #0]
 800406c:	424a      	negs	r2, r1
 800406e:	414a      	adcs	r2, r1
 8004070:	4802      	ldr	r0, [pc, #8]	; (800407c <osTimerCreate+0x34>)
 8004072:	2101      	movs	r1, #1
 8004074:	f001 fd14 	bl	8005aa0 <xTimerCreate>
 8004078:	e7f4      	b.n	8004064 <osTimerCreate+0x1c>
 800407a:	bf00      	nop
 800407c:	08007b21 	.word	0x08007b21

08004080 <osTimerStart>:
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
{
 8004080:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 8004082:	2400      	movs	r4, #0
 8004084:	9403      	str	r4, [sp, #12]
  TickType_t ticks = millisec / portTICK_PERIOD_MS;

  if (ticks == 0)
    ticks = 1;
 8004086:	42a1      	cmp	r1, r4
 8004088:	bf14      	ite	ne
 800408a:	460a      	movne	r2, r1
 800408c:	2201      	moveq	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800408e:	f3ef 8305 	mrs	r3, IPSR
    
  if (inHandlerMode()) 
 8004092:	b1a3      	cbz	r3, 80040be <osTimerStart+0x3e>
  {
    if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
 8004094:	9400      	str	r4, [sp, #0]
 8004096:	ab03      	add	r3, sp, #12
 8004098:	2109      	movs	r1, #9
 800409a:	f001 fd65 	bl	8005b68 <xTimerGenericCommand>
 800409e:	2801      	cmp	r0, #1
 80040a0:	d113      	bne.n	80040ca <osTimerStart+0x4a>
    {
      result = osErrorOS;
    }
    else
    {
      portEND_SWITCHING_ISR(taskWoken);     
 80040a2:	9b03      	ldr	r3, [sp, #12]
 80040a4:	b913      	cbnz	r3, 80040ac <osTimerStart+0x2c>
  osStatus result = osOK;
 80040a6:	2000      	movs	r0, #0

#else 
  result = osErrorOS;
#endif
  return result;
}
 80040a8:	b004      	add	sp, #16
 80040aa:	bd10      	pop	{r4, pc}
      portEND_SWITCHING_ISR(taskWoken);     
 80040ac:	4b08      	ldr	r3, [pc, #32]	; (80040d0 <osTimerStart+0x50>)
 80040ae:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80040b2:	601a      	str	r2, [r3, #0]
 80040b4:	f3bf 8f4f 	dsb	sy
 80040b8:	f3bf 8f6f 	isb	sy
 80040bc:	e7f3      	b.n	80040a6 <osTimerStart+0x26>
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
 80040be:	9300      	str	r3, [sp, #0]
 80040c0:	2104      	movs	r1, #4
 80040c2:	f001 fd51 	bl	8005b68 <xTimerGenericCommand>
 80040c6:	2801      	cmp	r0, #1
 80040c8:	d0ed      	beq.n	80040a6 <osTimerStart+0x26>
      result = osErrorOS;
 80040ca:	20ff      	movs	r0, #255	; 0xff
  return result;
 80040cc:	e7ec      	b.n	80040a8 <osTimerStart+0x28>
 80040ce:	bf00      	nop
 80040d0:	e000ed04 	.word	0xe000ed04

080040d4 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 80040d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  osSemaphoreId sema;
  
  if (semaphore_def->controlblock != NULL){
 80040d6:	6845      	ldr	r5, [r0, #4]
{ 
 80040d8:	460c      	mov	r4, r1
  if (semaphore_def->controlblock != NULL){
 80040da:	b1a5      	cbz	r5, 8004106 <osSemaphoreCreate+0x32>
    if (count == 1) {
 80040dc:	2901      	cmp	r1, #1
 80040de:	d10b      	bne.n	80040f8 <osSemaphoreCreate+0x24>
      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
 80040e0:	2303      	movs	r3, #3
 80040e2:	2200      	movs	r2, #0
 80040e4:	9300      	str	r3, [sp, #0]
 80040e6:	4620      	mov	r0, r4
 80040e8:	462b      	mov	r3, r5
 80040ea:	4611      	mov	r1, r2
 80040ec:	f000 fbfa 	bl	80048e4 <xQueueGenericCreateStatic>
 80040f0:	4604      	mov	r4, r0
#else
    return NULL;
#endif
  }
#endif
}
 80040f2:	4620      	mov	r0, r4
 80040f4:	b003      	add	sp, #12
 80040f6:	bd30      	pop	{r4, r5, pc}
      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
 80040f8:	462a      	mov	r2, r5
 80040fa:	4608      	mov	r0, r1
}
 80040fc:	b003      	add	sp, #12
 80040fe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
 8004102:	f000 bc5c 	b.w	80049be <xQueueCreateCountingSemaphoreStatic>
    if (count == 1) {
 8004106:	2901      	cmp	r1, #1
 8004108:	d10d      	bne.n	8004126 <osSemaphoreCreate+0x52>
      vSemaphoreCreateBinary(sema);
 800410a:	4620      	mov	r0, r4
 800410c:	2203      	movs	r2, #3
 800410e:	4629      	mov	r1, r5
 8004110:	f000 fc31 	bl	8004976 <xQueueGenericCreate>
 8004114:	4604      	mov	r4, r0
 8004116:	2800      	cmp	r0, #0
 8004118:	d0eb      	beq.n	80040f2 <osSemaphoreCreate+0x1e>
 800411a:	462b      	mov	r3, r5
 800411c:	462a      	mov	r2, r5
 800411e:	4629      	mov	r1, r5
 8004120:	f000 fc8e 	bl	8004a40 <xQueueGenericSend>
 8004124:	e7e5      	b.n	80040f2 <osSemaphoreCreate+0x1e>
      return xSemaphoreCreateCounting(count, count);
 8004126:	4608      	mov	r0, r1
}
 8004128:	b003      	add	sp, #12
 800412a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      return xSemaphoreCreateCounting(count, count);
 800412e:	f000 bc68 	b.w	8004a02 <xQueueCreateCountingSemaphore>
	...

08004134 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 8004134:	b513      	push	{r0, r1, r4, lr}
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 8004136:	2400      	movs	r4, #0
{
 8004138:	460a      	mov	r2, r1
  portBASE_TYPE taskWoken = pdFALSE;  
 800413a:	9401      	str	r4, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 800413c:	b1e8      	cbz	r0, 800417a <osSemaphoreWait+0x46>
 800413e:	f3ef 8305 	mrs	r3, IPSR
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8004142:	b1a3      	cbz	r3, 800416e <osSemaphoreWait+0x3a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8004144:	aa01      	add	r2, sp, #4
 8004146:	4621      	mov	r1, r4
 8004148:	f000 feaa 	bl	8004ea0 <xQueueReceiveFromISR>
 800414c:	2801      	cmp	r0, #1
 800414e:	d002      	beq.n	8004156 <osSemaphoreWait+0x22>
      return osErrorOS;
 8004150:	20ff      	movs	r0, #255	; 0xff
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
}
 8004152:	b002      	add	sp, #8
 8004154:	bd10      	pop	{r4, pc}
	portEND_SWITCHING_ISR(taskWoken);
 8004156:	9b01      	ldr	r3, [sp, #4]
 8004158:	b13b      	cbz	r3, 800416a <osSemaphoreWait+0x36>
 800415a:	4b09      	ldr	r3, [pc, #36]	; (8004180 <osSemaphoreWait+0x4c>)
 800415c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004160:	601a      	str	r2, [r3, #0]
 8004162:	f3bf 8f4f 	dsb	sy
 8004166:	f3bf 8f6f 	isb	sy
  return osOK;
 800416a:	2000      	movs	r0, #0
 800416c:	e7f1      	b.n	8004152 <osSemaphoreWait+0x1e>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 800416e:	4619      	mov	r1, r3
 8004170:	f000 fdd2 	bl	8004d18 <xQueueGenericReceive>
 8004174:	2801      	cmp	r0, #1
 8004176:	d1eb      	bne.n	8004150 <osSemaphoreWait+0x1c>
 8004178:	e7f7      	b.n	800416a <osSemaphoreWait+0x36>
    return osErrorParameter;
 800417a:	2080      	movs	r0, #128	; 0x80
 800417c:	e7e9      	b.n	8004152 <osSemaphoreWait+0x1e>
 800417e:	bf00      	nop
 8004180:	e000ed04 	.word	0xe000ed04

08004184 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 8004184:	b513      	push	{r0, r1, r4, lr}
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8004186:	2400      	movs	r4, #0
 8004188:	9401      	str	r4, [sp, #4]
 800418a:	f3ef 8305 	mrs	r3, IPSR
  
  
  if (inHandlerMode()) {
 800418e:	b193      	cbz	r3, 80041b6 <osSemaphoreRelease+0x32>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8004190:	a901      	add	r1, sp, #4
 8004192:	f000 fd6d 	bl	8004c70 <xQueueGiveFromISR>
 8004196:	2801      	cmp	r0, #1
 8004198:	d113      	bne.n	80041c2 <osSemaphoreRelease+0x3e>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 800419a:	9b01      	ldr	r3, [sp, #4]
 800419c:	b913      	cbnz	r3, 80041a4 <osSemaphoreRelease+0x20>
  osStatus result = osOK;
 800419e:	2000      	movs	r0, #0
      result = osErrorOS;
    }
  }
  
  return result;
}
 80041a0:	b002      	add	sp, #8
 80041a2:	bd10      	pop	{r4, pc}
    portEND_SWITCHING_ISR(taskWoken);
 80041a4:	4b08      	ldr	r3, [pc, #32]	; (80041c8 <osSemaphoreRelease+0x44>)
 80041a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80041aa:	601a      	str	r2, [r3, #0]
 80041ac:	f3bf 8f4f 	dsb	sy
 80041b0:	f3bf 8f6f 	isb	sy
 80041b4:	e7f3      	b.n	800419e <osSemaphoreRelease+0x1a>
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 80041b6:	461a      	mov	r2, r3
 80041b8:	4619      	mov	r1, r3
 80041ba:	f000 fc41 	bl	8004a40 <xQueueGenericSend>
 80041be:	2801      	cmp	r0, #1
 80041c0:	d0ed      	beq.n	800419e <osSemaphoreRelease+0x1a>
      result = osErrorOS;
 80041c2:	20ff      	movs	r0, #255	; 0xff
 80041c4:	e7ec      	b.n	80041a0 <osSemaphoreRelease+0x1c>
 80041c6:	bf00      	nop
 80041c8:	e000ed04 	.word	0xe000ed04

080041cc <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 80041cc:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 80041ce:	f001 fb31 	bl	8005834 <xTaskGetSchedulerState>
 80041d2:	2801      	cmp	r0, #1
 80041d4:	d003      	beq.n	80041de <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80041d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 80041da:	f000 b90b 	b.w	80043f4 <xPortSysTickHandler>
 80041de:	bd08      	pop	{r3, pc}

080041e0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80041e0:	f100 0308 	add.w	r3, r0, #8
 80041e4:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80041e6:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80041ea:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80041ec:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80041ee:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80041f0:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80041f2:	6003      	str	r3, [r0, #0]
 80041f4:	4770      	bx	lr

080041f6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80041f6:	2300      	movs	r3, #0
 80041f8:	6103      	str	r3, [r0, #16]
 80041fa:	4770      	bx	lr

080041fc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80041fc:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80041fe:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8004200:	689a      	ldr	r2, [r3, #8]
 8004202:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8004204:	689a      	ldr	r2, [r3, #8]
 8004206:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8004208:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800420a:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800420c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800420e:	3301      	adds	r3, #1
 8004210:	6003      	str	r3, [r0, #0]
 8004212:	4770      	bx	lr

08004214 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8004214:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8004216:	1c53      	adds	r3, r2, #1
{
 8004218:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 800421a:	d10a      	bne.n	8004232 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800421c:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800421e:	685a      	ldr	r2, [r3, #4]
 8004220:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8004222:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8004224:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8004226:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8004228:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800422a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800422c:	3301      	adds	r3, #1
 800422e:	6003      	str	r3, [r0, #0]
 8004230:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8004232:	f100 0308 	add.w	r3, r0, #8
 8004236:	685c      	ldr	r4, [r3, #4]
 8004238:	6825      	ldr	r5, [r4, #0]
 800423a:	42aa      	cmp	r2, r5
 800423c:	d3ef      	bcc.n	800421e <vListInsert+0xa>
 800423e:	4623      	mov	r3, r4
 8004240:	e7f9      	b.n	8004236 <vListInsert+0x22>

08004242 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004242:	6841      	ldr	r1, [r0, #4]
 8004244:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8004246:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8004248:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800424a:	6882      	ldr	r2, [r0, #8]
 800424c:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800424e:	6859      	ldr	r1, [r3, #4]
 8004250:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8004252:	bf08      	it	eq
 8004254:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8004256:	2200      	movs	r2, #0
 8004258:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800425a:	6818      	ldr	r0, [r3, #0]
 800425c:	3801      	subs	r0, #1
 800425e:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8004260:	4770      	bx	lr
	...

08004264 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8004264:	4b0a      	ldr	r3, [pc, #40]	; (8004290 <prvTaskExitError+0x2c>)
 8004266:	681b      	ldr	r3, [r3, #0]
 8004268:	3301      	adds	r3, #1
 800426a:	d008      	beq.n	800427e <prvTaskExitError+0x1a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800426c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004270:	f383 8811 	msr	BASEPRI, r3
 8004274:	f3bf 8f6f 	isb	sy
 8004278:	f3bf 8f4f 	dsb	sy
 800427c:	e7fe      	b.n	800427c <prvTaskExitError+0x18>
 800427e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004282:	f383 8811 	msr	BASEPRI, r3
 8004286:	f3bf 8f6f 	isb	sy
 800428a:	f3bf 8f4f 	dsb	sy
 800428e:	e7fe      	b.n	800428e <prvTaskExitError+0x2a>
 8004290:	20000110 	.word	0x20000110

08004294 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8004294:	4806      	ldr	r0, [pc, #24]	; (80042b0 <prvPortStartFirstTask+0x1c>)
 8004296:	6800      	ldr	r0, [r0, #0]
 8004298:	6800      	ldr	r0, [r0, #0]
 800429a:	f380 8808 	msr	MSP, r0
 800429e:	b662      	cpsie	i
 80042a0:	b661      	cpsie	f
 80042a2:	f3bf 8f4f 	dsb	sy
 80042a6:	f3bf 8f6f 	isb	sy
 80042aa:	df00      	svc	0
 80042ac:	bf00      	nop
 80042ae:	0000      	.short	0x0000
 80042b0:	e000ed08 	.word	0xe000ed08

080042b4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80042b4:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80042c4 <vPortEnableVFP+0x10>
 80042b8:	6801      	ldr	r1, [r0, #0]
 80042ba:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80042be:	6001      	str	r1, [r0, #0]
 80042c0:	4770      	bx	lr
 80042c2:	0000      	.short	0x0000
 80042c4:	e000ed88 	.word	0xe000ed88

080042c8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80042c8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80042cc:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80042d0:	4b07      	ldr	r3, [pc, #28]	; (80042f0 <pxPortInitialiseStack+0x28>)
 80042d2:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80042d6:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80042da:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80042de:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80042e2:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80042e6:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80042ea:	3844      	subs	r0, #68	; 0x44
 80042ec:	4770      	bx	lr
 80042ee:	bf00      	nop
 80042f0:	08004265 	.word	0x08004265
	...

08004300 <SVC_Handler>:
	__asm volatile (
 8004300:	4b07      	ldr	r3, [pc, #28]	; (8004320 <pxCurrentTCBConst2>)
 8004302:	6819      	ldr	r1, [r3, #0]
 8004304:	6808      	ldr	r0, [r1, #0]
 8004306:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800430a:	f380 8809 	msr	PSP, r0
 800430e:	f3bf 8f6f 	isb	sy
 8004312:	f04f 0000 	mov.w	r0, #0
 8004316:	f380 8811 	msr	BASEPRI, r0
 800431a:	4770      	bx	lr
 800431c:	f3af 8000 	nop.w

08004320 <pxCurrentTCBConst2>:
 8004320:	20001210 	.word	0x20001210

08004324 <vPortEnterCritical>:
 8004324:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004328:	f383 8811 	msr	BASEPRI, r3
 800432c:	f3bf 8f6f 	isb	sy
 8004330:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8004334:	4a0a      	ldr	r2, [pc, #40]	; (8004360 <vPortEnterCritical+0x3c>)
 8004336:	6813      	ldr	r3, [r2, #0]
 8004338:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800433a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800433c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800433e:	d10d      	bne.n	800435c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004340:	4b08      	ldr	r3, [pc, #32]	; (8004364 <vPortEnterCritical+0x40>)
 8004342:	681b      	ldr	r3, [r3, #0]
 8004344:	f013 0fff 	tst.w	r3, #255	; 0xff
 8004348:	d008      	beq.n	800435c <vPortEnterCritical+0x38>
 800434a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800434e:	f383 8811 	msr	BASEPRI, r3
 8004352:	f3bf 8f6f 	isb	sy
 8004356:	f3bf 8f4f 	dsb	sy
 800435a:	e7fe      	b.n	800435a <vPortEnterCritical+0x36>
 800435c:	4770      	bx	lr
 800435e:	bf00      	nop
 8004360:	20000110 	.word	0x20000110
 8004364:	e000ed04 	.word	0xe000ed04

08004368 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8004368:	4a08      	ldr	r2, [pc, #32]	; (800438c <vPortExitCritical+0x24>)
 800436a:	6813      	ldr	r3, [r2, #0]
 800436c:	b943      	cbnz	r3, 8004380 <vPortExitCritical+0x18>
 800436e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004372:	f383 8811 	msr	BASEPRI, r3
 8004376:	f3bf 8f6f 	isb	sy
 800437a:	f3bf 8f4f 	dsb	sy
 800437e:	e7fe      	b.n	800437e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8004380:	3b01      	subs	r3, #1
 8004382:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8004384:	b90b      	cbnz	r3, 800438a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8004386:	f383 8811 	msr	BASEPRI, r3
 800438a:	4770      	bx	lr
 800438c:	20000110 	.word	0x20000110

08004390 <PendSV_Handler>:
	__asm volatile
 8004390:	f3ef 8009 	mrs	r0, PSP
 8004394:	f3bf 8f6f 	isb	sy
 8004398:	4b15      	ldr	r3, [pc, #84]	; (80043f0 <pxCurrentTCBConst>)
 800439a:	681a      	ldr	r2, [r3, #0]
 800439c:	f01e 0f10 	tst.w	lr, #16
 80043a0:	bf08      	it	eq
 80043a2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80043a6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80043aa:	6010      	str	r0, [r2, #0]
 80043ac:	f84d 3d04 	str.w	r3, [sp, #-4]!
 80043b0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80043b4:	f380 8811 	msr	BASEPRI, r0
 80043b8:	f3bf 8f4f 	dsb	sy
 80043bc:	f3bf 8f6f 	isb	sy
 80043c0:	f001 f934 	bl	800562c <vTaskSwitchContext>
 80043c4:	f04f 0000 	mov.w	r0, #0
 80043c8:	f380 8811 	msr	BASEPRI, r0
 80043cc:	bc08      	pop	{r3}
 80043ce:	6819      	ldr	r1, [r3, #0]
 80043d0:	6808      	ldr	r0, [r1, #0]
 80043d2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80043d6:	f01e 0f10 	tst.w	lr, #16
 80043da:	bf08      	it	eq
 80043dc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80043e0:	f380 8809 	msr	PSP, r0
 80043e4:	f3bf 8f6f 	isb	sy
 80043e8:	4770      	bx	lr
 80043ea:	bf00      	nop
 80043ec:	f3af 8000 	nop.w

080043f0 <pxCurrentTCBConst>:
 80043f0:	20001210 	.word	0x20001210

080043f4 <xPortSysTickHandler>:
{
 80043f4:	b508      	push	{r3, lr}
	__asm volatile
 80043f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043fa:	f383 8811 	msr	BASEPRI, r3
 80043fe:	f3bf 8f6f 	isb	sy
 8004402:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8004406:	f000 ffab 	bl	8005360 <xTaskIncrementTick>
 800440a:	b118      	cbz	r0, 8004414 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800440c:	4b03      	ldr	r3, [pc, #12]	; (800441c <xPortSysTickHandler+0x28>)
 800440e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004412:	601a      	str	r2, [r3, #0]
	__asm volatile
 8004414:	2300      	movs	r3, #0
 8004416:	f383 8811 	msr	BASEPRI, r3
 800441a:	bd08      	pop	{r3, pc}
 800441c:	e000ed04 	.word	0xe000ed04

08004420 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004420:	4b06      	ldr	r3, [pc, #24]	; (800443c <vPortSetupTimerInterrupt+0x1c>)
 8004422:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8004426:	681b      	ldr	r3, [r3, #0]
 8004428:	fbb3 f3f2 	udiv	r3, r3, r2
 800442c:	4a04      	ldr	r2, [pc, #16]	; (8004440 <vPortSetupTimerInterrupt+0x20>)
 800442e:	3b01      	subs	r3, #1
 8004430:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004432:	4b04      	ldr	r3, [pc, #16]	; (8004444 <vPortSetupTimerInterrupt+0x24>)
 8004434:	2207      	movs	r2, #7
 8004436:	601a      	str	r2, [r3, #0]
 8004438:	4770      	bx	lr
 800443a:	bf00      	nop
 800443c:	20000120 	.word	0x20000120
 8004440:	e000e014 	.word	0xe000e014
 8004444:	e000e010 	.word	0xe000e010

08004448 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8004448:	4b31      	ldr	r3, [pc, #196]	; (8004510 <xPortStartScheduler+0xc8>)
 800444a:	4a32      	ldr	r2, [pc, #200]	; (8004514 <xPortStartScheduler+0xcc>)
{
 800444c:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800444e:	6819      	ldr	r1, [r3, #0]
 8004450:	4291      	cmp	r1, r2
 8004452:	d108      	bne.n	8004466 <xPortStartScheduler+0x1e>
	__asm volatile
 8004454:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004458:	f383 8811 	msr	BASEPRI, r3
 800445c:	f3bf 8f6f 	isb	sy
 8004460:	f3bf 8f4f 	dsb	sy
 8004464:	e7fe      	b.n	8004464 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8004466:	681a      	ldr	r2, [r3, #0]
 8004468:	4b2b      	ldr	r3, [pc, #172]	; (8004518 <xPortStartScheduler+0xd0>)
 800446a:	429a      	cmp	r2, r3
 800446c:	d108      	bne.n	8004480 <xPortStartScheduler+0x38>
 800446e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004472:	f383 8811 	msr	BASEPRI, r3
 8004476:	f3bf 8f6f 	isb	sy
 800447a:	f3bf 8f4f 	dsb	sy
 800447e:	e7fe      	b.n	800447e <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004480:	4b26      	ldr	r3, [pc, #152]	; (800451c <xPortStartScheduler+0xd4>)
 8004482:	781a      	ldrb	r2, [r3, #0]
 8004484:	b2d2      	uxtb	r2, r2
 8004486:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8004488:	22ff      	movs	r2, #255	; 0xff
 800448a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800448c:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800448e:	4a24      	ldr	r2, [pc, #144]	; (8004520 <xPortStartScheduler+0xd8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004490:	b2db      	uxtb	r3, r3
 8004492:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004496:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800449a:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800449e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80044a0:	4b20      	ldr	r3, [pc, #128]	; (8004524 <xPortStartScheduler+0xdc>)
 80044a2:	2207      	movs	r2, #7
 80044a4:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80044a6:	2100      	movs	r1, #0
 80044a8:	f89d 0003 	ldrb.w	r0, [sp, #3]
 80044ac:	0600      	lsls	r0, r0, #24
 80044ae:	f102 34ff 	add.w	r4, r2, #4294967295
 80044b2:	d423      	bmi.n	80044fc <xPortStartScheduler+0xb4>
 80044b4:	b101      	cbz	r1, 80044b8 <xPortStartScheduler+0x70>
 80044b6:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 80044b8:	681a      	ldr	r2, [r3, #0]
 80044ba:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80044bc:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80044c0:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80044c2:	9b01      	ldr	r3, [sp, #4]
 80044c4:	4a15      	ldr	r2, [pc, #84]	; (800451c <xPortStartScheduler+0xd4>)
 80044c6:	b2db      	uxtb	r3, r3
 80044c8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80044ca:	4b17      	ldr	r3, [pc, #92]	; (8004528 <xPortStartScheduler+0xe0>)
 80044cc:	681a      	ldr	r2, [r3, #0]
 80044ce:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80044d2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80044d4:	681a      	ldr	r2, [r3, #0]
 80044d6:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 80044da:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 80044dc:	f7ff ffa0 	bl	8004420 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80044e0:	4b12      	ldr	r3, [pc, #72]	; (800452c <xPortStartScheduler+0xe4>)
 80044e2:	2200      	movs	r2, #0
 80044e4:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 80044e6:	f7ff fee5 	bl	80042b4 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 80044ea:	4a11      	ldr	r2, [pc, #68]	; (8004530 <xPortStartScheduler+0xe8>)
 80044ec:	6813      	ldr	r3, [r2, #0]
 80044ee:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80044f2:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 80044f4:	f7ff fece 	bl	8004294 <prvPortStartFirstTask>
	prvTaskExitError();
 80044f8:	f7ff feb4 	bl	8004264 <prvTaskExitError>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80044fc:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8004500:	0052      	lsls	r2, r2, #1
 8004502:	b2d2      	uxtb	r2, r2
 8004504:	f88d 2003 	strb.w	r2, [sp, #3]
 8004508:	2101      	movs	r1, #1
 800450a:	4622      	mov	r2, r4
 800450c:	e7cc      	b.n	80044a8 <xPortStartScheduler+0x60>
 800450e:	bf00      	nop
 8004510:	e000ed00 	.word	0xe000ed00
 8004514:	410fc271 	.word	0x410fc271
 8004518:	410fc270 	.word	0x410fc270
 800451c:	e000e400 	.word	0xe000e400
 8004520:	200001f2 	.word	0x200001f2
 8004524:	200001f4 	.word	0x200001f4
 8004528:	e000ed20 	.word	0xe000ed20
 800452c:	20000110 	.word	0x20000110
 8004530:	e000ef34 	.word	0xe000ef34

08004534 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8004534:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004538:	2b0f      	cmp	r3, #15
 800453a:	d90e      	bls.n	800455a <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800453c:	4a10      	ldr	r2, [pc, #64]	; (8004580 <vPortValidateInterruptPriority+0x4c>)
 800453e:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004540:	4a10      	ldr	r2, [pc, #64]	; (8004584 <vPortValidateInterruptPriority+0x50>)
 8004542:	7812      	ldrb	r2, [r2, #0]
 8004544:	429a      	cmp	r2, r3
 8004546:	d908      	bls.n	800455a <vPortValidateInterruptPriority+0x26>
 8004548:	f04f 0350 	mov.w	r3, #80	; 0x50
 800454c:	f383 8811 	msr	BASEPRI, r3
 8004550:	f3bf 8f6f 	isb	sy
 8004554:	f3bf 8f4f 	dsb	sy
 8004558:	e7fe      	b.n	8004558 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800455a:	4b0b      	ldr	r3, [pc, #44]	; (8004588 <vPortValidateInterruptPriority+0x54>)
 800455c:	4a0b      	ldr	r2, [pc, #44]	; (800458c <vPortValidateInterruptPriority+0x58>)
 800455e:	681b      	ldr	r3, [r3, #0]
 8004560:	6812      	ldr	r2, [r2, #0]
 8004562:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004566:	4293      	cmp	r3, r2
 8004568:	d908      	bls.n	800457c <vPortValidateInterruptPriority+0x48>
 800456a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800456e:	f383 8811 	msr	BASEPRI, r3
 8004572:	f3bf 8f6f 	isb	sy
 8004576:	f3bf 8f4f 	dsb	sy
 800457a:	e7fe      	b.n	800457a <vPortValidateInterruptPriority+0x46>
 800457c:	4770      	bx	lr
 800457e:	bf00      	nop
 8004580:	e000e3f0 	.word	0xe000e3f0
 8004584:	200001f2 	.word	0x200001f2
 8004588:	e000ed0c 	.word	0xe000ed0c
 800458c:	200001f4 	.word	0x200001f4

08004590 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004590:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004592:	4b0f      	ldr	r3, [pc, #60]	; (80045d0 <prvInsertBlockIntoFreeList+0x40>)
 8004594:	681a      	ldr	r2, [r3, #0]
 8004596:	4282      	cmp	r2, r0
 8004598:	d318      	bcc.n	80045cc <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800459a:	685c      	ldr	r4, [r3, #4]
 800459c:	1919      	adds	r1, r3, r4
 800459e:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80045a0:	bf01      	itttt	eq
 80045a2:	6841      	ldreq	r1, [r0, #4]
 80045a4:	4618      	moveq	r0, r3
 80045a6:	1909      	addeq	r1, r1, r4
 80045a8:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80045aa:	6844      	ldr	r4, [r0, #4]
 80045ac:	1901      	adds	r1, r0, r4
 80045ae:	428a      	cmp	r2, r1
 80045b0:	d107      	bne.n	80045c2 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80045b2:	4908      	ldr	r1, [pc, #32]	; (80045d4 <prvInsertBlockIntoFreeList+0x44>)
 80045b4:	6809      	ldr	r1, [r1, #0]
 80045b6:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80045b8:	bf1f      	itttt	ne
 80045ba:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 80045bc:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 80045be:	1909      	addne	r1, r1, r4
 80045c0:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 80045c2:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80045c4:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80045c6:	bf18      	it	ne
 80045c8:	6018      	strne	r0, [r3, #0]
 80045ca:	bd10      	pop	{r4, pc}
 80045cc:	4613      	mov	r3, r2
 80045ce:	e7e1      	b.n	8004594 <prvInsertBlockIntoFreeList+0x4>
 80045d0:	20001208 	.word	0x20001208
 80045d4:	200001f8 	.word	0x200001f8

080045d8 <pvPortMalloc>:
{
 80045d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80045dc:	4604      	mov	r4, r0
	vTaskSuspendAll();
 80045de:	f000 feb1 	bl	8005344 <vTaskSuspendAll>
		if( pxEnd == NULL )
 80045e2:	493e      	ldr	r1, [pc, #248]	; (80046dc <pvPortMalloc+0x104>)
 80045e4:	4d3e      	ldr	r5, [pc, #248]	; (80046e0 <pvPortMalloc+0x108>)
 80045e6:	680b      	ldr	r3, [r1, #0]
 80045e8:	bb0b      	cbnz	r3, 800462e <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 80045ea:	4a3e      	ldr	r2, [pc, #248]	; (80046e4 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80045ec:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 80045ee:	bf1f      	itttt	ne
 80045f0:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80045f2:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80045f6:	f502 5380 	addne.w	r3, r2, #4096	; 0x1000
 80045fa:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80045fc:	bf14      	ite	ne
 80045fe:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8004600:	f44f 5380 	moveq.w	r3, #4096	; 0x1000
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8004604:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8004606:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8004608:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800460c:	4e36      	ldr	r6, [pc, #216]	; (80046e8 <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 800460e:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8004610:	2000      	movs	r0, #0
 8004612:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004614:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8004616:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8004618:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800461a:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800461c:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800461e:	4b33      	ldr	r3, [pc, #204]	; (80046ec <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8004620:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004622:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004624:	4b32      	ldr	r3, [pc, #200]	; (80046f0 <pvPortMalloc+0x118>)
 8004626:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004628:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800462c:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800462e:	682f      	ldr	r7, [r5, #0]
 8004630:	4227      	tst	r7, r4
 8004632:	d116      	bne.n	8004662 <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8004634:	2c00      	cmp	r4, #0
 8004636:	d041      	beq.n	80046bc <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8004638:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800463c:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800463e:	bf1c      	itt	ne
 8004640:	f023 0307 	bicne.w	r3, r3, #7
 8004644:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004646:	b163      	cbz	r3, 8004662 <pvPortMalloc+0x8a>
 8004648:	4a29      	ldr	r2, [pc, #164]	; (80046f0 <pvPortMalloc+0x118>)
 800464a:	6816      	ldr	r6, [r2, #0]
 800464c:	42b3      	cmp	r3, r6
 800464e:	4690      	mov	r8, r2
 8004650:	d807      	bhi.n	8004662 <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8004652:	4a25      	ldr	r2, [pc, #148]	; (80046e8 <pvPortMalloc+0x110>)
 8004654:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004656:	6868      	ldr	r0, [r5, #4]
 8004658:	4283      	cmp	r3, r0
 800465a:	d804      	bhi.n	8004666 <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 800465c:	6809      	ldr	r1, [r1, #0]
 800465e:	428d      	cmp	r5, r1
 8004660:	d107      	bne.n	8004672 <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8004662:	2400      	movs	r4, #0
 8004664:	e02a      	b.n	80046bc <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004666:	682c      	ldr	r4, [r5, #0]
 8004668:	2c00      	cmp	r4, #0
 800466a:	d0f7      	beq.n	800465c <pvPortMalloc+0x84>
 800466c:	462a      	mov	r2, r5
 800466e:	4625      	mov	r5, r4
 8004670:	e7f1      	b.n	8004656 <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004672:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004674:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004676:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004678:	1ac2      	subs	r2, r0, r3
 800467a:	2a10      	cmp	r2, #16
 800467c:	d90f      	bls.n	800469e <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800467e:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004680:	0741      	lsls	r1, r0, #29
 8004682:	d008      	beq.n	8004696 <pvPortMalloc+0xbe>
 8004684:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004688:	f383 8811 	msr	BASEPRI, r3
 800468c:	f3bf 8f6f 	isb	sy
 8004690:	f3bf 8f4f 	dsb	sy
 8004694:	e7fe      	b.n	8004694 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004696:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004698:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800469a:	f7ff ff79 	bl	8004590 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800469e:	4913      	ldr	r1, [pc, #76]	; (80046ec <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80046a0:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80046a2:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80046a4:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80046a6:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80046a8:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 80046aa:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80046ae:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80046b2:	bf38      	it	cc
 80046b4:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80046b6:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80046b8:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80046ba:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 80046bc:	f000 fee2 	bl	8005484 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80046c0:	0763      	lsls	r3, r4, #29
 80046c2:	d008      	beq.n	80046d6 <pvPortMalloc+0xfe>
 80046c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046c8:	f383 8811 	msr	BASEPRI, r3
 80046cc:	f3bf 8f6f 	isb	sy
 80046d0:	f3bf 8f4f 	dsb	sy
 80046d4:	e7fe      	b.n	80046d4 <pvPortMalloc+0xfc>
}
 80046d6:	4620      	mov	r0, r4
 80046d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80046dc:	200001f8 	.word	0x200001f8
 80046e0:	200011fc 	.word	0x200011fc
 80046e4:	200001fc 	.word	0x200001fc
 80046e8:	20001208 	.word	0x20001208
 80046ec:	20001204 	.word	0x20001204
 80046f0:	20001200 	.word	0x20001200

080046f4 <vPortFree>:
{
 80046f4:	b510      	push	{r4, lr}
	if( pv != NULL )
 80046f6:	4604      	mov	r4, r0
 80046f8:	b370      	cbz	r0, 8004758 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 80046fa:	4a18      	ldr	r2, [pc, #96]	; (800475c <vPortFree+0x68>)
 80046fc:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004700:	6812      	ldr	r2, [r2, #0]
 8004702:	4213      	tst	r3, r2
 8004704:	d108      	bne.n	8004718 <vPortFree+0x24>
 8004706:	f04f 0350 	mov.w	r3, #80	; 0x50
 800470a:	f383 8811 	msr	BASEPRI, r3
 800470e:	f3bf 8f6f 	isb	sy
 8004712:	f3bf 8f4f 	dsb	sy
 8004716:	e7fe      	b.n	8004716 <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004718:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800471c:	b141      	cbz	r1, 8004730 <vPortFree+0x3c>
 800471e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004722:	f383 8811 	msr	BASEPRI, r3
 8004726:	f3bf 8f6f 	isb	sy
 800472a:	f3bf 8f4f 	dsb	sy
 800472e:	e7fe      	b.n	800472e <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004730:	ea23 0302 	bic.w	r3, r3, r2
 8004734:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8004738:	f000 fe04 	bl	8005344 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800473c:	4a08      	ldr	r2, [pc, #32]	; (8004760 <vPortFree+0x6c>)
 800473e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004742:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004744:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004748:	440b      	add	r3, r1
 800474a:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800474c:	f7ff ff20 	bl	8004590 <prvInsertBlockIntoFreeList>
}
 8004750:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8004754:	f000 be96 	b.w	8005484 <xTaskResumeAll>
 8004758:	bd10      	pop	{r4, pc}
 800475a:	bf00      	nop
 800475c:	200011fc 	.word	0x200011fc
 8004760:	20001200 	.word	0x20001200

08004764 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8004764:	b570      	push	{r4, r5, r6, lr}
 8004766:	4615      	mov	r5, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8004768:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800476a:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
 800476c:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800476e:	b942      	cbnz	r2, 8004782 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004770:	6805      	ldr	r5, [r0, #0]
 8004772:	b99d      	cbnz	r5, 800479c <prvCopyDataToQueue+0x38>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8004774:	6840      	ldr	r0, [r0, #4]
 8004776:	f001 f8b3 	bl	80058e0 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 800477a:	6065      	str	r5, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 800477c:	3601      	adds	r6, #1
 800477e:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 8004780:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8004782:	b96d      	cbnz	r5, 80047a0 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8004784:	6880      	ldr	r0, [r0, #8]
 8004786:	f002 fce9 	bl	800715c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800478a:	68a3      	ldr	r3, [r4, #8]
 800478c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800478e:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004790:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004792:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004794:	4293      	cmp	r3, r2
 8004796:	d301      	bcc.n	800479c <prvCopyDataToQueue+0x38>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8004798:	6823      	ldr	r3, [r4, #0]
 800479a:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 800479c:	2000      	movs	r0, #0
 800479e:	e7ed      	b.n	800477c <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80047a0:	68c0      	ldr	r0, [r0, #12]
 80047a2:	f002 fcdb 	bl	800715c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80047a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80047a8:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80047aa:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80047ac:	425b      	negs	r3, r3
 80047ae:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80047b0:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80047b2:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80047b4:	bf3e      	ittt	cc
 80047b6:	6862      	ldrcc	r2, [r4, #4]
 80047b8:	189b      	addcc	r3, r3, r2
 80047ba:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 80047bc:	2d02      	cmp	r5, #2
 80047be:	d1ed      	bne.n	800479c <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80047c0:	b10e      	cbz	r6, 80047c6 <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 80047c2:	3e01      	subs	r6, #1
 80047c4:	e7ea      	b.n	800479c <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 80047c6:	4630      	mov	r0, r6
 80047c8:	e7d8      	b.n	800477c <prvCopyDataToQueue+0x18>

080047ca <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 80047ca:	4603      	mov	r3, r0
 80047cc:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80047ce:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 80047d0:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80047d2:	b162      	cbz	r2, 80047ee <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80047d4:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80047d6:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80047d8:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80047da:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80047dc:	60d9      	str	r1, [r3, #12]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 80047de:	bf24      	itt	cs
 80047e0:	6819      	ldrcs	r1, [r3, #0]
 80047e2:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 80047e4:	68d9      	ldr	r1, [r3, #12]
	}
}
 80047e6:	f85d 4b04 	ldr.w	r4, [sp], #4
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 80047ea:	f002 bcb7 	b.w	800715c <memcpy>
}
 80047ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 80047f2:	4770      	bx	lr

080047f4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 80047f4:	b570      	push	{r4, r5, r6, lr}
 80047f6:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80047f8:	f7ff fd94 	bl	8004324 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 80047fc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004800:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8004804:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004806:	2d00      	cmp	r5, #0
 8004808:	dc14      	bgt.n	8004834 <prvUnlockQueue+0x40>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800480a:	23ff      	movs	r3, #255	; 0xff
 800480c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004810:	f7ff fdaa 	bl	8004368 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004814:	f7ff fd86 	bl	8004324 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004818:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800481c:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 8004820:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004822:	2d00      	cmp	r5, #0
 8004824:	dc12      	bgt.n	800484c <prvUnlockQueue+0x58>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004826:	23ff      	movs	r3, #255	; 0xff
 8004828:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 800482c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8004830:	f7ff bd9a 	b.w	8004368 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004834:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004836:	2b00      	cmp	r3, #0
 8004838:	d0e7      	beq.n	800480a <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800483a:	4630      	mov	r0, r6
 800483c:	f000 ff68 	bl	8005710 <xTaskRemoveFromEventList>
 8004840:	b108      	cbz	r0, 8004846 <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8004842:	f000 fff1 	bl	8005828 <vTaskMissedYield>
 8004846:	3d01      	subs	r5, #1
 8004848:	b26d      	sxtb	r5, r5
 800484a:	e7dc      	b.n	8004806 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800484c:	6923      	ldr	r3, [r4, #16]
 800484e:	2b00      	cmp	r3, #0
 8004850:	d0e9      	beq.n	8004826 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004852:	4630      	mov	r0, r6
 8004854:	f000 ff5c 	bl	8005710 <xTaskRemoveFromEventList>
 8004858:	b108      	cbz	r0, 800485e <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 800485a:	f000 ffe5 	bl	8005828 <vTaskMissedYield>
 800485e:	3d01      	subs	r5, #1
 8004860:	b26d      	sxtb	r5, r5
 8004862:	e7de      	b.n	8004822 <prvUnlockQueue+0x2e>

08004864 <xQueueGenericReset>:
{
 8004864:	b538      	push	{r3, r4, r5, lr}
 8004866:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8004868:	4604      	mov	r4, r0
 800486a:	b940      	cbnz	r0, 800487e <xQueueGenericReset+0x1a>
 800486c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004870:	f383 8811 	msr	BASEPRI, r3
 8004874:	f3bf 8f6f 	isb	sy
 8004878:	f3bf 8f4f 	dsb	sy
 800487c:	e7fe      	b.n	800487c <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
 800487e:	f7ff fd51 	bl	8004324 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004882:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8004884:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004886:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8004888:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800488a:	4343      	muls	r3, r0
 800488c:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800488e:	1a1b      	subs	r3, r3, r0
 8004890:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004892:	6061      	str	r1, [r4, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8004894:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8004896:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 8004898:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800489a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 800489c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 80048a0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 80048a4:	b995      	cbnz	r5, 80048cc <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80048a6:	6923      	ldr	r3, [r4, #16]
 80048a8:	b163      	cbz	r3, 80048c4 <xQueueGenericReset+0x60>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80048aa:	f104 0010 	add.w	r0, r4, #16
 80048ae:	f000 ff2f 	bl	8005710 <xTaskRemoveFromEventList>
 80048b2:	b138      	cbz	r0, 80048c4 <xQueueGenericReset+0x60>
					queueYIELD_IF_USING_PREEMPTION();
 80048b4:	4b0a      	ldr	r3, [pc, #40]	; (80048e0 <xQueueGenericReset+0x7c>)
 80048b6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80048ba:	601a      	str	r2, [r3, #0]
 80048bc:	f3bf 8f4f 	dsb	sy
 80048c0:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 80048c4:	f7ff fd50 	bl	8004368 <vPortExitCritical>
}
 80048c8:	2001      	movs	r0, #1
 80048ca:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 80048cc:	f104 0010 	add.w	r0, r4, #16
 80048d0:	f7ff fc86 	bl	80041e0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 80048d4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80048d8:	f7ff fc82 	bl	80041e0 <vListInitialise>
 80048dc:	e7f2      	b.n	80048c4 <xQueueGenericReset+0x60>
 80048de:	bf00      	nop
 80048e0:	e000ed04 	.word	0xe000ed04

080048e4 <xQueueGenericCreateStatic>:
	{
 80048e4:	b513      	push	{r0, r1, r4, lr}
 80048e6:	461c      	mov	r4, r3
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80048e8:	b940      	cbnz	r0, 80048fc <xQueueGenericCreateStatic+0x18>
 80048ea:	f04f 0350 	mov.w	r3, #80	; 0x50
 80048ee:	f383 8811 	msr	BASEPRI, r3
 80048f2:	f3bf 8f6f 	isb	sy
 80048f6:	f3bf 8f4f 	dsb	sy
 80048fa:	e7fe      	b.n	80048fa <xQueueGenericCreateStatic+0x16>
		configASSERT( pxStaticQueue != NULL );
 80048fc:	b943      	cbnz	r3, 8004910 <xQueueGenericCreateStatic+0x2c>
 80048fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004902:	f383 8811 	msr	BASEPRI, r3
 8004906:	f3bf 8f6f 	isb	sy
 800490a:	f3bf 8f4f 	dsb	sy
 800490e:	e7fe      	b.n	800490e <xQueueGenericCreateStatic+0x2a>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8004910:	b14a      	cbz	r2, 8004926 <xQueueGenericCreateStatic+0x42>
 8004912:	b9d9      	cbnz	r1, 800494c <xQueueGenericCreateStatic+0x68>
 8004914:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004918:	f383 8811 	msr	BASEPRI, r3
 800491c:	f3bf 8f6f 	isb	sy
 8004920:	f3bf 8f4f 	dsb	sy
 8004924:	e7fe      	b.n	8004924 <xQueueGenericCreateStatic+0x40>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8004926:	b189      	cbz	r1, 800494c <xQueueGenericCreateStatic+0x68>
 8004928:	f04f 0350 	mov.w	r3, #80	; 0x50
 800492c:	f383 8811 	msr	BASEPRI, r3
 8004930:	f3bf 8f6f 	isb	sy
 8004934:	f3bf 8f4f 	dsb	sy
 8004938:	e7fe      	b.n	8004938 <xQueueGenericCreateStatic+0x54>
 800493a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800493e:	f383 8811 	msr	BASEPRI, r3
 8004942:	f3bf 8f6f 	isb	sy
 8004946:	f3bf 8f4f 	dsb	sy
 800494a:	e7fe      	b.n	800494a <xQueueGenericCreateStatic+0x66>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800494c:	2348      	movs	r3, #72	; 0x48
 800494e:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 8004950:	9b01      	ldr	r3, [sp, #4]
 8004952:	2b48      	cmp	r3, #72	; 0x48
 8004954:	d1f1      	bne.n	800493a <xQueueGenericCreateStatic+0x56>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8004956:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004958:	2900      	cmp	r1, #0
 800495a:	bf08      	it	eq
 800495c:	4622      	moveq	r2, r4
	pxNewQueue->uxLength = uxQueueLength;
 800495e:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8004960:	6421      	str	r1, [r4, #64]	; 0x40
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8004962:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004966:	6022      	str	r2, [r4, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8004968:	4619      	mov	r1, r3
 800496a:	4620      	mov	r0, r4
 800496c:	f7ff ff7a 	bl	8004864 <xQueueGenericReset>
	}
 8004970:	4620      	mov	r0, r4
 8004972:	b002      	add	sp, #8
 8004974:	bd10      	pop	{r4, pc}

08004976 <xQueueGenericCreate>:
	{
 8004976:	b570      	push	{r4, r5, r6, lr}
 8004978:	460d      	mov	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800497a:	4606      	mov	r6, r0
 800497c:	b940      	cbnz	r0, 8004990 <xQueueGenericCreate+0x1a>
 800497e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004982:	f383 8811 	msr	BASEPRI, r3
 8004986:	f3bf 8f6f 	isb	sy
 800498a:	f3bf 8f4f 	dsb	sy
 800498e:	e7fe      	b.n	800498e <xQueueGenericCreate+0x18>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004990:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8004992:	3048      	adds	r0, #72	; 0x48
 8004994:	f7ff fe20 	bl	80045d8 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8004998:	4604      	mov	r4, r0
 800499a:	b150      	cbz	r0, 80049b2 <xQueueGenericCreate+0x3c>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800499c:	2300      	movs	r3, #0
 800499e:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
	if( uxItemSize == ( UBaseType_t ) 0 )
 80049a2:	b945      	cbnz	r5, 80049b6 <xQueueGenericCreate+0x40>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80049a4:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 80049a6:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 80049a8:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80049aa:	2101      	movs	r1, #1
 80049ac:	4620      	mov	r0, r4
 80049ae:	f7ff ff59 	bl	8004864 <xQueueGenericReset>
	}
 80049b2:	4620      	mov	r0, r4
 80049b4:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 80049b6:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80049ba:	6003      	str	r3, [r0, #0]
 80049bc:	e7f3      	b.n	80049a6 <xQueueGenericCreate+0x30>

080049be <xQueueCreateCountingSemaphoreStatic>:
	{
 80049be:	b513      	push	{r0, r1, r4, lr}
 80049c0:	4613      	mov	r3, r2
 80049c2:	460c      	mov	r4, r1
		configASSERT( uxMaxCount != 0 );
 80049c4:	b940      	cbnz	r0, 80049d8 <xQueueCreateCountingSemaphoreStatic+0x1a>
 80049c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80049ca:	f383 8811 	msr	BASEPRI, r3
 80049ce:	f3bf 8f6f 	isb	sy
 80049d2:	f3bf 8f4f 	dsb	sy
 80049d6:	e7fe      	b.n	80049d6 <xQueueCreateCountingSemaphoreStatic+0x18>
		configASSERT( uxInitialCount <= uxMaxCount );
 80049d8:	4288      	cmp	r0, r1
 80049da:	d208      	bcs.n	80049ee <xQueueCreateCountingSemaphoreStatic+0x30>
 80049dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80049e0:	f383 8811 	msr	BASEPRI, r3
 80049e4:	f3bf 8f6f 	isb	sy
 80049e8:	f3bf 8f4f 	dsb	sy
 80049ec:	e7fe      	b.n	80049ec <xQueueCreateCountingSemaphoreStatic+0x2e>
		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80049ee:	2202      	movs	r2, #2
 80049f0:	9200      	str	r2, [sp, #0]
 80049f2:	2200      	movs	r2, #0
 80049f4:	4611      	mov	r1, r2
 80049f6:	f7ff ff75 	bl	80048e4 <xQueueGenericCreateStatic>
		if( xHandle != NULL )
 80049fa:	b100      	cbz	r0, 80049fe <xQueueCreateCountingSemaphoreStatic+0x40>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80049fc:	6384      	str	r4, [r0, #56]	; 0x38
	}
 80049fe:	b002      	add	sp, #8
 8004a00:	bd10      	pop	{r4, pc}

08004a02 <xQueueCreateCountingSemaphore>:
	{
 8004a02:	b510      	push	{r4, lr}
 8004a04:	460c      	mov	r4, r1
		configASSERT( uxMaxCount != 0 );
 8004a06:	b940      	cbnz	r0, 8004a1a <xQueueCreateCountingSemaphore+0x18>
 8004a08:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a0c:	f383 8811 	msr	BASEPRI, r3
 8004a10:	f3bf 8f6f 	isb	sy
 8004a14:	f3bf 8f4f 	dsb	sy
 8004a18:	e7fe      	b.n	8004a18 <xQueueCreateCountingSemaphore+0x16>
		configASSERT( uxInitialCount <= uxMaxCount );
 8004a1a:	4288      	cmp	r0, r1
 8004a1c:	d208      	bcs.n	8004a30 <xQueueCreateCountingSemaphore+0x2e>
 8004a1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a22:	f383 8811 	msr	BASEPRI, r3
 8004a26:	f3bf 8f6f 	isb	sy
 8004a2a:	f3bf 8f4f 	dsb	sy
 8004a2e:	e7fe      	b.n	8004a2e <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8004a30:	2202      	movs	r2, #2
 8004a32:	2100      	movs	r1, #0
 8004a34:	f7ff ff9f 	bl	8004976 <xQueueGenericCreate>
		if( xHandle != NULL )
 8004a38:	b100      	cbz	r0, 8004a3c <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8004a3a:	6384      	str	r4, [r0, #56]	; 0x38
	}
 8004a3c:	bd10      	pop	{r4, pc}
	...

08004a40 <xQueueGenericSend>:
{
 8004a40:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004a44:	4689      	mov	r9, r1
 8004a46:	9201      	str	r2, [sp, #4]
 8004a48:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8004a4a:	4604      	mov	r4, r0
 8004a4c:	b940      	cbnz	r0, 8004a60 <xQueueGenericSend+0x20>
 8004a4e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a52:	f383 8811 	msr	BASEPRI, r3
 8004a56:	f3bf 8f6f 	isb	sy
 8004a5a:	f3bf 8f4f 	dsb	sy
 8004a5e:	e7fe      	b.n	8004a5e <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004a60:	2900      	cmp	r1, #0
 8004a62:	f040 8088 	bne.w	8004b76 <xQueueGenericSend+0x136>
 8004a66:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004a68:	2b00      	cmp	r3, #0
 8004a6a:	f000 8084 	beq.w	8004b76 <xQueueGenericSend+0x136>
 8004a6e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a72:	f383 8811 	msr	BASEPRI, r3
 8004a76:	f3bf 8f6f 	isb	sy
 8004a7a:	f3bf 8f4f 	dsb	sy
 8004a7e:	e7fe      	b.n	8004a7e <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004a80:	9e01      	ldr	r6, [sp, #4]
 8004a82:	2e00      	cmp	r6, #0
 8004a84:	f000 8082 	beq.w	8004b8c <xQueueGenericSend+0x14c>
 8004a88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a8c:	f383 8811 	msr	BASEPRI, r3
 8004a90:	f3bf 8f6f 	isb	sy
 8004a94:	f3bf 8f4f 	dsb	sy
 8004a98:	e7fe      	b.n	8004a98 <xQueueGenericSend+0x58>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004a9a:	9d01      	ldr	r5, [sp, #4]
 8004a9c:	b91d      	cbnz	r5, 8004aa6 <xQueueGenericSend+0x66>
					taskEXIT_CRITICAL();
 8004a9e:	f7ff fc63 	bl	8004368 <vPortExitCritical>
			return errQUEUE_FULL;
 8004aa2:	2000      	movs	r0, #0
 8004aa4:	e058      	b.n	8004b58 <xQueueGenericSend+0x118>
				else if( xEntryTimeSet == pdFALSE )
 8004aa6:	b916      	cbnz	r6, 8004aae <xQueueGenericSend+0x6e>
					vTaskSetTimeOutState( &xTimeOut );
 8004aa8:	a802      	add	r0, sp, #8
 8004aaa:	f000 fe73 	bl	8005794 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8004aae:	f7ff fc5b 	bl	8004368 <vPortExitCritical>
		vTaskSuspendAll();
 8004ab2:	f000 fc47 	bl	8005344 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004ab6:	f7ff fc35 	bl	8004324 <vPortEnterCritical>
 8004aba:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004abe:	2bff      	cmp	r3, #255	; 0xff
 8004ac0:	bf08      	it	eq
 8004ac2:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 8004ac6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004aca:	2bff      	cmp	r3, #255	; 0xff
 8004acc:	bf08      	it	eq
 8004ace:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8004ad2:	f7ff fc49 	bl	8004368 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004ad6:	a901      	add	r1, sp, #4
 8004ad8:	a802      	add	r0, sp, #8
 8004ada:	f000 fe6b 	bl	80057b4 <xTaskCheckForTimeOut>
 8004ade:	2800      	cmp	r0, #0
 8004ae0:	d143      	bne.n	8004b6a <xQueueGenericSend+0x12a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8004ae2:	f7ff fc1f 	bl	8004324 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8004ae6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8004ae8:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8004aea:	f7ff fc3d 	bl	8004368 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8004aee:	42ae      	cmp	r6, r5
 8004af0:	d135      	bne.n	8004b5e <xQueueGenericSend+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8004af2:	9901      	ldr	r1, [sp, #4]
 8004af4:	f104 0010 	add.w	r0, r4, #16
 8004af8:	f000 fdd2 	bl	80056a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004afc:	4620      	mov	r0, r4
 8004afe:	f7ff fe79 	bl	80047f4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004b02:	f000 fcbf 	bl	8005484 <xTaskResumeAll>
 8004b06:	b938      	cbnz	r0, 8004b18 <xQueueGenericSend+0xd8>
					portYIELD_WITHIN_API();
 8004b08:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004b0c:	f8ca 3000 	str.w	r3, [sl]
 8004b10:	f3bf 8f4f 	dsb	sy
 8004b14:	f3bf 8f6f 	isb	sy
 8004b18:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8004b1a:	f7ff fc03 	bl	8004324 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8004b1e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004b20:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004b22:	429a      	cmp	r2, r3
 8004b24:	d301      	bcc.n	8004b2a <xQueueGenericSend+0xea>
 8004b26:	2f02      	cmp	r7, #2
 8004b28:	d1b7      	bne.n	8004a9a <xQueueGenericSend+0x5a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004b2a:	463a      	mov	r2, r7
 8004b2c:	4649      	mov	r1, r9
 8004b2e:	4620      	mov	r0, r4
 8004b30:	f7ff fe18 	bl	8004764 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004b34:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004b36:	b11b      	cbz	r3, 8004b40 <xQueueGenericSend+0x100>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004b38:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004b3c:	f000 fde8 	bl	8005710 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 8004b40:	b138      	cbz	r0, 8004b52 <xQueueGenericSend+0x112>
						queueYIELD_IF_USING_PREEMPTION();
 8004b42:	4b19      	ldr	r3, [pc, #100]	; (8004ba8 <xQueueGenericSend+0x168>)
 8004b44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004b48:	601a      	str	r2, [r3, #0]
 8004b4a:	f3bf 8f4f 	dsb	sy
 8004b4e:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8004b52:	f7ff fc09 	bl	8004368 <vPortExitCritical>
				return pdPASS;
 8004b56:	2001      	movs	r0, #1
}
 8004b58:	b004      	add	sp, #16
 8004b5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 8004b5e:	4620      	mov	r0, r4
 8004b60:	f7ff fe48 	bl	80047f4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004b64:	f000 fc8e 	bl	8005484 <xTaskResumeAll>
 8004b68:	e7d6      	b.n	8004b18 <xQueueGenericSend+0xd8>
			prvUnlockQueue( pxQueue );
 8004b6a:	4620      	mov	r0, r4
 8004b6c:	f7ff fe42 	bl	80047f4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004b70:	f000 fc88 	bl	8005484 <xTaskResumeAll>
 8004b74:	e795      	b.n	8004aa2 <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004b76:	2f02      	cmp	r7, #2
 8004b78:	d102      	bne.n	8004b80 <xQueueGenericSend+0x140>
 8004b7a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004b7c:	2b01      	cmp	r3, #1
 8004b7e:	d10a      	bne.n	8004b96 <xQueueGenericSend+0x156>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004b80:	f000 fe58 	bl	8005834 <xTaskGetSchedulerState>
 8004b84:	2800      	cmp	r0, #0
 8004b86:	f43f af7b 	beq.w	8004a80 <xQueueGenericSend+0x40>
 8004b8a:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8004b8c:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8004b90:	f8df a014 	ldr.w	sl, [pc, #20]	; 8004ba8 <xQueueGenericSend+0x168>
 8004b94:	e7c1      	b.n	8004b1a <xQueueGenericSend+0xda>
 8004b96:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b9a:	f383 8811 	msr	BASEPRI, r3
 8004b9e:	f3bf 8f6f 	isb	sy
 8004ba2:	f3bf 8f4f 	dsb	sy
 8004ba6:	e7fe      	b.n	8004ba6 <xQueueGenericSend+0x166>
 8004ba8:	e000ed04 	.word	0xe000ed04

08004bac <xQueueGenericSendFromISR>:
{
 8004bac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004bb0:	4688      	mov	r8, r1
 8004bb2:	4691      	mov	r9, r2
 8004bb4:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8004bb6:	4604      	mov	r4, r0
 8004bb8:	b940      	cbnz	r0, 8004bcc <xQueueGenericSendFromISR+0x20>
 8004bba:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bbe:	f383 8811 	msr	BASEPRI, r3
 8004bc2:	f3bf 8f6f 	isb	sy
 8004bc6:	f3bf 8f4f 	dsb	sy
 8004bca:	e7fe      	b.n	8004bca <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004bcc:	bb09      	cbnz	r1, 8004c12 <xQueueGenericSendFromISR+0x66>
 8004bce:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004bd0:	b1fb      	cbz	r3, 8004c12 <xQueueGenericSendFromISR+0x66>
 8004bd2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bd6:	f383 8811 	msr	BASEPRI, r3
 8004bda:	f3bf 8f6f 	isb	sy
 8004bde:	f3bf 8f4f 	dsb	sy
 8004be2:	e7fe      	b.n	8004be2 <xQueueGenericSendFromISR+0x36>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004be4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004be8:	f000 fd92 	bl	8005710 <xTaskRemoveFromEventList>
 8004bec:	2800      	cmp	r0, #0
 8004bee:	d034      	beq.n	8004c5a <xQueueGenericSendFromISR+0xae>
							if( pxHigherPriorityTaskWoken != NULL )
 8004bf0:	f1b9 0f00 	cmp.w	r9, #0
 8004bf4:	d031      	beq.n	8004c5a <xQueueGenericSendFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8004bf6:	2001      	movs	r0, #1
 8004bf8:	f8c9 0000 	str.w	r0, [r9]
	__asm volatile
 8004bfc:	f386 8811 	msr	BASEPRI, r6
}
 8004c00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8004c04:	3501      	adds	r5, #1
 8004c06:	b26d      	sxtb	r5, r5
 8004c08:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8004c0c:	e025      	b.n	8004c5a <xQueueGenericSendFromISR+0xae>
			xReturn = errQUEUE_FULL;
 8004c0e:	2000      	movs	r0, #0
 8004c10:	e7f4      	b.n	8004bfc <xQueueGenericSendFromISR+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004c12:	2f02      	cmp	r7, #2
 8004c14:	d102      	bne.n	8004c1c <xQueueGenericSendFromISR+0x70>
 8004c16:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004c18:	2b01      	cmp	r3, #1
 8004c1a:	d120      	bne.n	8004c5e <xQueueGenericSendFromISR+0xb2>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004c1c:	f7ff fc8a 	bl	8004534 <vPortValidateInterruptPriority>
	__asm volatile
 8004c20:	f3ef 8611 	mrs	r6, BASEPRI
 8004c24:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c28:	f383 8811 	msr	BASEPRI, r3
 8004c2c:	f3bf 8f6f 	isb	sy
 8004c30:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8004c34:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8004c36:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004c38:	429a      	cmp	r2, r3
 8004c3a:	d301      	bcc.n	8004c40 <xQueueGenericSendFromISR+0x94>
 8004c3c:	2f02      	cmp	r7, #2
 8004c3e:	d1e6      	bne.n	8004c0e <xQueueGenericSendFromISR+0x62>
			const int8_t cTxLock = pxQueue->cTxLock;
 8004c40:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004c44:	463a      	mov	r2, r7
			const int8_t cTxLock = pxQueue->cTxLock;
 8004c46:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8004c48:	4641      	mov	r1, r8
 8004c4a:	4620      	mov	r0, r4
 8004c4c:	f7ff fd8a 	bl	8004764 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8004c50:	1c6b      	adds	r3, r5, #1
 8004c52:	d1d7      	bne.n	8004c04 <xQueueGenericSendFromISR+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004c54:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004c56:	2b00      	cmp	r3, #0
 8004c58:	d1c4      	bne.n	8004be4 <xQueueGenericSendFromISR+0x38>
			xReturn = pdPASS;
 8004c5a:	2001      	movs	r0, #1
 8004c5c:	e7ce      	b.n	8004bfc <xQueueGenericSendFromISR+0x50>
	__asm volatile
 8004c5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c62:	f383 8811 	msr	BASEPRI, r3
 8004c66:	f3bf 8f6f 	isb	sy
 8004c6a:	f3bf 8f4f 	dsb	sy
 8004c6e:	e7fe      	b.n	8004c6e <xQueueGenericSendFromISR+0xc2>

08004c70 <xQueueGiveFromISR>:
{
 8004c70:	b570      	push	{r4, r5, r6, lr}
 8004c72:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8004c74:	4604      	mov	r4, r0
 8004c76:	b940      	cbnz	r0, 8004c8a <xQueueGiveFromISR+0x1a>
 8004c78:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c7c:	f383 8811 	msr	BASEPRI, r3
 8004c80:	f3bf 8f6f 	isb	sy
 8004c84:	f3bf 8f4f 	dsb	sy
 8004c88:	e7fe      	b.n	8004c88 <xQueueGiveFromISR+0x18>
	configASSERT( pxQueue->uxItemSize == 0 );
 8004c8a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004c8c:	b143      	cbz	r3, 8004ca0 <xQueueGiveFromISR+0x30>
 8004c8e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c92:	f383 8811 	msr	BASEPRI, r3
 8004c96:	f3bf 8f6f 	isb	sy
 8004c9a:	f3bf 8f4f 	dsb	sy
 8004c9e:	e7fe      	b.n	8004c9e <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
 8004ca0:	6803      	ldr	r3, [r0, #0]
 8004ca2:	b90b      	cbnz	r3, 8004ca8 <xQueueGiveFromISR+0x38>
 8004ca4:	6843      	ldr	r3, [r0, #4]
 8004ca6:	bb73      	cbnz	r3, 8004d06 <xQueueGiveFromISR+0x96>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004ca8:	f7ff fc44 	bl	8004534 <vPortValidateInterruptPriority>
	__asm volatile
 8004cac:	f3ef 8611 	mrs	r6, BASEPRI
 8004cb0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004cb4:	f383 8811 	msr	BASEPRI, r3
 8004cb8:	f3bf 8f6f 	isb	sy
 8004cbc:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004cc0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 8004cc2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004cc4:	429a      	cmp	r2, r3
 8004cc6:	d301      	bcc.n	8004ccc <xQueueGiveFromISR+0x5c>
			xReturn = errQUEUE_FULL;
 8004cc8:	2000      	movs	r0, #0
 8004cca:	e014      	b.n	8004cf6 <xQueueGiveFromISR+0x86>
			const int8_t cTxLock = pxQueue->cTxLock;
 8004ccc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004cd0:	3201      	adds	r2, #1
			const int8_t cTxLock = pxQueue->cTxLock;
 8004cd2:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004cd4:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8004cd6:	1c5a      	adds	r2, r3, #1
 8004cd8:	d110      	bne.n	8004cfc <xQueueGiveFromISR+0x8c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004cda:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004cdc:	b90b      	cbnz	r3, 8004ce2 <xQueueGiveFromISR+0x72>
			xReturn = pdPASS;
 8004cde:	2001      	movs	r0, #1
 8004ce0:	e009      	b.n	8004cf6 <xQueueGiveFromISR+0x86>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004ce2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004ce6:	f000 fd13 	bl	8005710 <xTaskRemoveFromEventList>
 8004cea:	2800      	cmp	r0, #0
 8004cec:	d0f7      	beq.n	8004cde <xQueueGiveFromISR+0x6e>
							if( pxHigherPriorityTaskWoken != NULL )
 8004cee:	2d00      	cmp	r5, #0
 8004cf0:	d0f5      	beq.n	8004cde <xQueueGiveFromISR+0x6e>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8004cf2:	2001      	movs	r0, #1
 8004cf4:	6028      	str	r0, [r5, #0]
	__asm volatile
 8004cf6:	f386 8811 	msr	BASEPRI, r6
}
 8004cfa:	bd70      	pop	{r4, r5, r6, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8004cfc:	3301      	adds	r3, #1
 8004cfe:	b25b      	sxtb	r3, r3
 8004d00:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8004d04:	e7eb      	b.n	8004cde <xQueueGiveFromISR+0x6e>
	__asm volatile
 8004d06:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d0a:	f383 8811 	msr	BASEPRI, r3
 8004d0e:	f3bf 8f6f 	isb	sy
 8004d12:	f3bf 8f4f 	dsb	sy
 8004d16:	e7fe      	b.n	8004d16 <xQueueGiveFromISR+0xa6>

08004d18 <xQueueGenericReceive>:
{
 8004d18:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004d1c:	4688      	mov	r8, r1
 8004d1e:	9201      	str	r2, [sp, #4]
 8004d20:	4699      	mov	r9, r3
	configASSERT( pxQueue );
 8004d22:	4604      	mov	r4, r0
 8004d24:	b940      	cbnz	r0, 8004d38 <xQueueGenericReceive+0x20>
 8004d26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d2a:	f383 8811 	msr	BASEPRI, r3
 8004d2e:	f3bf 8f6f 	isb	sy
 8004d32:	f3bf 8f4f 	dsb	sy
 8004d36:	e7fe      	b.n	8004d36 <xQueueGenericReceive+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004d38:	2900      	cmp	r1, #0
 8004d3a:	f040 80a5 	bne.w	8004e88 <xQueueGenericReceive+0x170>
 8004d3e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004d40:	2b00      	cmp	r3, #0
 8004d42:	f000 80a1 	beq.w	8004e88 <xQueueGenericReceive+0x170>
 8004d46:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d4a:	f383 8811 	msr	BASEPRI, r3
 8004d4e:	f3bf 8f6f 	isb	sy
 8004d52:	f3bf 8f4f 	dsb	sy
 8004d56:	e7fe      	b.n	8004d56 <xQueueGenericReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004d58:	9e01      	ldr	r6, [sp, #4]
 8004d5a:	2e00      	cmp	r6, #0
 8004d5c:	f000 809a 	beq.w	8004e94 <xQueueGenericReceive+0x17c>
 8004d60:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004d64:	f383 8811 	msr	BASEPRI, r3
 8004d68:	f3bf 8f6f 	isb	sy
 8004d6c:	f3bf 8f4f 	dsb	sy
 8004d70:	e7fe      	b.n	8004d70 <xQueueGenericReceive+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004d72:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8004d74:	60e6      	str	r6, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004d76:	2b00      	cmp	r3, #0
 8004d78:	d06d      	beq.n	8004e56 <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004d7a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004d7e:	e05f      	b.n	8004e40 <xQueueGenericReceive+0x128>
				if( xTicksToWait == ( TickType_t ) 0 )
 8004d80:	9d01      	ldr	r5, [sp, #4]
 8004d82:	b91d      	cbnz	r5, 8004d8c <xQueueGenericReceive+0x74>
					taskEXIT_CRITICAL();
 8004d84:	f7ff faf0 	bl	8004368 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8004d88:	4628      	mov	r0, r5
 8004d8a:	e067      	b.n	8004e5c <xQueueGenericReceive+0x144>
				else if( xEntryTimeSet == pdFALSE )
 8004d8c:	b916      	cbnz	r6, 8004d94 <xQueueGenericReceive+0x7c>
					vTaskSetTimeOutState( &xTimeOut );
 8004d8e:	a802      	add	r0, sp, #8
 8004d90:	f000 fd00 	bl	8005794 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8004d94:	f7ff fae8 	bl	8004368 <vPortExitCritical>
		vTaskSuspendAll();
 8004d98:	f000 fad4 	bl	8005344 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004d9c:	f7ff fac2 	bl	8004324 <vPortEnterCritical>
 8004da0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004da4:	2bff      	cmp	r3, #255	; 0xff
 8004da6:	bf08      	it	eq
 8004da8:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8004dac:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004db0:	2bff      	cmp	r3, #255	; 0xff
 8004db2:	bf08      	it	eq
 8004db4:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 8004db8:	f7ff fad6 	bl	8004368 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004dbc:	a901      	add	r1, sp, #4
 8004dbe:	a802      	add	r0, sp, #8
 8004dc0:	f000 fcf8 	bl	80057b4 <xTaskCheckForTimeOut>
 8004dc4:	2800      	cmp	r0, #0
 8004dc6:	d152      	bne.n	8004e6e <xQueueGenericReceive+0x156>
	taskENTER_CRITICAL();
 8004dc8:	f7ff faac 	bl	8004324 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8004dcc:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8004dce:	f7ff facb 	bl	8004368 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004dd2:	2d00      	cmp	r5, #0
 8004dd4:	d145      	bne.n	8004e62 <xQueueGenericReceive+0x14a>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004dd6:	6823      	ldr	r3, [r4, #0]
 8004dd8:	b933      	cbnz	r3, 8004de8 <xQueueGenericReceive+0xd0>
						taskENTER_CRITICAL();
 8004dda:	f7ff faa3 	bl	8004324 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8004dde:	6860      	ldr	r0, [r4, #4]
 8004de0:	f000 fd38 	bl	8005854 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8004de4:	f7ff fac0 	bl	8004368 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004de8:	9901      	ldr	r1, [sp, #4]
 8004dea:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004dee:	f000 fc57 	bl	80056a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004df2:	4620      	mov	r0, r4
 8004df4:	f7ff fcfe 	bl	80047f4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004df8:	f000 fb44 	bl	8005484 <xTaskResumeAll>
 8004dfc:	b938      	cbnz	r0, 8004e0e <xQueueGenericReceive+0xf6>
					portYIELD_WITHIN_API();
 8004dfe:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8004e02:	f8ca 3000 	str.w	r3, [sl]
 8004e06:	f3bf 8f4f 	dsb	sy
 8004e0a:	f3bf 8f6f 	isb	sy
 8004e0e:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8004e10:	f7ff fa88 	bl	8004324 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004e14:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004e16:	2d00      	cmp	r5, #0
 8004e18:	d0b2      	beq.n	8004d80 <xQueueGenericReceive+0x68>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004e1a:	4641      	mov	r1, r8
 8004e1c:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8004e1e:	68e6      	ldr	r6, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004e20:	f7ff fcd3 	bl	80047ca <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8004e24:	f1b9 0f00 	cmp.w	r9, #0
 8004e28:	d1a3      	bne.n	8004d72 <xQueueGenericReceive+0x5a>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004e2a:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8004e2c:	3d01      	subs	r5, #1
 8004e2e:	63a5      	str	r5, [r4, #56]	; 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004e30:	b913      	cbnz	r3, 8004e38 <xQueueGenericReceive+0x120>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8004e32:	f000 fda5 	bl	8005980 <pvTaskIncrementMutexHeldCount>
 8004e36:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004e38:	6923      	ldr	r3, [r4, #16]
 8004e3a:	b163      	cbz	r3, 8004e56 <xQueueGenericReceive+0x13e>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004e3c:	f104 0010 	add.w	r0, r4, #16
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004e40:	f000 fc66 	bl	8005710 <xTaskRemoveFromEventList>
 8004e44:	b138      	cbz	r0, 8004e56 <xQueueGenericReceive+0x13e>
							queueYIELD_IF_USING_PREEMPTION();
 8004e46:	4b15      	ldr	r3, [pc, #84]	; (8004e9c <xQueueGenericReceive+0x184>)
 8004e48:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004e4c:	601a      	str	r2, [r3, #0]
 8004e4e:	f3bf 8f4f 	dsb	sy
 8004e52:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8004e56:	f7ff fa87 	bl	8004368 <vPortExitCritical>
				return pdPASS;
 8004e5a:	2001      	movs	r0, #1
}
 8004e5c:	b004      	add	sp, #16
 8004e5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 8004e62:	4620      	mov	r0, r4
 8004e64:	f7ff fcc6 	bl	80047f4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004e68:	f000 fb0c 	bl	8005484 <xTaskResumeAll>
 8004e6c:	e7cf      	b.n	8004e0e <xQueueGenericReceive+0xf6>
			prvUnlockQueue( pxQueue );
 8004e6e:	4620      	mov	r0, r4
 8004e70:	f7ff fcc0 	bl	80047f4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004e74:	f000 fb06 	bl	8005484 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8004e78:	f7ff fa54 	bl	8004324 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8004e7c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8004e7e:	f7ff fa73 	bl	8004368 <vPortExitCritical>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004e82:	2d00      	cmp	r5, #0
 8004e84:	d1c3      	bne.n	8004e0e <xQueueGenericReceive+0xf6>
 8004e86:	e77f      	b.n	8004d88 <xQueueGenericReceive+0x70>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8004e88:	f000 fcd4 	bl	8005834 <xTaskGetSchedulerState>
 8004e8c:	2800      	cmp	r0, #0
 8004e8e:	f43f af63 	beq.w	8004d58 <xQueueGenericReceive+0x40>
 8004e92:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8004e94:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 8004e96:	f8df a004 	ldr.w	sl, [pc, #4]	; 8004e9c <xQueueGenericReceive+0x184>
 8004e9a:	e7b9      	b.n	8004e10 <xQueueGenericReceive+0xf8>
 8004e9c:	e000ed04 	.word	0xe000ed04

08004ea0 <xQueueReceiveFromISR>:
{
 8004ea0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004ea4:	4689      	mov	r9, r1
 8004ea6:	4690      	mov	r8, r2
	configASSERT( pxQueue );
 8004ea8:	4605      	mov	r5, r0
 8004eaa:	b940      	cbnz	r0, 8004ebe <xQueueReceiveFromISR+0x1e>
 8004eac:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004eb0:	f383 8811 	msr	BASEPRI, r3
 8004eb4:	f3bf 8f6f 	isb	sy
 8004eb8:	f3bf 8f4f 	dsb	sy
 8004ebc:	e7fe      	b.n	8004ebc <xQueueReceiveFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004ebe:	bb71      	cbnz	r1, 8004f1e <xQueueReceiveFromISR+0x7e>
 8004ec0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004ec2:	b363      	cbz	r3, 8004f1e <xQueueReceiveFromISR+0x7e>
 8004ec4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004ec8:	f383 8811 	msr	BASEPRI, r3
 8004ecc:	f3bf 8f6f 	isb	sy
 8004ed0:	f3bf 8f4f 	dsb	sy
 8004ed4:	e7fe      	b.n	8004ed4 <xQueueReceiveFromISR+0x34>
			const int8_t cRxLock = pxQueue->cRxLock;
 8004ed6:	f895 6044 	ldrb.w	r6, [r5, #68]	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004eda:	4649      	mov	r1, r9
			const int8_t cRxLock = pxQueue->cRxLock;
 8004edc:	b276      	sxtb	r6, r6
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8004ede:	4628      	mov	r0, r5
 8004ee0:	f7ff fc73 	bl	80047ca <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8004ee4:	3c01      	subs	r4, #1
			if( cRxLock == queueUNLOCKED )
 8004ee6:	1c73      	adds	r3, r6, #1
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8004ee8:	63ac      	str	r4, [r5, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 8004eea:	d113      	bne.n	8004f14 <xQueueReceiveFromISR+0x74>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004eec:	692b      	ldr	r3, [r5, #16]
 8004eee:	b90b      	cbnz	r3, 8004ef4 <xQueueReceiveFromISR+0x54>
			xReturn = pdPASS;
 8004ef0:	2001      	movs	r0, #1
 8004ef2:	e00b      	b.n	8004f0c <xQueueReceiveFromISR+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004ef4:	f105 0010 	add.w	r0, r5, #16
 8004ef8:	f000 fc0a 	bl	8005710 <xTaskRemoveFromEventList>
 8004efc:	2800      	cmp	r0, #0
 8004efe:	d0f7      	beq.n	8004ef0 <xQueueReceiveFromISR+0x50>
						if( pxHigherPriorityTaskWoken != NULL )
 8004f00:	f1b8 0f00 	cmp.w	r8, #0
 8004f04:	d0f4      	beq.n	8004ef0 <xQueueReceiveFromISR+0x50>
							*pxHigherPriorityTaskWoken = pdTRUE;
 8004f06:	2001      	movs	r0, #1
 8004f08:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile
 8004f0c:	f387 8811 	msr	BASEPRI, r7
}
 8004f10:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 8004f14:	3601      	adds	r6, #1
 8004f16:	b276      	sxtb	r6, r6
 8004f18:	f885 6044 	strb.w	r6, [r5, #68]	; 0x44
 8004f1c:	e7e8      	b.n	8004ef0 <xQueueReceiveFromISR+0x50>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8004f1e:	f7ff fb09 	bl	8004534 <vPortValidateInterruptPriority>
	__asm volatile
 8004f22:	f3ef 8711 	mrs	r7, BASEPRI
 8004f26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004f2a:	f383 8811 	msr	BASEPRI, r3
 8004f2e:	f3bf 8f6f 	isb	sy
 8004f32:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004f36:	6bac      	ldr	r4, [r5, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004f38:	2c00      	cmp	r4, #0
 8004f3a:	d1cc      	bne.n	8004ed6 <xQueueReceiveFromISR+0x36>
			xReturn = pdFAIL;
 8004f3c:	4620      	mov	r0, r4
 8004f3e:	e7e5      	b.n	8004f0c <xQueueReceiveFromISR+0x6c>

08004f40 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8004f40:	b530      	push	{r4, r5, lr}

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8004f42:	4a07      	ldr	r2, [pc, #28]	; (8004f60 <vQueueAddToRegistry+0x20>)
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004f44:	2300      	movs	r3, #0
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8004f46:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 8004f4a:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
 8004f4e:	b91d      	cbnz	r5, 8004f58 <vQueueAddToRegistry+0x18>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8004f50:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8004f54:	6060      	str	r0, [r4, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 8004f56:	bd30      	pop	{r4, r5, pc}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004f58:	3301      	adds	r3, #1
 8004f5a:	2b08      	cmp	r3, #8
 8004f5c:	d1f3      	bne.n	8004f46 <vQueueAddToRegistry+0x6>
 8004f5e:	bd30      	pop	{r4, r5, pc}
 8004f60:	20002114 	.word	0x20002114

08004f64 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8004f64:	b570      	push	{r4, r5, r6, lr}
 8004f66:	4604      	mov	r4, r0
 8004f68:	460d      	mov	r5, r1
 8004f6a:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8004f6c:	f7ff f9da 	bl	8004324 <vPortEnterCritical>
 8004f70:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004f74:	2bff      	cmp	r3, #255	; 0xff
 8004f76:	bf04      	itt	eq
 8004f78:	2300      	moveq	r3, #0
 8004f7a:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8004f7e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8004f82:	2bff      	cmp	r3, #255	; 0xff
 8004f84:	bf04      	itt	eq
 8004f86:	2300      	moveq	r3, #0
 8004f88:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8004f8c:	f7ff f9ec 	bl	8004368 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8004f90:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004f92:	b92b      	cbnz	r3, 8004fa0 <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8004f94:	4632      	mov	r2, r6
 8004f96:	4629      	mov	r1, r5
 8004f98:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004f9c:	f000 fb9a 	bl	80056d4 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8004fa0:	4620      	mov	r0, r4
	}
 8004fa2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 8004fa6:	f7ff bc25 	b.w	80047f4 <prvUnlockQueue>
	...

08004fac <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8004fac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004fb0:	4606      	mov	r6, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8004fb2:	f7ff f9b7 	bl	8004324 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8004fb6:	4b2d      	ldr	r3, [pc, #180]	; (800506c <prvAddNewTaskToReadyList+0xc0>)
		if( pxCurrentTCB == NULL )
 8004fb8:	4c2d      	ldr	r4, [pc, #180]	; (8005070 <prvAddNewTaskToReadyList+0xc4>)
		uxCurrentNumberOfTasks++;
 8004fba:	681a      	ldr	r2, [r3, #0]
 8004fbc:	4f2d      	ldr	r7, [pc, #180]	; (8005074 <prvAddNewTaskToReadyList+0xc8>)
 8004fbe:	3201      	adds	r2, #1
 8004fc0:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8004fc2:	6825      	ldr	r5, [r4, #0]
 8004fc4:	2d00      	cmp	r5, #0
 8004fc6:	d145      	bne.n	8005054 <prvAddNewTaskToReadyList+0xa8>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 8004fc8:	6026      	str	r6, [r4, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8004fca:	681b      	ldr	r3, [r3, #0]
 8004fcc:	2b01      	cmp	r3, #1
 8004fce:	d11c      	bne.n	800500a <prvAddNewTaskToReadyList+0x5e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8004fd0:	1978      	adds	r0, r7, r5
 8004fd2:	3514      	adds	r5, #20
 8004fd4:	f7ff f904 	bl	80041e0 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8004fd8:	2d8c      	cmp	r5, #140	; 0x8c
 8004fda:	d1f9      	bne.n	8004fd0 <prvAddNewTaskToReadyList+0x24>
	}

	vListInitialise( &xDelayedTaskList1 );
 8004fdc:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 80050a0 <prvAddNewTaskToReadyList+0xf4>
	vListInitialise( &xDelayedTaskList2 );
 8004fe0:	4d25      	ldr	r5, [pc, #148]	; (8005078 <prvAddNewTaskToReadyList+0xcc>)
	vListInitialise( &xDelayedTaskList1 );
 8004fe2:	4640      	mov	r0, r8
 8004fe4:	f7ff f8fc 	bl	80041e0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8004fe8:	4628      	mov	r0, r5
 8004fea:	f7ff f8f9 	bl	80041e0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8004fee:	4823      	ldr	r0, [pc, #140]	; (800507c <prvAddNewTaskToReadyList+0xd0>)
 8004ff0:	f7ff f8f6 	bl	80041e0 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8004ff4:	4822      	ldr	r0, [pc, #136]	; (8005080 <prvAddNewTaskToReadyList+0xd4>)
 8004ff6:	f7ff f8f3 	bl	80041e0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8004ffa:	4822      	ldr	r0, [pc, #136]	; (8005084 <prvAddNewTaskToReadyList+0xd8>)
 8004ffc:	f7ff f8f0 	bl	80041e0 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8005000:	4b21      	ldr	r3, [pc, #132]	; (8005088 <prvAddNewTaskToReadyList+0xdc>)
 8005002:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8005006:	4b21      	ldr	r3, [pc, #132]	; (800508c <prvAddNewTaskToReadyList+0xe0>)
 8005008:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 800500a:	4a21      	ldr	r2, [pc, #132]	; (8005090 <prvAddNewTaskToReadyList+0xe4>)
		prvAddTaskToReadyList( pxNewTCB );
 800500c:	4921      	ldr	r1, [pc, #132]	; (8005094 <prvAddNewTaskToReadyList+0xe8>)
		uxTaskNumber++;
 800500e:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8005010:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8005012:	3301      	adds	r3, #1
 8005014:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8005016:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8005018:	2301      	movs	r3, #1
 800501a:	4093      	lsls	r3, r2
 800501c:	4303      	orrs	r3, r0
 800501e:	2014      	movs	r0, #20
 8005020:	600b      	str	r3, [r1, #0]
 8005022:	fb00 7002 	mla	r0, r0, r2, r7
 8005026:	1d31      	adds	r1, r6, #4
 8005028:	f7ff f8e8 	bl	80041fc <vListInsertEnd>
	taskEXIT_CRITICAL();
 800502c:	f7ff f99c 	bl	8004368 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8005030:	4b19      	ldr	r3, [pc, #100]	; (8005098 <prvAddNewTaskToReadyList+0xec>)
 8005032:	681b      	ldr	r3, [r3, #0]
 8005034:	b163      	cbz	r3, 8005050 <prvAddNewTaskToReadyList+0xa4>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8005036:	6823      	ldr	r3, [r4, #0]
 8005038:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800503a:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800503c:	429a      	cmp	r2, r3
 800503e:	d207      	bcs.n	8005050 <prvAddNewTaskToReadyList+0xa4>
			taskYIELD_IF_USING_PREEMPTION();
 8005040:	4b16      	ldr	r3, [pc, #88]	; (800509c <prvAddNewTaskToReadyList+0xf0>)
 8005042:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005046:	601a      	str	r2, [r3, #0]
 8005048:	f3bf 8f4f 	dsb	sy
 800504c:	f3bf 8f6f 	isb	sy
 8005050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( xSchedulerRunning == pdFALSE )
 8005054:	4b10      	ldr	r3, [pc, #64]	; (8005098 <prvAddNewTaskToReadyList+0xec>)
 8005056:	681b      	ldr	r3, [r3, #0]
 8005058:	2b00      	cmp	r3, #0
 800505a:	d1d6      	bne.n	800500a <prvAddNewTaskToReadyList+0x5e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800505c:	6823      	ldr	r3, [r4, #0]
 800505e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005060:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8005062:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8005064:	bf98      	it	ls
 8005066:	6026      	strls	r6, [r4, #0]
 8005068:	e7cf      	b.n	800500a <prvAddNewTaskToReadyList+0x5e>
 800506a:	bf00      	nop
 800506c:	200012a8 	.word	0x200012a8
 8005070:	20001210 	.word	0x20001210
 8005074:	2000121c 	.word	0x2000121c
 8005078:	200012d4 	.word	0x200012d4
 800507c:	200012f0 	.word	0x200012f0
 8005080:	2000131c 	.word	0x2000131c
 8005084:	20001308 	.word	0x20001308
 8005088:	20001214 	.word	0x20001214
 800508c:	20001218 	.word	0x20001218
 8005090:	200012b8 	.word	0x200012b8
 8005094:	200012bc 	.word	0x200012bc
 8005098:	20001304 	.word	0x20001304
 800509c:	e000ed04 	.word	0xe000ed04
 80050a0:	200012c0 	.word	0x200012c0

080050a4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80050a4:	4a06      	ldr	r2, [pc, #24]	; (80050c0 <prvResetNextTaskUnblockTime+0x1c>)
 80050a6:	6813      	ldr	r3, [r2, #0]
 80050a8:	6819      	ldr	r1, [r3, #0]
 80050aa:	4b06      	ldr	r3, [pc, #24]	; (80050c4 <prvResetNextTaskUnblockTime+0x20>)
 80050ac:	b919      	cbnz	r1, 80050b6 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 80050ae:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80050b2:	601a      	str	r2, [r3, #0]
 80050b4:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80050b6:	6812      	ldr	r2, [r2, #0]
 80050b8:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80050ba:	68d2      	ldr	r2, [r2, #12]
 80050bc:	6852      	ldr	r2, [r2, #4]
 80050be:	e7f8      	b.n	80050b2 <prvResetNextTaskUnblockTime+0xe>
 80050c0:	20001214 	.word	0x20001214
 80050c4:	200012e8 	.word	0x200012e8

080050c8 <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 80050c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80050cc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80050ce:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80050d2:	6b26      	ldr	r6, [r4, #48]	; 0x30
 80050d4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80050d8:	3a01      	subs	r2, #1
 80050da:	eb06 0682 	add.w	r6, r6, r2, lsl #2
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 80050de:	469a      	mov	sl, r3
 80050e0:	4681      	mov	r9, r0
 80050e2:	1e4b      	subs	r3, r1, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80050e4:	f026 0607 	bic.w	r6, r6, #7
 80050e8:	f104 0234 	add.w	r2, r4, #52	; 0x34
 80050ec:	310f      	adds	r1, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80050ee:	7858      	ldrb	r0, [r3, #1]
 80050f0:	f802 0b01 	strb.w	r0, [r2], #1
		if( pcName[ x ] == 0x00 )
 80050f4:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 80050f8:	b108      	cbz	r0, 80050fe <prvInitialiseNewTask.isra.2+0x36>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80050fa:	428b      	cmp	r3, r1
 80050fc:	d1f7      	bne.n	80050ee <prvInitialiseNewTask.isra.2+0x26>
 80050fe:	9d08      	ldr	r5, [sp, #32]
 8005100:	2d06      	cmp	r5, #6
 8005102:	bf28      	it	cs
 8005104:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8005106:	2700      	movs	r7, #0
	pxNewTCB->uxPriority = uxPriority;
 8005108:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 800510a:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800510c:	1d20      	adds	r0, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800510e:	f884 7043 	strb.w	r7, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8005112:	64a7      	str	r7, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8005114:	f7ff f86f 	bl	80041f6 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005118:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800511c:	f104 0018 	add.w	r0, r4, #24
 8005120:	f7ff f869 	bl	80041f6 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8005124:	64e7      	str	r7, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8005126:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005128:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800512a:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800512c:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8005130:	4652      	mov	r2, sl
 8005132:	4649      	mov	r1, r9
 8005134:	4630      	mov	r0, r6
 8005136:	f7ff f8c7 	bl	80042c8 <pxPortInitialiseStack>
 800513a:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800513c:	f1b8 0f00 	cmp.w	r8, #0
 8005140:	d001      	beq.n	8005146 <prvInitialiseNewTask.isra.2+0x7e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8005142:	f8c8 4000 	str.w	r4, [r8]
 8005146:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800514a <prvDeleteTCB>:
	{
 800514a:	b510      	push	{r4, lr}
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800514c:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
	{
 8005150:	4604      	mov	r4, r0
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8005152:	b93b      	cbnz	r3, 8005164 <prvDeleteTCB+0x1a>
				vPortFree( pxTCB->pxStack );
 8005154:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8005156:	f7ff facd 	bl	80046f4 <vPortFree>
				vPortFree( pxTCB );
 800515a:	4620      	mov	r0, r4
	}
 800515c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
 8005160:	f7ff bac8 	b.w	80046f4 <vPortFree>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8005164:	2b01      	cmp	r3, #1
 8005166:	d0f9      	beq.n	800515c <prvDeleteTCB+0x12>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
 8005168:	2b02      	cmp	r3, #2
 800516a:	d008      	beq.n	800517e <prvDeleteTCB+0x34>
	__asm volatile
 800516c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005170:	f383 8811 	msr	BASEPRI, r3
 8005174:	f3bf 8f6f 	isb	sy
 8005178:	f3bf 8f4f 	dsb	sy
 800517c:	e7fe      	b.n	800517c <prvDeleteTCB+0x32>
 800517e:	bd10      	pop	{r4, pc}

08005180 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8005180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8005182:	4b1b      	ldr	r3, [pc, #108]	; (80051f0 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005184:	4e1b      	ldr	r6, [pc, #108]	; (80051f4 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8005186:	681d      	ldr	r5, [r3, #0]
{
 8005188:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800518a:	6830      	ldr	r0, [r6, #0]
 800518c:	3004      	adds	r0, #4
{
 800518e:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005190:	f7ff f857 	bl	8004242 <uxListRemove>
 8005194:	4633      	mov	r3, r6
 8005196:	b940      	cbnz	r0, 80051aa <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8005198:	6831      	ldr	r1, [r6, #0]
 800519a:	4e17      	ldr	r6, [pc, #92]	; (80051f8 <prvAddCurrentTaskToDelayedList+0x78>)
 800519c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800519e:	6832      	ldr	r2, [r6, #0]
 80051a0:	2001      	movs	r0, #1
 80051a2:	4088      	lsls	r0, r1
 80051a4:	ea22 0200 	bic.w	r2, r2, r0
 80051a8:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80051aa:	1c62      	adds	r2, r4, #1
 80051ac:	d107      	bne.n	80051be <prvAddCurrentTaskToDelayedList+0x3e>
 80051ae:	b137      	cbz	r7, 80051be <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051b0:	6819      	ldr	r1, [r3, #0]
 80051b2:	4812      	ldr	r0, [pc, #72]	; (80051fc <prvAddCurrentTaskToDelayedList+0x7c>)
 80051b4:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80051b6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051ba:	f7ff b81f 	b.w	80041fc <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 80051be:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80051c0:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 80051c2:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80051c4:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 80051c6:	d907      	bls.n	80051d8 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051c8:	4a0d      	ldr	r2, [pc, #52]	; (8005200 <prvAddCurrentTaskToDelayedList+0x80>)
 80051ca:	6810      	ldr	r0, [r2, #0]
 80051cc:	6819      	ldr	r1, [r3, #0]
}
 80051ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051d2:	3104      	adds	r1, #4
 80051d4:	f7ff b81e 	b.w	8004214 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80051d8:	4a0a      	ldr	r2, [pc, #40]	; (8005204 <prvAddCurrentTaskToDelayedList+0x84>)
 80051da:	6810      	ldr	r0, [r2, #0]
 80051dc:	6819      	ldr	r1, [r3, #0]
 80051de:	3104      	adds	r1, #4
 80051e0:	f7ff f818 	bl	8004214 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80051e4:	4b08      	ldr	r3, [pc, #32]	; (8005208 <prvAddCurrentTaskToDelayedList+0x88>)
 80051e6:	681a      	ldr	r2, [r3, #0]
 80051e8:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 80051ea:	bf38      	it	cc
 80051ec:	601c      	strcc	r4, [r3, #0]
 80051ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80051f0:	20001330 	.word	0x20001330
 80051f4:	20001210 	.word	0x20001210
 80051f8:	200012bc 	.word	0x200012bc
 80051fc:	20001308 	.word	0x20001308
 8005200:	20001218 	.word	0x20001218
 8005204:	20001214 	.word	0x20001214
 8005208:	200012e8 	.word	0x200012e8

0800520c <prvTaskIsTaskSuspended.part.0>:
 800520c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005210:	f383 8811 	msr	BASEPRI, r3
 8005214:	f3bf 8f6f 	isb	sy
 8005218:	f3bf 8f4f 	dsb	sy
 800521c:	e7fe      	b.n	800521c <prvTaskIsTaskSuspended.part.0+0x10>

0800521e <xTaskCreateStatic>:
	{
 800521e:	b530      	push	{r4, r5, lr}
 8005220:	b087      	sub	sp, #28
 8005222:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8005224:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		configASSERT( puxStackBuffer != NULL );
 8005226:	b90d      	cbnz	r5, 800522c <xTaskCreateStatic+0xe>
 8005228:	f7ff fff0 	bl	800520c <prvTaskIsTaskSuspended.part.0>
		configASSERT( pxTaskBuffer != NULL );
 800522c:	b944      	cbnz	r4, 8005240 <xTaskCreateStatic+0x22>
 800522e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005232:	f383 8811 	msr	BASEPRI, r3
 8005236:	f3bf 8f6f 	isb	sy
 800523a:	f3bf 8f4f 	dsb	sy
 800523e:	e7fe      	b.n	800523e <xTaskCreateStatic+0x20>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8005240:	6325      	str	r5, [r4, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8005242:	2502      	movs	r5, #2
 8005244:	f884 5051 	strb.w	r5, [r4, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8005248:	ad05      	add	r5, sp, #20
 800524a:	9501      	str	r5, [sp, #4]
 800524c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800524e:	9402      	str	r4, [sp, #8]
 8005250:	9500      	str	r5, [sp, #0]
 8005252:	f7ff ff39 	bl	80050c8 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8005256:	4620      	mov	r0, r4
 8005258:	f7ff fea8 	bl	8004fac <prvAddNewTaskToReadyList>
	}
 800525c:	9805      	ldr	r0, [sp, #20]
 800525e:	b007      	add	sp, #28
 8005260:	bd30      	pop	{r4, r5, pc}

08005262 <xTaskCreate>:
	{
 8005262:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005266:	4607      	mov	r7, r0
 8005268:	b085      	sub	sp, #20
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800526a:	0090      	lsls	r0, r2, #2
	{
 800526c:	4688      	mov	r8, r1
 800526e:	4616      	mov	r6, r2
 8005270:	4699      	mov	r9, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005272:	f7ff f9b1 	bl	80045d8 <pvPortMalloc>
			if( pxStack != NULL )
 8005276:	4605      	mov	r5, r0
 8005278:	b1e8      	cbz	r0, 80052b6 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800527a:	2054      	movs	r0, #84	; 0x54
 800527c:	f7ff f9ac 	bl	80045d8 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8005280:	4604      	mov	r4, r0
 8005282:	b1a8      	cbz	r0, 80052b0 <xTaskCreate+0x4e>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8005284:	2300      	movs	r3, #0
 8005286:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800528a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
					pxNewTCB->pxStack = pxStack;
 800528c:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800528e:	9301      	str	r3, [sp, #4]
 8005290:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8005292:	9002      	str	r0, [sp, #8]
 8005294:	9300      	str	r3, [sp, #0]
 8005296:	4632      	mov	r2, r6
 8005298:	464b      	mov	r3, r9
 800529a:	4641      	mov	r1, r8
 800529c:	4638      	mov	r0, r7
 800529e:	f7ff ff13 	bl	80050c8 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 80052a2:	4620      	mov	r0, r4
 80052a4:	f7ff fe82 	bl	8004fac <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 80052a8:	2001      	movs	r0, #1
	}
 80052aa:	b005      	add	sp, #20
 80052ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 80052b0:	4628      	mov	r0, r5
 80052b2:	f7ff fa1f 	bl	80046f4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80052b6:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 80052ba:	e7f6      	b.n	80052aa <xTaskCreate+0x48>

080052bc <vTaskStartScheduler>:
{
 80052bc:	b510      	push	{r4, lr}
 80052be:	b088      	sub	sp, #32
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 80052c0:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80052c2:	aa07      	add	r2, sp, #28
 80052c4:	a906      	add	r1, sp, #24
 80052c6:	a805      	add	r0, sp, #20
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 80052c8:	9405      	str	r4, [sp, #20]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 80052ca:	9406      	str	r4, [sp, #24]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80052cc:	f000 ffc6 	bl	800625c <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 80052d0:	9b05      	ldr	r3, [sp, #20]
 80052d2:	9302      	str	r3, [sp, #8]
 80052d4:	9b06      	ldr	r3, [sp, #24]
 80052d6:	9301      	str	r3, [sp, #4]
 80052d8:	9400      	str	r4, [sp, #0]
 80052da:	4623      	mov	r3, r4
 80052dc:	9a07      	ldr	r2, [sp, #28]
 80052de:	4914      	ldr	r1, [pc, #80]	; (8005330 <vTaskStartScheduler+0x74>)
 80052e0:	4814      	ldr	r0, [pc, #80]	; (8005334 <vTaskStartScheduler+0x78>)
 80052e2:	f7ff ff9c 	bl	800521e <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 80052e6:	b9a0      	cbnz	r0, 8005312 <vTaskStartScheduler+0x56>
}
 80052e8:	b008      	add	sp, #32
 80052ea:	bd10      	pop	{r4, pc}
 80052ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 80052f0:	f383 8811 	msr	BASEPRI, r3
 80052f4:	f3bf 8f6f 	isb	sy
 80052f8:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 80052fc:	4b0e      	ldr	r3, [pc, #56]	; (8005338 <vTaskStartScheduler+0x7c>)
 80052fe:	f04f 32ff 	mov.w	r2, #4294967295
 8005302:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8005304:	4b0d      	ldr	r3, [pc, #52]	; (800533c <vTaskStartScheduler+0x80>)
 8005306:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8005308:	4b0d      	ldr	r3, [pc, #52]	; (8005340 <vTaskStartScheduler+0x84>)
 800530a:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 800530c:	f7ff f89c 	bl	8004448 <xPortStartScheduler>
 8005310:	e7ea      	b.n	80052e8 <vTaskStartScheduler+0x2c>
			xReturn = xTimerCreateTimerTask();
 8005312:	f000 fb93 	bl	8005a3c <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8005316:	2801      	cmp	r0, #1
 8005318:	d0e8      	beq.n	80052ec <vTaskStartScheduler+0x30>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800531a:	3001      	adds	r0, #1
 800531c:	d1e4      	bne.n	80052e8 <vTaskStartScheduler+0x2c>
 800531e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005322:	f383 8811 	msr	BASEPRI, r3
 8005326:	f3bf 8f6f 	isb	sy
 800532a:	f3bf 8f4f 	dsb	sy
 800532e:	e7fe      	b.n	800532e <vTaskStartScheduler+0x72>
 8005330:	08007a38 	.word	0x08007a38
 8005334:	080055bd 	.word	0x080055bd
 8005338:	200012e8 	.word	0x200012e8
 800533c:	20001304 	.word	0x20001304
 8005340:	20001330 	.word	0x20001330

08005344 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8005344:	4a02      	ldr	r2, [pc, #8]	; (8005350 <vTaskSuspendAll+0xc>)
 8005346:	6813      	ldr	r3, [r2, #0]
 8005348:	3301      	adds	r3, #1
 800534a:	6013      	str	r3, [r2, #0]
 800534c:	4770      	bx	lr
 800534e:	bf00      	nop
 8005350:	200012b4 	.word	0x200012b4

08005354 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8005354:	4b01      	ldr	r3, [pc, #4]	; (800535c <xTaskGetTickCount+0x8>)
 8005356:	6818      	ldr	r0, [r3, #0]
}
 8005358:	4770      	bx	lr
 800535a:	bf00      	nop
 800535c:	20001330 	.word	0x20001330

08005360 <xTaskIncrementTick>:
{
 8005360:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005364:	4b3c      	ldr	r3, [pc, #240]	; (8005458 <xTaskIncrementTick+0xf8>)
 8005366:	681b      	ldr	r3, [r3, #0]
 8005368:	2b00      	cmp	r3, #0
 800536a:	d153      	bne.n	8005414 <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + 1;
 800536c:	4b3b      	ldr	r3, [pc, #236]	; (800545c <xTaskIncrementTick+0xfc>)
 800536e:	681c      	ldr	r4, [r3, #0]
 8005370:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8005372:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 8005374:	b9bc      	cbnz	r4, 80053a6 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8005376:	4b3a      	ldr	r3, [pc, #232]	; (8005460 <xTaskIncrementTick+0x100>)
 8005378:	681a      	ldr	r2, [r3, #0]
 800537a:	6812      	ldr	r2, [r2, #0]
 800537c:	b142      	cbz	r2, 8005390 <xTaskIncrementTick+0x30>
 800537e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005382:	f383 8811 	msr	BASEPRI, r3
 8005386:	f3bf 8f6f 	isb	sy
 800538a:	f3bf 8f4f 	dsb	sy
 800538e:	e7fe      	b.n	800538e <xTaskIncrementTick+0x2e>
 8005390:	4a34      	ldr	r2, [pc, #208]	; (8005464 <xTaskIncrementTick+0x104>)
 8005392:	6819      	ldr	r1, [r3, #0]
 8005394:	6810      	ldr	r0, [r2, #0]
 8005396:	6018      	str	r0, [r3, #0]
 8005398:	6011      	str	r1, [r2, #0]
 800539a:	4a33      	ldr	r2, [pc, #204]	; (8005468 <xTaskIncrementTick+0x108>)
 800539c:	6813      	ldr	r3, [r2, #0]
 800539e:	3301      	adds	r3, #1
 80053a0:	6013      	str	r3, [r2, #0]
 80053a2:	f7ff fe7f 	bl	80050a4 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80053a6:	4d31      	ldr	r5, [pc, #196]	; (800546c <xTaskIncrementTick+0x10c>)
 80053a8:	4f31      	ldr	r7, [pc, #196]	; (8005470 <xTaskIncrementTick+0x110>)
 80053aa:	682b      	ldr	r3, [r5, #0]
 80053ac:	429c      	cmp	r4, r3
 80053ae:	f04f 0b00 	mov.w	fp, #0
 80053b2:	d33e      	bcc.n	8005432 <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80053b4:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8005460 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 80053b8:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 8005480 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80053bc:	f8d8 2000 	ldr.w	r2, [r8]
 80053c0:	6812      	ldr	r2, [r2, #0]
 80053c2:	bb72      	cbnz	r2, 8005422 <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80053c4:	f04f 32ff 	mov.w	r2, #4294967295
 80053c8:	602a      	str	r2, [r5, #0]
					break;
 80053ca:	e032      	b.n	8005432 <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80053cc:	f106 0a04 	add.w	sl, r6, #4
 80053d0:	4650      	mov	r0, sl
 80053d2:	f7fe ff36 	bl	8004242 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80053d6:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 80053d8:	b119      	cbz	r1, 80053e2 <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80053da:	f106 0018 	add.w	r0, r6, #24
 80053de:	f7fe ff30 	bl	8004242 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80053e2:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80053e4:	f8d9 3000 	ldr.w	r3, [r9]
 80053e8:	2201      	movs	r2, #1
 80053ea:	fa02 f100 	lsl.w	r1, r2, r0
 80053ee:	4319      	orrs	r1, r3
 80053f0:	4b20      	ldr	r3, [pc, #128]	; (8005474 <xTaskIncrementTick+0x114>)
 80053f2:	f8c9 1000 	str.w	r1, [r9]
 80053f6:	f04f 0e14 	mov.w	lr, #20
 80053fa:	4651      	mov	r1, sl
 80053fc:	fb0e 3000 	mla	r0, lr, r0, r3
 8005400:	f7fe fefc 	bl	80041fc <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005404:	6838      	ldr	r0, [r7, #0]
 8005406:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8005408:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800540a:	4291      	cmp	r1, r2
 800540c:	bf28      	it	cs
 800540e:	f04f 0b01 	movcs.w	fp, #1
 8005412:	e7d3      	b.n	80053bc <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8005414:	4a18      	ldr	r2, [pc, #96]	; (8005478 <xTaskIncrementTick+0x118>)
 8005416:	6813      	ldr	r3, [r2, #0]
 8005418:	3301      	adds	r3, #1
 800541a:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800541c:	f04f 0b00 	mov.w	fp, #0
 8005420:	e011      	b.n	8005446 <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8005422:	f8d8 2000 	ldr.w	r2, [r8]
 8005426:	68d2      	ldr	r2, [r2, #12]
 8005428:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800542a:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 800542c:	428c      	cmp	r4, r1
 800542e:	d2cd      	bcs.n	80053cc <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8005430:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8005432:	683a      	ldr	r2, [r7, #0]
 8005434:	4b0f      	ldr	r3, [pc, #60]	; (8005474 <xTaskIncrementTick+0x114>)
 8005436:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8005438:	2214      	movs	r2, #20
 800543a:	434a      	muls	r2, r1
 800543c:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 800543e:	2a02      	cmp	r2, #2
 8005440:	bf28      	it	cs
 8005442:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 8005446:	4a0d      	ldr	r2, [pc, #52]	; (800547c <xTaskIncrementTick+0x11c>)
 8005448:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 800544a:	2a00      	cmp	r2, #0
 800544c:	bf18      	it	ne
 800544e:	f04f 0b01 	movne.w	fp, #1
}
 8005452:	4658      	mov	r0, fp
 8005454:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005458:	200012b4 	.word	0x200012b4
 800545c:	20001330 	.word	0x20001330
 8005460:	20001214 	.word	0x20001214
 8005464:	20001218 	.word	0x20001218
 8005468:	200012ec 	.word	0x200012ec
 800546c:	200012e8 	.word	0x200012e8
 8005470:	20001210 	.word	0x20001210
 8005474:	2000121c 	.word	0x2000121c
 8005478:	200012b0 	.word	0x200012b0
 800547c:	20001334 	.word	0x20001334
 8005480:	200012bc 	.word	0x200012bc

08005484 <xTaskResumeAll>:
{
 8005484:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 8005488:	4c31      	ldr	r4, [pc, #196]	; (8005550 <xTaskResumeAll+0xcc>)
 800548a:	6823      	ldr	r3, [r4, #0]
 800548c:	b943      	cbnz	r3, 80054a0 <xTaskResumeAll+0x1c>
 800548e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005492:	f383 8811 	msr	BASEPRI, r3
 8005496:	f3bf 8f6f 	isb	sy
 800549a:	f3bf 8f4f 	dsb	sy
 800549e:	e7fe      	b.n	800549e <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 80054a0:	f7fe ff40 	bl	8004324 <vPortEnterCritical>
		--uxSchedulerSuspended;
 80054a4:	6823      	ldr	r3, [r4, #0]
 80054a6:	3b01      	subs	r3, #1
 80054a8:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80054aa:	6824      	ldr	r4, [r4, #0]
 80054ac:	b12c      	cbz	r4, 80054ba <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 80054ae:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80054b0:	f7fe ff5a 	bl	8004368 <vPortExitCritical>
}
 80054b4:	4620      	mov	r0, r4
 80054b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80054ba:	4b26      	ldr	r3, [pc, #152]	; (8005554 <xTaskResumeAll+0xd0>)
 80054bc:	681b      	ldr	r3, [r3, #0]
 80054be:	2b00      	cmp	r3, #0
 80054c0:	d0f5      	beq.n	80054ae <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80054c2:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 800556c <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 80054c6:	4f24      	ldr	r7, [pc, #144]	; (8005558 <xTaskResumeAll+0xd4>)
 80054c8:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 8005570 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80054cc:	f8d9 3000 	ldr.w	r3, [r9]
 80054d0:	b9e3      	cbnz	r3, 800550c <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 80054d2:	b10c      	cbz	r4, 80054d8 <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 80054d4:	f7ff fde6 	bl	80050a4 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 80054d8:	4d20      	ldr	r5, [pc, #128]	; (800555c <xTaskResumeAll+0xd8>)
 80054da:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 80054dc:	b144      	cbz	r4, 80054f0 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 80054de:	4e20      	ldr	r6, [pc, #128]	; (8005560 <xTaskResumeAll+0xdc>)
 80054e0:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 80054e2:	f7ff ff3d 	bl	8005360 <xTaskIncrementTick>
 80054e6:	b100      	cbz	r0, 80054ea <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 80054e8:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 80054ea:	3c01      	subs	r4, #1
 80054ec:	d1f9      	bne.n	80054e2 <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 80054ee:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 80054f0:	4b1b      	ldr	r3, [pc, #108]	; (8005560 <xTaskResumeAll+0xdc>)
 80054f2:	681b      	ldr	r3, [r3, #0]
 80054f4:	2b00      	cmp	r3, #0
 80054f6:	d0da      	beq.n	80054ae <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 80054f8:	4b1a      	ldr	r3, [pc, #104]	; (8005564 <xTaskResumeAll+0xe0>)
 80054fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80054fe:	601a      	str	r2, [r3, #0]
 8005500:	f3bf 8f4f 	dsb	sy
 8005504:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8005508:	2401      	movs	r4, #1
 800550a:	e7d1      	b.n	80054b0 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800550c:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8005510:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005512:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8005514:	f104 0018 	add.w	r0, r4, #24
 8005518:	f7fe fe93 	bl	8004242 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800551c:	4630      	mov	r0, r6
 800551e:	f7fe fe90 	bl	8004242 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8005522:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005524:	6839      	ldr	r1, [r7, #0]
 8005526:	2501      	movs	r5, #1
 8005528:	fa05 f302 	lsl.w	r3, r5, r2
 800552c:	2014      	movs	r0, #20
 800552e:	430b      	orrs	r3, r1
 8005530:	fb00 8002 	mla	r0, r0, r2, r8
 8005534:	4631      	mov	r1, r6
 8005536:	603b      	str	r3, [r7, #0]
 8005538:	f7fe fe60 	bl	80041fc <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800553c:	4b0a      	ldr	r3, [pc, #40]	; (8005568 <xTaskResumeAll+0xe4>)
 800553e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005540:	681b      	ldr	r3, [r3, #0]
 8005542:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005544:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 8005546:	bf24      	itt	cs
 8005548:	4b05      	ldrcs	r3, [pc, #20]	; (8005560 <xTaskResumeAll+0xdc>)
 800554a:	601d      	strcs	r5, [r3, #0]
 800554c:	e7be      	b.n	80054cc <xTaskResumeAll+0x48>
 800554e:	bf00      	nop
 8005550:	200012b4 	.word	0x200012b4
 8005554:	200012a8 	.word	0x200012a8
 8005558:	200012bc 	.word	0x200012bc
 800555c:	200012b0 	.word	0x200012b0
 8005560:	20001334 	.word	0x20001334
 8005564:	e000ed04 	.word	0xe000ed04
 8005568:	20001210 	.word	0x20001210
 800556c:	200012f0 	.word	0x200012f0
 8005570:	2000121c 	.word	0x2000121c

08005574 <vTaskDelay>:
	{
 8005574:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8005576:	b940      	cbnz	r0, 800558a <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 8005578:	4b0e      	ldr	r3, [pc, #56]	; (80055b4 <vTaskDelay+0x40>)
 800557a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800557e:	601a      	str	r2, [r3, #0]
 8005580:	f3bf 8f4f 	dsb	sy
 8005584:	f3bf 8f6f 	isb	sy
 8005588:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800558a:	4b0b      	ldr	r3, [pc, #44]	; (80055b8 <vTaskDelay+0x44>)
 800558c:	6819      	ldr	r1, [r3, #0]
 800558e:	b141      	cbz	r1, 80055a2 <vTaskDelay+0x2e>
 8005590:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005594:	f383 8811 	msr	BASEPRI, r3
 8005598:	f3bf 8f6f 	isb	sy
 800559c:	f3bf 8f4f 	dsb	sy
 80055a0:	e7fe      	b.n	80055a0 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 80055a2:	f7ff fecf 	bl	8005344 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80055a6:	f7ff fdeb 	bl	8005180 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80055aa:	f7ff ff6b 	bl	8005484 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80055ae:	2800      	cmp	r0, #0
 80055b0:	d0e2      	beq.n	8005578 <vTaskDelay+0x4>
 80055b2:	bd08      	pop	{r3, pc}
 80055b4:	e000ed04 	.word	0xe000ed04
 80055b8:	200012b4 	.word	0x200012b4

080055bc <prvIdleTask>:
{
 80055bc:	b508      	push	{r3, lr}
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80055be:	4d16      	ldr	r5, [pc, #88]	; (8005618 <prvIdleTask+0x5c>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80055c0:	4c16      	ldr	r4, [pc, #88]	; (800561c <prvIdleTask+0x60>)
 80055c2:	6823      	ldr	r3, [r4, #0]
 80055c4:	b963      	cbnz	r3, 80055e0 <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80055c6:	4b16      	ldr	r3, [pc, #88]	; (8005620 <prvIdleTask+0x64>)
 80055c8:	681b      	ldr	r3, [r3, #0]
 80055ca:	2b01      	cmp	r3, #1
 80055cc:	d9f8      	bls.n	80055c0 <prvIdleTask+0x4>
				taskYIELD();
 80055ce:	4b15      	ldr	r3, [pc, #84]	; (8005624 <prvIdleTask+0x68>)
 80055d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80055d4:	601a      	str	r2, [r3, #0]
 80055d6:	f3bf 8f4f 	dsb	sy
 80055da:	f3bf 8f6f 	isb	sy
 80055de:	e7ef      	b.n	80055c0 <prvIdleTask+0x4>
			vTaskSuspendAll();
 80055e0:	f7ff feb0 	bl	8005344 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80055e4:	682e      	ldr	r6, [r5, #0]
			( void ) xTaskResumeAll();
 80055e6:	f7ff ff4d 	bl	8005484 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 80055ea:	2e00      	cmp	r6, #0
 80055ec:	d0e9      	beq.n	80055c2 <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 80055ee:	f7fe fe99 	bl	8004324 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 80055f2:	68eb      	ldr	r3, [r5, #12]
 80055f4:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80055f6:	1d30      	adds	r0, r6, #4
 80055f8:	f7fe fe23 	bl	8004242 <uxListRemove>
					--uxCurrentNumberOfTasks;
 80055fc:	4a0a      	ldr	r2, [pc, #40]	; (8005628 <prvIdleTask+0x6c>)
 80055fe:	6813      	ldr	r3, [r2, #0]
 8005600:	3b01      	subs	r3, #1
 8005602:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 8005604:	6823      	ldr	r3, [r4, #0]
 8005606:	3b01      	subs	r3, #1
 8005608:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 800560a:	f7fe fead 	bl	8004368 <vPortExitCritical>
				prvDeleteTCB( pxTCB );
 800560e:	4630      	mov	r0, r6
 8005610:	f7ff fd9b 	bl	800514a <prvDeleteTCB>
 8005614:	e7d5      	b.n	80055c2 <prvIdleTask+0x6>
 8005616:	bf00      	nop
 8005618:	2000131c 	.word	0x2000131c
 800561c:	200012ac 	.word	0x200012ac
 8005620:	2000121c 	.word	0x2000121c
 8005624:	e000ed04 	.word	0xe000ed04
 8005628:	200012a8 	.word	0x200012a8

0800562c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800562c:	4b17      	ldr	r3, [pc, #92]	; (800568c <vTaskSwitchContext+0x60>)
 800562e:	681a      	ldr	r2, [r3, #0]
 8005630:	4b17      	ldr	r3, [pc, #92]	; (8005690 <vTaskSwitchContext+0x64>)
{
 8005632:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8005634:	b112      	cbz	r2, 800563c <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8005636:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8005638:	601a      	str	r2, [r3, #0]
 800563a:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 800563c:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800563e:	4b15      	ldr	r3, [pc, #84]	; (8005694 <vTaskSwitchContext+0x68>)
 8005640:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8005642:	fab3 f383 	clz	r3, r3
 8005646:	b2db      	uxtb	r3, r3
 8005648:	f1c3 031f 	rsb	r3, r3, #31
 800564c:	2214      	movs	r2, #20
 800564e:	4912      	ldr	r1, [pc, #72]	; (8005698 <vTaskSwitchContext+0x6c>)
 8005650:	435a      	muls	r2, r3
 8005652:	1888      	adds	r0, r1, r2
 8005654:	588c      	ldr	r4, [r1, r2]
 8005656:	b944      	cbnz	r4, 800566a <vTaskSwitchContext+0x3e>
	__asm volatile
 8005658:	f04f 0350 	mov.w	r3, #80	; 0x50
 800565c:	f383 8811 	msr	BASEPRI, r3
 8005660:	f3bf 8f6f 	isb	sy
 8005664:	f3bf 8f4f 	dsb	sy
 8005668:	e7fe      	b.n	8005668 <vTaskSwitchContext+0x3c>
 800566a:	6844      	ldr	r4, [r0, #4]
 800566c:	3208      	adds	r2, #8
 800566e:	6864      	ldr	r4, [r4, #4]
 8005670:	6044      	str	r4, [r0, #4]
 8005672:	440a      	add	r2, r1
 8005674:	4294      	cmp	r4, r2
 8005676:	bf04      	itt	eq
 8005678:	6862      	ldreq	r2, [r4, #4]
 800567a:	6042      	streq	r2, [r0, #4]
 800567c:	2214      	movs	r2, #20
 800567e:	fb02 1303 	mla	r3, r2, r3, r1
 8005682:	685b      	ldr	r3, [r3, #4]
 8005684:	68da      	ldr	r2, [r3, #12]
 8005686:	4b05      	ldr	r3, [pc, #20]	; (800569c <vTaskSwitchContext+0x70>)
 8005688:	e7d6      	b.n	8005638 <vTaskSwitchContext+0xc>
 800568a:	bf00      	nop
 800568c:	200012b4 	.word	0x200012b4
 8005690:	20001334 	.word	0x20001334
 8005694:	200012bc 	.word	0x200012bc
 8005698:	2000121c 	.word	0x2000121c
 800569c:	20001210 	.word	0x20001210

080056a0 <vTaskPlaceOnEventList>:
{
 80056a0:	b510      	push	{r4, lr}
 80056a2:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 80056a4:	b940      	cbnz	r0, 80056b8 <vTaskPlaceOnEventList+0x18>
 80056a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80056aa:	f383 8811 	msr	BASEPRI, r3
 80056ae:	f3bf 8f6f 	isb	sy
 80056b2:	f3bf 8f4f 	dsb	sy
 80056b6:	e7fe      	b.n	80056b6 <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80056b8:	4b05      	ldr	r3, [pc, #20]	; (80056d0 <vTaskPlaceOnEventList+0x30>)
 80056ba:	6819      	ldr	r1, [r3, #0]
 80056bc:	3118      	adds	r1, #24
 80056be:	f7fe fda9 	bl	8004214 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80056c2:	4620      	mov	r0, r4
 80056c4:	2101      	movs	r1, #1
}
 80056c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80056ca:	f7ff bd59 	b.w	8005180 <prvAddCurrentTaskToDelayedList>
 80056ce:	bf00      	nop
 80056d0:	20001210 	.word	0x20001210

080056d4 <vTaskPlaceOnEventListRestricted>:
	{
 80056d4:	b538      	push	{r3, r4, r5, lr}
 80056d6:	460d      	mov	r5, r1
 80056d8:	4614      	mov	r4, r2
		configASSERT( pxEventList );
 80056da:	b940      	cbnz	r0, 80056ee <vTaskPlaceOnEventListRestricted+0x1a>
 80056dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80056e0:	f383 8811 	msr	BASEPRI, r3
 80056e4:	f3bf 8f6f 	isb	sy
 80056e8:	f3bf 8f4f 	dsb	sy
 80056ec:	e7fe      	b.n	80056ec <vTaskPlaceOnEventListRestricted+0x18>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80056ee:	4b07      	ldr	r3, [pc, #28]	; (800570c <vTaskPlaceOnEventListRestricted+0x38>)
 80056f0:	6819      	ldr	r1, [r3, #0]
 80056f2:	3118      	adds	r1, #24
 80056f4:	f7fe fd82 	bl	80041fc <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 80056f8:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80056fa:	4621      	mov	r1, r4
 80056fc:	bf0c      	ite	eq
 80056fe:	4628      	moveq	r0, r5
 8005700:	f04f 30ff 	movne.w	r0, #4294967295
	}
 8005704:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8005708:	f7ff bd3a 	b.w	8005180 <prvAddCurrentTaskToDelayedList>
 800570c:	20001210 	.word	0x20001210

08005710 <xTaskRemoveFromEventList>:
{
 8005710:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005712:	68c3      	ldr	r3, [r0, #12]
 8005714:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8005716:	b944      	cbnz	r4, 800572a <xTaskRemoveFromEventList+0x1a>
 8005718:	f04f 0350 	mov.w	r3, #80	; 0x50
 800571c:	f383 8811 	msr	BASEPRI, r3
 8005720:	f3bf 8f6f 	isb	sy
 8005724:	f3bf 8f4f 	dsb	sy
 8005728:	e7fe      	b.n	8005728 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800572a:	f104 0518 	add.w	r5, r4, #24
 800572e:	4628      	mov	r0, r5
 8005730:	f7fe fd87 	bl	8004242 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005734:	4b11      	ldr	r3, [pc, #68]	; (800577c <xTaskRemoveFromEventList+0x6c>)
 8005736:	681b      	ldr	r3, [r3, #0]
 8005738:	b9e3      	cbnz	r3, 8005774 <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800573a:	1d25      	adds	r5, r4, #4
 800573c:	4628      	mov	r0, r5
 800573e:	f7fe fd80 	bl	8004242 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8005742:	490f      	ldr	r1, [pc, #60]	; (8005780 <xTaskRemoveFromEventList+0x70>)
 8005744:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005746:	6808      	ldr	r0, [r1, #0]
 8005748:	2301      	movs	r3, #1
 800574a:	4093      	lsls	r3, r2
 800574c:	4303      	orrs	r3, r0
 800574e:	600b      	str	r3, [r1, #0]
 8005750:	4b0c      	ldr	r3, [pc, #48]	; (8005784 <xTaskRemoveFromEventList+0x74>)
 8005752:	2014      	movs	r0, #20
 8005754:	4629      	mov	r1, r5
 8005756:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800575a:	f7fe fd4f 	bl	80041fc <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800575e:	4b0a      	ldr	r3, [pc, #40]	; (8005788 <xTaskRemoveFromEventList+0x78>)
 8005760:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005766:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8005768:	bf83      	ittte	hi
 800576a:	4b08      	ldrhi	r3, [pc, #32]	; (800578c <xTaskRemoveFromEventList+0x7c>)
 800576c:	2001      	movhi	r0, #1
 800576e:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 8005770:	2000      	movls	r0, #0
}
 8005772:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8005774:	4629      	mov	r1, r5
 8005776:	4806      	ldr	r0, [pc, #24]	; (8005790 <xTaskRemoveFromEventList+0x80>)
 8005778:	e7ef      	b.n	800575a <xTaskRemoveFromEventList+0x4a>
 800577a:	bf00      	nop
 800577c:	200012b4 	.word	0x200012b4
 8005780:	200012bc 	.word	0x200012bc
 8005784:	2000121c 	.word	0x2000121c
 8005788:	20001210 	.word	0x20001210
 800578c:	20001334 	.word	0x20001334
 8005790:	200012f0 	.word	0x200012f0

08005794 <vTaskSetTimeOutState>:
{
 8005794:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8005796:	b908      	cbnz	r0, 800579c <vTaskSetTimeOutState+0x8>
 8005798:	f7ff fd38 	bl	800520c <prvTaskIsTaskSuspended.part.0>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800579c:	4b03      	ldr	r3, [pc, #12]	; (80057ac <vTaskSetTimeOutState+0x18>)
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80057a2:	4b03      	ldr	r3, [pc, #12]	; (80057b0 <vTaskSetTimeOutState+0x1c>)
 80057a4:	681b      	ldr	r3, [r3, #0]
 80057a6:	6043      	str	r3, [r0, #4]
 80057a8:	bd08      	pop	{r3, pc}
 80057aa:	bf00      	nop
 80057ac:	200012ec 	.word	0x200012ec
 80057b0:	20001330 	.word	0x20001330

080057b4 <xTaskCheckForTimeOut>:
{
 80057b4:	b538      	push	{r3, r4, r5, lr}
 80057b6:	460d      	mov	r5, r1
	configASSERT( pxTimeOut );
 80057b8:	4604      	mov	r4, r0
 80057ba:	b940      	cbnz	r0, 80057ce <xTaskCheckForTimeOut+0x1a>
 80057bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80057c0:	f383 8811 	msr	BASEPRI, r3
 80057c4:	f3bf 8f6f 	isb	sy
 80057c8:	f3bf 8f4f 	dsb	sy
 80057cc:	e7fe      	b.n	80057cc <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
 80057ce:	b941      	cbnz	r1, 80057e2 <xTaskCheckForTimeOut+0x2e>
 80057d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80057d4:	f383 8811 	msr	BASEPRI, r3
 80057d8:	f3bf 8f6f 	isb	sy
 80057dc:	f3bf 8f4f 	dsb	sy
 80057e0:	e7fe      	b.n	80057e0 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
 80057e2:	f7fe fd9f 	bl	8004324 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 80057e6:	4b0e      	ldr	r3, [pc, #56]	; (8005820 <xTaskCheckForTimeOut+0x6c>)
 80057e8:	6819      	ldr	r1, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 80057ea:	682b      	ldr	r3, [r5, #0]
 80057ec:	1c5a      	adds	r2, r3, #1
 80057ee:	d010      	beq.n	8005812 <xTaskCheckForTimeOut+0x5e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80057f0:	4a0c      	ldr	r2, [pc, #48]	; (8005824 <xTaskCheckForTimeOut+0x70>)
 80057f2:	6820      	ldr	r0, [r4, #0]
 80057f4:	6812      	ldr	r2, [r2, #0]
 80057f6:	4290      	cmp	r0, r2
 80057f8:	6862      	ldr	r2, [r4, #4]
 80057fa:	d001      	beq.n	8005800 <xTaskCheckForTimeOut+0x4c>
 80057fc:	4291      	cmp	r1, r2
 80057fe:	d20d      	bcs.n	800581c <xTaskCheckForTimeOut+0x68>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005800:	1a88      	subs	r0, r1, r2
 8005802:	4283      	cmp	r3, r0
 8005804:	d90a      	bls.n	800581c <xTaskCheckForTimeOut+0x68>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8005806:	1a5b      	subs	r3, r3, r1
 8005808:	4413      	add	r3, r2
 800580a:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800580c:	4620      	mov	r0, r4
 800580e:	f7ff ffc1 	bl	8005794 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 8005812:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8005814:	f7fe fda8 	bl	8004368 <vPortExitCritical>
}
 8005818:	4620      	mov	r0, r4
 800581a:	bd38      	pop	{r3, r4, r5, pc}
			xReturn = pdTRUE;
 800581c:	2401      	movs	r4, #1
 800581e:	e7f9      	b.n	8005814 <xTaskCheckForTimeOut+0x60>
 8005820:	20001330 	.word	0x20001330
 8005824:	200012ec 	.word	0x200012ec

08005828 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8005828:	4b01      	ldr	r3, [pc, #4]	; (8005830 <vTaskMissedYield+0x8>)
 800582a:	2201      	movs	r2, #1
 800582c:	601a      	str	r2, [r3, #0]
 800582e:	4770      	bx	lr
 8005830:	20001334 	.word	0x20001334

08005834 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8005834:	4b05      	ldr	r3, [pc, #20]	; (800584c <xTaskGetSchedulerState+0x18>)
 8005836:	681b      	ldr	r3, [r3, #0]
 8005838:	b133      	cbz	r3, 8005848 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800583a:	4b05      	ldr	r3, [pc, #20]	; (8005850 <xTaskGetSchedulerState+0x1c>)
 800583c:	681b      	ldr	r3, [r3, #0]
 800583e:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8005840:	bf0c      	ite	eq
 8005842:	2002      	moveq	r0, #2
 8005844:	2000      	movne	r0, #0
 8005846:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005848:	2001      	movs	r0, #1
	}
 800584a:	4770      	bx	lr
 800584c:	20001304 	.word	0x20001304
 8005850:	200012b4 	.word	0x200012b4

08005854 <vTaskPriorityInherit>:
	{
 8005854:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 8005858:	4604      	mov	r4, r0
 800585a:	2800      	cmp	r0, #0
 800585c:	d038      	beq.n	80058d0 <vTaskPriorityInherit+0x7c>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 800585e:	4d1d      	ldr	r5, [pc, #116]	; (80058d4 <vTaskPriorityInherit+0x80>)
 8005860:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005862:	682a      	ldr	r2, [r5, #0]
 8005864:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8005866:	4293      	cmp	r3, r2
 8005868:	d232      	bcs.n	80058d0 <vTaskPriorityInherit+0x7c>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800586a:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800586c:	4e1a      	ldr	r6, [pc, #104]	; (80058d8 <vTaskPriorityInherit+0x84>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800586e:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005870:	bfa1      	itttt	ge
 8005872:	682a      	ldrge	r2, [r5, #0]
 8005874:	6ad2      	ldrge	r2, [r2, #44]	; 0x2c
 8005876:	f1c2 0207 	rsbge	r2, r2, #7
 800587a:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800587c:	2714      	movs	r7, #20
 800587e:	6942      	ldr	r2, [r0, #20]
 8005880:	fb07 6303 	mla	r3, r7, r3, r6
 8005884:	429a      	cmp	r2, r3
 8005886:	d120      	bne.n	80058ca <vTaskPriorityInherit+0x76>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005888:	f100 0804 	add.w	r8, r0, #4
 800588c:	4640      	mov	r0, r8
 800588e:	f7fe fcd8 	bl	8004242 <uxListRemove>
 8005892:	4a12      	ldr	r2, [pc, #72]	; (80058dc <vTaskPriorityInherit+0x88>)
 8005894:	b948      	cbnz	r0, 80058aa <vTaskPriorityInherit+0x56>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005896:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005898:	4347      	muls	r7, r0
 800589a:	59f3      	ldr	r3, [r6, r7]
 800589c:	b92b      	cbnz	r3, 80058aa <vTaskPriorityInherit+0x56>
 800589e:	6813      	ldr	r3, [r2, #0]
 80058a0:	2101      	movs	r1, #1
 80058a2:	4081      	lsls	r1, r0
 80058a4:	ea23 0301 	bic.w	r3, r3, r1
 80058a8:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80058aa:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 80058ac:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80058ae:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80058b0:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80058b2:	2301      	movs	r3, #1
 80058b4:	4083      	lsls	r3, r0
 80058b6:	430b      	orrs	r3, r1
 80058b8:	6013      	str	r3, [r2, #0]
 80058ba:	2314      	movs	r3, #20
 80058bc:	4641      	mov	r1, r8
 80058be:	fb03 6000 	mla	r0, r3, r0, r6
	}
 80058c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 80058c6:	f7fe bc99 	b.w	80041fc <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80058ca:	682b      	ldr	r3, [r5, #0]
 80058cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80058ce:	62c3      	str	r3, [r0, #44]	; 0x2c
 80058d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80058d4:	20001210 	.word	0x20001210
 80058d8:	2000121c 	.word	0x2000121c
 80058dc:	200012bc 	.word	0x200012bc

080058e0 <xTaskPriorityDisinherit>:
	{
 80058e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 80058e2:	4604      	mov	r4, r0
 80058e4:	b908      	cbnz	r0, 80058ea <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 80058e6:	2000      	movs	r0, #0
 80058e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 80058ea:	4b22      	ldr	r3, [pc, #136]	; (8005974 <xTaskPriorityDisinherit+0x94>)
 80058ec:	681b      	ldr	r3, [r3, #0]
 80058ee:	4298      	cmp	r0, r3
 80058f0:	d008      	beq.n	8005904 <xTaskPriorityDisinherit+0x24>
 80058f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80058f6:	f383 8811 	msr	BASEPRI, r3
 80058fa:	f3bf 8f6f 	isb	sy
 80058fe:	f3bf 8f4f 	dsb	sy
 8005902:	e7fe      	b.n	8005902 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8005904:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8005906:	b943      	cbnz	r3, 800591a <xTaskPriorityDisinherit+0x3a>
 8005908:	f04f 0350 	mov.w	r3, #80	; 0x50
 800590c:	f383 8811 	msr	BASEPRI, r3
 8005910:	f3bf 8f6f 	isb	sy
 8005914:	f3bf 8f4f 	dsb	sy
 8005918:	e7fe      	b.n	8005918 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800591a:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800591c:	6c42      	ldr	r2, [r0, #68]	; 0x44
			( pxTCB->uxMutexesHeld )--;
 800591e:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005920:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8005922:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005924:	d0df      	beq.n	80058e6 <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8005926:	2b00      	cmp	r3, #0
 8005928:	d1dd      	bne.n	80058e6 <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800592a:	1d05      	adds	r5, r0, #4
 800592c:	4628      	mov	r0, r5
 800592e:	f7fe fc88 	bl	8004242 <uxListRemove>
 8005932:	4e11      	ldr	r6, [pc, #68]	; (8005978 <xTaskPriorityDisinherit+0x98>)
 8005934:	4a11      	ldr	r2, [pc, #68]	; (800597c <xTaskPriorityDisinherit+0x9c>)
 8005936:	b950      	cbnz	r0, 800594e <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005938:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800593a:	2114      	movs	r1, #20
 800593c:	4379      	muls	r1, r7
 800593e:	5873      	ldr	r3, [r6, r1]
 8005940:	b92b      	cbnz	r3, 800594e <xTaskPriorityDisinherit+0x6e>
 8005942:	6813      	ldr	r3, [r2, #0]
 8005944:	2001      	movs	r0, #1
 8005946:	40b8      	lsls	r0, r7
 8005948:	ea23 0300 	bic.w	r3, r3, r0
 800594c:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800594e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005950:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005952:	f1c3 0107 	rsb	r1, r3, #7
 8005956:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8005958:	6811      	ldr	r1, [r2, #0]
 800595a:	2401      	movs	r4, #1
 800595c:	fa04 f003 	lsl.w	r0, r4, r3
 8005960:	4308      	orrs	r0, r1
 8005962:	6010      	str	r0, [r2, #0]
 8005964:	2014      	movs	r0, #20
 8005966:	fb00 6003 	mla	r0, r0, r3, r6
 800596a:	4629      	mov	r1, r5
 800596c:	f7fe fc46 	bl	80041fc <vListInsertEnd>
					xReturn = pdTRUE;
 8005970:	4620      	mov	r0, r4
	}
 8005972:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005974:	20001210 	.word	0x20001210
 8005978:	2000121c 	.word	0x2000121c
 800597c:	200012bc 	.word	0x200012bc

08005980 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8005980:	4b04      	ldr	r3, [pc, #16]	; (8005994 <pvTaskIncrementMutexHeldCount+0x14>)
 8005982:	681a      	ldr	r2, [r3, #0]
 8005984:	b11a      	cbz	r2, 800598e <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 8005986:	6819      	ldr	r1, [r3, #0]
 8005988:	6c8a      	ldr	r2, [r1, #72]	; 0x48
 800598a:	3201      	adds	r2, #1
 800598c:	648a      	str	r2, [r1, #72]	; 0x48
		return pxCurrentTCB;
 800598e:	6818      	ldr	r0, [r3, #0]
	}
 8005990:	4770      	bx	lr
 8005992:	bf00      	nop
 8005994:	20001210 	.word	0x20001210

08005998 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8005998:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 800599a:	4c11      	ldr	r4, [pc, #68]	; (80059e0 <prvCheckForValidListAndQueue+0x48>)
	taskENTER_CRITICAL();
 800599c:	f7fe fcc2 	bl	8004324 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 80059a0:	6825      	ldr	r5, [r4, #0]
 80059a2:	b9bd      	cbnz	r5, 80059d4 <prvCheckForValidListAndQueue+0x3c>
		{
			vListInitialise( &xActiveTimerList1 );
 80059a4:	4f0f      	ldr	r7, [pc, #60]	; (80059e4 <prvCheckForValidListAndQueue+0x4c>)
			vListInitialise( &xActiveTimerList2 );
 80059a6:	4e10      	ldr	r6, [pc, #64]	; (80059e8 <prvCheckForValidListAndQueue+0x50>)
			vListInitialise( &xActiveTimerList1 );
 80059a8:	4638      	mov	r0, r7
 80059aa:	f7fe fc19 	bl	80041e0 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80059ae:	4630      	mov	r0, r6
 80059b0:	f7fe fc16 	bl	80041e0 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80059b4:	4b0d      	ldr	r3, [pc, #52]	; (80059ec <prvCheckForValidListAndQueue+0x54>)
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue;
				static uint8_t ucStaticTimerQueueStorage[ configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ];

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80059b6:	4a0e      	ldr	r2, [pc, #56]	; (80059f0 <prvCheckForValidListAndQueue+0x58>)
			pxCurrentTimerList = &xActiveTimerList1;
 80059b8:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 80059ba:	4b0e      	ldr	r3, [pc, #56]	; (80059f4 <prvCheckForValidListAndQueue+0x5c>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80059bc:	210c      	movs	r1, #12
			pxOverflowTimerList = &xActiveTimerList2;
 80059be:	601e      	str	r6, [r3, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80059c0:	200a      	movs	r0, #10
 80059c2:	9500      	str	r5, [sp, #0]
 80059c4:	4b0c      	ldr	r3, [pc, #48]	; (80059f8 <prvCheckForValidListAndQueue+0x60>)
 80059c6:	f7fe ff8d 	bl	80048e4 <xQueueGenericCreateStatic>
 80059ca:	6020      	str	r0, [r4, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 80059cc:	b110      	cbz	r0, 80059d4 <prvCheckForValidListAndQueue+0x3c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80059ce:	490b      	ldr	r1, [pc, #44]	; (80059fc <prvCheckForValidListAndQueue+0x64>)
 80059d0:	f7ff fab6 	bl	8004f40 <vQueueAddToRegistry>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 80059d4:	b003      	add	sp, #12
 80059d6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 80059da:	f7fe bcc5 	b.w	8004368 <vPortExitCritical>
 80059de:	bf00      	nop
 80059e0:	2000142c 	.word	0x2000142c
 80059e4:	200013b8 	.word	0x200013b8
 80059e8:	200013cc 	.word	0x200013cc
 80059ec:	20001338 	.word	0x20001338
 80059f0:	20001340 	.word	0x20001340
 80059f4:	2000133c 	.word	0x2000133c
 80059f8:	200013e4 	.word	0x200013e4
 80059fc:	08007a3d 	.word	0x08007a3d

08005a00 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
 8005a00:	4291      	cmp	r1, r2
{
 8005a02:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8005a04:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8005a06:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
 8005a08:	d80a      	bhi.n	8005a20 <prvInsertTimerInActiveList+0x20>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005a0a:	1ad2      	subs	r2, r2, r3
 8005a0c:	6983      	ldr	r3, [r0, #24]
 8005a0e:	429a      	cmp	r2, r3
 8005a10:	d20d      	bcs.n	8005a2e <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8005a12:	4b08      	ldr	r3, [pc, #32]	; (8005a34 <prvInsertTimerInActiveList+0x34>)
 8005a14:	1d01      	adds	r1, r0, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8005a16:	6818      	ldr	r0, [r3, #0]
 8005a18:	f7fe fbfc 	bl	8004214 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8005a1c:	2000      	movs	r0, #0
 8005a1e:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8005a20:	429a      	cmp	r2, r3
 8005a22:	d201      	bcs.n	8005a28 <prvInsertTimerInActiveList+0x28>
 8005a24:	4299      	cmp	r1, r3
 8005a26:	d202      	bcs.n	8005a2e <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8005a28:	1d01      	adds	r1, r0, #4
 8005a2a:	4b03      	ldr	r3, [pc, #12]	; (8005a38 <prvInsertTimerInActiveList+0x38>)
 8005a2c:	e7f3      	b.n	8005a16 <prvInsertTimerInActiveList+0x16>
			xProcessTimerNow = pdTRUE;
 8005a2e:	2001      	movs	r0, #1
}
 8005a30:	bd08      	pop	{r3, pc}
 8005a32:	bf00      	nop
 8005a34:	2000133c 	.word	0x2000133c
 8005a38:	20001338 	.word	0x20001338

08005a3c <xTimerCreateTimerTask>:
{
 8005a3c:	b510      	push	{r4, lr}
 8005a3e:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
 8005a40:	f7ff ffaa 	bl	8005998 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8005a44:	4b12      	ldr	r3, [pc, #72]	; (8005a90 <xTimerCreateTimerTask+0x54>)
 8005a46:	681b      	ldr	r3, [r3, #0]
 8005a48:	b1b3      	cbz	r3, 8005a78 <xTimerCreateTimerTask+0x3c>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 8005a4a:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8005a4c:	aa07      	add	r2, sp, #28
 8005a4e:	a906      	add	r1, sp, #24
 8005a50:	a805      	add	r0, sp, #20
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 8005a52:	9405      	str	r4, [sp, #20]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 8005a54:	9406      	str	r4, [sp, #24]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8005a56:	f000 fc0d 	bl	8006274 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8005a5a:	9b05      	ldr	r3, [sp, #20]
 8005a5c:	9302      	str	r3, [sp, #8]
 8005a5e:	9b06      	ldr	r3, [sp, #24]
 8005a60:	9301      	str	r3, [sp, #4]
 8005a62:	2302      	movs	r3, #2
 8005a64:	9300      	str	r3, [sp, #0]
 8005a66:	9a07      	ldr	r2, [sp, #28]
 8005a68:	490a      	ldr	r1, [pc, #40]	; (8005a94 <xTimerCreateTimerTask+0x58>)
 8005a6a:	480b      	ldr	r0, [pc, #44]	; (8005a98 <xTimerCreateTimerTask+0x5c>)
 8005a6c:	4623      	mov	r3, r4
 8005a6e:	f7ff fbd6 	bl	800521e <xTaskCreateStatic>
 8005a72:	4b0a      	ldr	r3, [pc, #40]	; (8005a9c <xTimerCreateTimerTask+0x60>)
 8005a74:	6018      	str	r0, [r3, #0]
	configASSERT( xReturn );
 8005a76:	b940      	cbnz	r0, 8005a8a <xTimerCreateTimerTask+0x4e>
 8005a78:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005a7c:	f383 8811 	msr	BASEPRI, r3
 8005a80:	f3bf 8f6f 	isb	sy
 8005a84:	f3bf 8f4f 	dsb	sy
 8005a88:	e7fe      	b.n	8005a88 <xTimerCreateTimerTask+0x4c>
}
 8005a8a:	2001      	movs	r0, #1
 8005a8c:	b008      	add	sp, #32
 8005a8e:	bd10      	pop	{r4, pc}
 8005a90:	2000142c 	.word	0x2000142c
 8005a94:	08007a42 	.word	0x08007a42
 8005a98:	08005c3d 	.word	0x08005c3d
 8005a9c:	20001430 	.word	0x20001430

08005aa0 <xTimerCreate>:
	{
 8005aa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005aa4:	4680      	mov	r8, r0
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8005aa6:	202c      	movs	r0, #44	; 0x2c
	{
 8005aa8:	460d      	mov	r5, r1
 8005aaa:	4617      	mov	r7, r2
 8005aac:	461e      	mov	r6, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 8005aae:	f7fe fd93 	bl	80045d8 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8005ab2:	4604      	mov	r4, r0
 8005ab4:	b1c0      	cbz	r0, 8005ae8 <xTimerCreate+0x48>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8005ab6:	b945      	cbnz	r5, 8005aca <xTimerCreate+0x2a>
 8005ab8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005abc:	f383 8811 	msr	BASEPRI, r3
 8005ac0:	f3bf 8f6f 	isb	sy
 8005ac4:	f3bf 8f4f 	dsb	sy
 8005ac8:	e7fe      	b.n	8005ac8 <xTimerCreate+0x28>
		prvCheckForValidListAndQueue();
 8005aca:	f7ff ff65 	bl	8005998 <prvCheckForValidListAndQueue>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8005ace:	9b06      	ldr	r3, [sp, #24]
 8005ad0:	6263      	str	r3, [r4, #36]	; 0x24
		pxNewTimer->pcTimerName = pcTimerName;
 8005ad2:	f8c4 8000 	str.w	r8, [r4]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8005ad6:	61a5      	str	r5, [r4, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
 8005ad8:	61e7      	str	r7, [r4, #28]
		pxNewTimer->pvTimerID = pvTimerID;
 8005ada:	6226      	str	r6, [r4, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8005adc:	1d20      	adds	r0, r4, #4
 8005ade:	f7fe fb8a 	bl	80041f6 <vListInitialiseItem>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
 8005ae2:	2300      	movs	r3, #0
 8005ae4:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	}
 8005ae8:	4620      	mov	r0, r4
 8005aea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005aee <xTimerCreateStatic>:
	{
 8005aee:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8005af2:	461e      	mov	r6, r3
			volatile size_t xSize = sizeof( StaticTimer_t );
 8005af4:	232c      	movs	r3, #44	; 0x2c
 8005af6:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Timer_t ) );
 8005af8:	9b01      	ldr	r3, [sp, #4]
	{
 8005afa:	9c09      	ldr	r4, [sp, #36]	; 0x24
			configASSERT( xSize == sizeof( Timer_t ) );
 8005afc:	2b2c      	cmp	r3, #44	; 0x2c
	{
 8005afe:	4680      	mov	r8, r0
 8005b00:	460d      	mov	r5, r1
 8005b02:	4617      	mov	r7, r2
			configASSERT( xSize == sizeof( Timer_t ) );
 8005b04:	d008      	beq.n	8005b18 <xTimerCreateStatic+0x2a>
 8005b06:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b0a:	f383 8811 	msr	BASEPRI, r3
 8005b0e:	f3bf 8f6f 	isb	sy
 8005b12:	f3bf 8f4f 	dsb	sy
 8005b16:	e7fe      	b.n	8005b16 <xTimerCreateStatic+0x28>
		configASSERT( pxTimerBuffer );
 8005b18:	b944      	cbnz	r4, 8005b2c <xTimerCreateStatic+0x3e>
 8005b1a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b1e:	f383 8811 	msr	BASEPRI, r3
 8005b22:	f3bf 8f6f 	isb	sy
 8005b26:	f3bf 8f4f 	dsb	sy
 8005b2a:	e7fe      	b.n	8005b2a <xTimerCreateStatic+0x3c>
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8005b2c:	b941      	cbnz	r1, 8005b40 <xTimerCreateStatic+0x52>
 8005b2e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b32:	f383 8811 	msr	BASEPRI, r3
 8005b36:	f3bf 8f6f 	isb	sy
 8005b3a:	f3bf 8f4f 	dsb	sy
 8005b3e:	e7fe      	b.n	8005b3e <xTimerCreateStatic+0x50>
		prvCheckForValidListAndQueue();
 8005b40:	f7ff ff2a 	bl	8005998 <prvCheckForValidListAndQueue>
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8005b44:	9b08      	ldr	r3, [sp, #32]
 8005b46:	6263      	str	r3, [r4, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8005b48:	1d20      	adds	r0, r4, #4
		pxNewTimer->pcTimerName = pcTimerName;
 8005b4a:	f8c4 8000 	str.w	r8, [r4]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8005b4e:	61a5      	str	r5, [r4, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
 8005b50:	61e7      	str	r7, [r4, #28]
		pxNewTimer->pvTimerID = pvTimerID;
 8005b52:	6226      	str	r6, [r4, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8005b54:	f7fe fb4f 	bl	80041f6 <vListInitialiseItem>
				pxNewTimer->ucStaticallyAllocated = pdTRUE;
 8005b58:	2301      	movs	r3, #1
	}
 8005b5a:	4620      	mov	r0, r4
				pxNewTimer->ucStaticallyAllocated = pdTRUE;
 8005b5c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	}
 8005b60:	b002      	add	sp, #8
 8005b62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08005b68 <xTimerGenericCommand>:
{
 8005b68:	b530      	push	{r4, r5, lr}
 8005b6a:	4615      	mov	r5, r2
 8005b6c:	b085      	sub	sp, #20
 8005b6e:	461a      	mov	r2, r3
	configASSERT( xTimer );
 8005b70:	4603      	mov	r3, r0
 8005b72:	b940      	cbnz	r0, 8005b86 <xTimerGenericCommand+0x1e>
 8005b74:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b78:	f383 8811 	msr	BASEPRI, r3
 8005b7c:	f3bf 8f6f 	isb	sy
 8005b80:	f3bf 8f4f 	dsb	sy
 8005b84:	e7fe      	b.n	8005b84 <xTimerGenericCommand+0x1c>
	if( xTimerQueue != NULL )
 8005b86:	4c0d      	ldr	r4, [pc, #52]	; (8005bbc <xTimerGenericCommand+0x54>)
 8005b88:	6820      	ldr	r0, [r4, #0]
 8005b8a:	b180      	cbz	r0, 8005bae <xTimerGenericCommand+0x46>
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8005b8c:	2905      	cmp	r1, #5
		xMessage.xMessageID = xCommandID;
 8005b8e:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8005b90:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8005b92:	9303      	str	r3, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8005b94:	dc0d      	bgt.n	8005bb2 <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8005b96:	f7ff fe4d 	bl	8005834 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8005b9a:	2300      	movs	r3, #0
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8005b9c:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8005b9e:	bf08      	it	eq
 8005ba0:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8005ba2:	6820      	ldr	r0, [r4, #0]
 8005ba4:	bf18      	it	ne
 8005ba6:	461a      	movne	r2, r3
 8005ba8:	a901      	add	r1, sp, #4
 8005baa:	f7fe ff49 	bl	8004a40 <xQueueGenericSend>
}
 8005bae:	b005      	add	sp, #20
 8005bb0:	bd30      	pop	{r4, r5, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8005bb2:	2300      	movs	r3, #0
 8005bb4:	a901      	add	r1, sp, #4
 8005bb6:	f7fe fff9 	bl	8004bac <xQueueGenericSendFromISR>
 8005bba:	e7f8      	b.n	8005bae <xTimerGenericCommand+0x46>
 8005bbc:	2000142c 	.word	0x2000142c

08005bc0 <prvSwitchTimerLists>:
{
 8005bc0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8005bc4:	4d1b      	ldr	r5, [pc, #108]	; (8005c34 <prvSwitchTimerLists+0x74>)
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8005bc6:	f04f 0800 	mov.w	r8, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8005bca:	682b      	ldr	r3, [r5, #0]
 8005bcc:	681a      	ldr	r2, [r3, #0]
 8005bce:	b932      	cbnz	r2, 8005bde <prvSwitchTimerLists+0x1e>
	pxCurrentTimerList = pxOverflowTimerList;
 8005bd0:	4a19      	ldr	r2, [pc, #100]	; (8005c38 <prvSwitchTimerLists+0x78>)
 8005bd2:	6811      	ldr	r1, [r2, #0]
 8005bd4:	6029      	str	r1, [r5, #0]
	pxOverflowTimerList = pxTemp;
 8005bd6:	6013      	str	r3, [r2, #0]
}
 8005bd8:	b002      	add	sp, #8
 8005bda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8005bde:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8005be0:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8005be2:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8005be4:	1d27      	adds	r7, r4, #4
 8005be6:	4638      	mov	r0, r7
 8005be8:	f7fe fb2b 	bl	8004242 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8005bec:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005bee:	4620      	mov	r0, r4
 8005bf0:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8005bf2:	69e3      	ldr	r3, [r4, #28]
 8005bf4:	2b01      	cmp	r3, #1
 8005bf6:	d1e8      	bne.n	8005bca <prvSwitchTimerLists+0xa>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8005bf8:	69a3      	ldr	r3, [r4, #24]
 8005bfa:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 8005bfc:	429e      	cmp	r6, r3
 8005bfe:	d206      	bcs.n	8005c0e <prvSwitchTimerLists+0x4e>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8005c00:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8005c02:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8005c04:	4639      	mov	r1, r7
 8005c06:	6828      	ldr	r0, [r5, #0]
 8005c08:	f7fe fb04 	bl	8004214 <vListInsert>
 8005c0c:	e7dd      	b.n	8005bca <prvSwitchTimerLists+0xa>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8005c0e:	2300      	movs	r3, #0
 8005c10:	f8cd 8000 	str.w	r8, [sp]
 8005c14:	4632      	mov	r2, r6
 8005c16:	4619      	mov	r1, r3
 8005c18:	4620      	mov	r0, r4
 8005c1a:	f7ff ffa5 	bl	8005b68 <xTimerGenericCommand>
				configASSERT( xResult );
 8005c1e:	2800      	cmp	r0, #0
 8005c20:	d1d3      	bne.n	8005bca <prvSwitchTimerLists+0xa>
 8005c22:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005c26:	f383 8811 	msr	BASEPRI, r3
 8005c2a:	f3bf 8f6f 	isb	sy
 8005c2e:	f3bf 8f4f 	dsb	sy
 8005c32:	e7fe      	b.n	8005c32 <prvSwitchTimerLists+0x72>
 8005c34:	20001338 	.word	0x20001338
 8005c38:	2000133c 	.word	0x2000133c

08005c3c <prvTimerTask>:
{
 8005c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8005c40:	4d6f      	ldr	r5, [pc, #444]	; (8005e00 <prvTimerTask+0x1c4>)
					portYIELD_WITHIN_API();
 8005c42:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8005e10 <prvTimerTask+0x1d4>
{
 8005c46:	b089      	sub	sp, #36	; 0x24
 8005c48:	462f      	mov	r7, r5
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8005c4a:	682b      	ldr	r3, [r5, #0]
 8005c4c:	f8d3 b000 	ldr.w	fp, [r3]
	if( *pxListWasEmpty == pdFALSE )
 8005c50:	f1bb 0f00 	cmp.w	fp, #0
 8005c54:	d043      	beq.n	8005cde <prvTimerTask+0xa2>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8005c56:	68db      	ldr	r3, [r3, #12]
 8005c58:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
 8005c5c:	f7ff fb72 	bl	8005344 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8005c60:	f7ff fb78 	bl	8005354 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8005c64:	4b67      	ldr	r3, [pc, #412]	; (8005e04 <prvTimerTask+0x1c8>)
 8005c66:	681a      	ldr	r2, [r3, #0]
 8005c68:	4290      	cmp	r0, r2
	xTimeNow = xTaskGetTickCount();
 8005c6a:	4682      	mov	sl, r0
 8005c6c:	461e      	mov	r6, r3
	if( xTimeNow < xLastTime )
 8005c6e:	d238      	bcs.n	8005ce2 <prvTimerTask+0xa6>
 8005c70:	9303      	str	r3, [sp, #12]
		prvSwitchTimerLists();
 8005c72:	f7ff ffa5 	bl	8005bc0 <prvSwitchTimerLists>
 8005c76:	9b03      	ldr	r3, [sp, #12]
		*pxTimerListsWereSwitched = pdTRUE;
 8005c78:	2401      	movs	r4, #1
	xLastTime = xTimeNow;
 8005c7a:	f8c3 a000 	str.w	sl, [r3]
		if( xTimerListsWereSwitched == pdFALSE )
 8005c7e:	2c00      	cmp	r4, #0
 8005c80:	f040 8083 	bne.w	8005d8a <prvTimerTask+0x14e>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8005c84:	f1bb 0f00 	cmp.w	fp, #0
 8005c88:	d064      	beq.n	8005d54 <prvTimerTask+0x118>
 8005c8a:	45d1      	cmp	r9, sl
 8005c8c:	d87b      	bhi.n	8005d86 <prvTimerTask+0x14a>
				( void ) xTaskResumeAll();
 8005c8e:	f7ff fbf9 	bl	8005484 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8005c92:	683b      	ldr	r3, [r7, #0]
 8005c94:	68db      	ldr	r3, [r3, #12]
 8005c96:	f8d3 b00c 	ldr.w	fp, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8005c9a:	f10b 0004 	add.w	r0, fp, #4
 8005c9e:	f7fe fad0 	bl	8004242 <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8005ca2:	f8db 301c 	ldr.w	r3, [fp, #28]
 8005ca6:	2b01      	cmp	r3, #1
 8005ca8:	d11d      	bne.n	8005ce6 <prvTimerTask+0xaa>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8005caa:	f8db 1018 	ldr.w	r1, [fp, #24]
 8005cae:	464b      	mov	r3, r9
 8005cb0:	4652      	mov	r2, sl
 8005cb2:	4449      	add	r1, r9
 8005cb4:	4658      	mov	r0, fp
 8005cb6:	f7ff fea3 	bl	8005a00 <prvInsertTimerInActiveList>
 8005cba:	b1a0      	cbz	r0, 8005ce6 <prvTimerTask+0xaa>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8005cbc:	9400      	str	r4, [sp, #0]
 8005cbe:	4623      	mov	r3, r4
 8005cc0:	464a      	mov	r2, r9
 8005cc2:	4621      	mov	r1, r4
 8005cc4:	4658      	mov	r0, fp
 8005cc6:	f7ff ff4f 	bl	8005b68 <xTimerGenericCommand>
			configASSERT( xResult );
 8005cca:	b960      	cbnz	r0, 8005ce6 <prvTimerTask+0xaa>
 8005ccc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005cd0:	f383 8811 	msr	BASEPRI, r3
 8005cd4:	f3bf 8f6f 	isb	sy
 8005cd8:	f3bf 8f4f 	dsb	sy
 8005cdc:	e7fe      	b.n	8005cdc <prvTimerTask+0xa0>
		xNextExpireTime = ( TickType_t ) 0U;
 8005cde:	46d9      	mov	r9, fp
 8005ce0:	e7bc      	b.n	8005c5c <prvTimerTask+0x20>
		*pxTimerListsWereSwitched = pdFALSE;
 8005ce2:	2400      	movs	r4, #0
 8005ce4:	e7c9      	b.n	8005c7a <prvTimerTask+0x3e>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8005ce6:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 8005cea:	4658      	mov	r0, fp
 8005cec:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8005cee:	f8df 911c 	ldr.w	r9, [pc, #284]	; 8005e0c <prvTimerTask+0x1d0>
 8005cf2:	f8d9 0000 	ldr.w	r0, [r9]
 8005cf6:	2300      	movs	r3, #0
 8005cf8:	461a      	mov	r2, r3
 8005cfa:	a905      	add	r1, sp, #20
 8005cfc:	f7ff f80c 	bl	8004d18 <xQueueGenericReceive>
 8005d00:	2800      	cmp	r0, #0
 8005d02:	d0a2      	beq.n	8005c4a <prvTimerTask+0xe>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8005d04:	9b05      	ldr	r3, [sp, #20]
 8005d06:	2b00      	cmp	r3, #0
 8005d08:	dbf3      	blt.n	8005cf2 <prvTimerTask+0xb6>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8005d0a:	9c07      	ldr	r4, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8005d0c:	6963      	ldr	r3, [r4, #20]
 8005d0e:	b113      	cbz	r3, 8005d16 <prvTimerTask+0xda>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8005d10:	1d20      	adds	r0, r4, #4
 8005d12:	f7fe fa96 	bl	8004242 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8005d16:	f7ff fb1d 	bl	8005354 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8005d1a:	6833      	ldr	r3, [r6, #0]
 8005d1c:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
 8005d1e:	4683      	mov	fp, r0
	if( xTimeNow < xLastTime )
 8005d20:	d201      	bcs.n	8005d26 <prvTimerTask+0xea>
		prvSwitchTimerLists();
 8005d22:	f7ff ff4d 	bl	8005bc0 <prvSwitchTimerLists>
 8005d26:	9a05      	ldr	r2, [sp, #20]
	xLastTime = xTimeNow;
 8005d28:	f8c6 b000 	str.w	fp, [r6]
 8005d2c:	2a09      	cmp	r2, #9
 8005d2e:	d8e0      	bhi.n	8005cf2 <prvTimerTask+0xb6>
 8005d30:	2301      	movs	r3, #1
 8005d32:	4093      	lsls	r3, r2
 8005d34:	f413 7a04 	ands.w	sl, r3, #528	; 0x210
 8005d38:	d14e      	bne.n	8005dd8 <prvTimerTask+0x19c>
 8005d3a:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 8005d3e:	d127      	bne.n	8005d90 <prvTimerTask+0x154>
 8005d40:	069b      	lsls	r3, r3, #26
 8005d42:	d5d6      	bpl.n	8005cf2 <prvTimerTask+0xb6>
						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 8005d44:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8005d48:	2b00      	cmp	r3, #0
 8005d4a:	d1d2      	bne.n	8005cf2 <prvTimerTask+0xb6>
							vPortFree( pxTimer );
 8005d4c:	4620      	mov	r0, r4
 8005d4e:	f7fe fcd1 	bl	80046f4 <vPortFree>
 8005d52:	e7ce      	b.n	8005cf2 <prvTimerTask+0xb6>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8005d54:	4b2c      	ldr	r3, [pc, #176]	; (8005e08 <prvTimerTask+0x1cc>)
 8005d56:	681b      	ldr	r3, [r3, #0]
 8005d58:	681a      	ldr	r2, [r3, #0]
 8005d5a:	fab2 f282 	clz	r2, r2
 8005d5e:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8005d60:	4b2a      	ldr	r3, [pc, #168]	; (8005e0c <prvTimerTask+0x1d0>)
 8005d62:	eba9 010a 	sub.w	r1, r9, sl
 8005d66:	6818      	ldr	r0, [r3, #0]
 8005d68:	f7ff f8fc 	bl	8004f64 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8005d6c:	f7ff fb8a 	bl	8005484 <xTaskResumeAll>
 8005d70:	2800      	cmp	r0, #0
 8005d72:	d1bc      	bne.n	8005cee <prvTimerTask+0xb2>
					portYIELD_WITHIN_API();
 8005d74:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8005d78:	f8c8 3000 	str.w	r3, [r8]
 8005d7c:	f3bf 8f4f 	dsb	sy
 8005d80:	f3bf 8f6f 	isb	sy
 8005d84:	e7b3      	b.n	8005cee <prvTimerTask+0xb2>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8005d86:	4622      	mov	r2, r4
 8005d88:	e7ea      	b.n	8005d60 <prvTimerTask+0x124>
			( void ) xTaskResumeAll();
 8005d8a:	f7ff fb7b 	bl	8005484 <xTaskResumeAll>
 8005d8e:	e7ae      	b.n	8005cee <prvTimerTask+0xb2>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8005d90:	69a1      	ldr	r1, [r4, #24]
 8005d92:	9b06      	ldr	r3, [sp, #24]
 8005d94:	465a      	mov	r2, fp
 8005d96:	4419      	add	r1, r3
 8005d98:	4620      	mov	r0, r4
 8005d9a:	f7ff fe31 	bl	8005a00 <prvInsertTimerInActiveList>
 8005d9e:	2800      	cmp	r0, #0
 8005da0:	d0a7      	beq.n	8005cf2 <prvTimerTask+0xb6>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8005da2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005da4:	4620      	mov	r0, r4
 8005da6:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8005da8:	69e3      	ldr	r3, [r4, #28]
 8005daa:	2b01      	cmp	r3, #1
 8005dac:	d1a1      	bne.n	8005cf2 <prvTimerTask+0xb6>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8005dae:	69a2      	ldr	r2, [r4, #24]
 8005db0:	9906      	ldr	r1, [sp, #24]
 8005db2:	f8cd a000 	str.w	sl, [sp]
 8005db6:	440a      	add	r2, r1
 8005db8:	4653      	mov	r3, sl
 8005dba:	4651      	mov	r1, sl
 8005dbc:	4620      	mov	r0, r4
 8005dbe:	f7ff fed3 	bl	8005b68 <xTimerGenericCommand>
							configASSERT( xResult );
 8005dc2:	2800      	cmp	r0, #0
 8005dc4:	d195      	bne.n	8005cf2 <prvTimerTask+0xb6>
 8005dc6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005dca:	f383 8811 	msr	BASEPRI, r3
 8005dce:	f3bf 8f6f 	isb	sy
 8005dd2:	f3bf 8f4f 	dsb	sy
 8005dd6:	e7fe      	b.n	8005dd6 <prvTimerTask+0x19a>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8005dd8:	9906      	ldr	r1, [sp, #24]
 8005dda:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8005ddc:	b941      	cbnz	r1, 8005df0 <prvTimerTask+0x1b4>
 8005dde:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005de2:	f383 8811 	msr	BASEPRI, r3
 8005de6:	f3bf 8f6f 	isb	sy
 8005dea:	f3bf 8f4f 	dsb	sy
 8005dee:	e7fe      	b.n	8005dee <prvTimerTask+0x1b2>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8005df0:	465b      	mov	r3, fp
 8005df2:	465a      	mov	r2, fp
 8005df4:	4459      	add	r1, fp
 8005df6:	4620      	mov	r0, r4
 8005df8:	f7ff fe02 	bl	8005a00 <prvInsertTimerInActiveList>
 8005dfc:	e779      	b.n	8005cf2 <prvTimerTask+0xb6>
 8005dfe:	bf00      	nop
 8005e00:	20001338 	.word	0x20001338
 8005e04:	200013e0 	.word	0x200013e0
 8005e08:	2000133c 	.word	0x2000133c
 8005e0c:	2000142c 	.word	0x2000142c
 8005e10:	e000ed04 	.word	0xe000ed04

08005e14 <reset_timer>:
volatile unsigned int *SCB_DEMCR = (unsigned int *)0xE000EDFC;		//address of the register


void reset_timer()
{
    *SCB_DEMCR   = *SCB_DEMCR | 0x01000000;
 8005e14:	4b06      	ldr	r3, [pc, #24]	; (8005e30 <reset_timer+0x1c>)
 8005e16:	681a      	ldr	r2, [r3, #0]
 8005e18:	6813      	ldr	r3, [r2, #0]
 8005e1a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005e1e:	6013      	str	r3, [r2, #0]
    *DWT_CYCCNT  = 0; // reset the counter
 8005e20:	4b04      	ldr	r3, [pc, #16]	; (8005e34 <reset_timer+0x20>)
 8005e22:	681a      	ldr	r2, [r3, #0]
 8005e24:	2300      	movs	r3, #0
 8005e26:	6013      	str	r3, [r2, #0]
    *DWT_CONTROL = 0;
 8005e28:	4a03      	ldr	r2, [pc, #12]	; (8005e38 <reset_timer+0x24>)
 8005e2a:	6812      	ldr	r2, [r2, #0]
 8005e2c:	6013      	str	r3, [r2, #0]
 8005e2e:	4770      	bx	lr
 8005e30:	2000011c 	.word	0x2000011c
 8005e34:	20000118 	.word	0x20000118
 8005e38:	20000114 	.word	0x20000114

08005e3c <start_timer>:
}

void start_timer()
{
    *DWT_CONTROL = *DWT_CONTROL | 1 ; // enable the counter
 8005e3c:	4b03      	ldr	r3, [pc, #12]	; (8005e4c <start_timer+0x10>)
 8005e3e:	681a      	ldr	r2, [r3, #0]
 8005e40:	6813      	ldr	r3, [r2, #0]
 8005e42:	f043 0301 	orr.w	r3, r3, #1
 8005e46:	6013      	str	r3, [r2, #0]
 8005e48:	4770      	bx	lr
 8005e4a:	bf00      	nop
 8005e4c:	20000114 	.word	0x20000114

08005e50 <stop_timer>:
}

void stop_timer()
{
    *DWT_CONTROL = *DWT_CONTROL | 0 ; // disable the counter
 8005e50:	4b02      	ldr	r3, [pc, #8]	; (8005e5c <stop_timer+0xc>)
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	681a      	ldr	r2, [r3, #0]
 8005e56:	601a      	str	r2, [r3, #0]
 8005e58:	4770      	bx	lr
 8005e5a:	bf00      	nop
 8005e5c:	20000114 	.word	0x20000114

08005e60 <getCycles>:
}

unsigned int getCycles()
{
    return *DWT_CYCCNT;
 8005e60:	4b01      	ldr	r3, [pc, #4]	; (8005e68 <getCycles+0x8>)
 8005e62:	681b      	ldr	r3, [r3, #0]
 8005e64:	6818      	ldr	r0, [r3, #0]
}
 8005e66:	4770      	bx	lr
 8005e68:	20000118 	.word	0x20000118

08005e6c <debug_outbyte>:

#if DEBUG 

void debug_outbyte(char c)
{
	while(!(DEBUG_UART_HANDLE.Instance->ISR & (1 << 7))) {};
 8005e6c:	4b03      	ldr	r3, [pc, #12]	; (8005e7c <debug_outbyte+0x10>)
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	69da      	ldr	r2, [r3, #28]
 8005e72:	0612      	lsls	r2, r2, #24
 8005e74:	d5fc      	bpl.n	8005e70 <debug_outbyte+0x4>
	DEBUG_UART_HANDLE.Instance->TDR = c;
 8005e76:	b280      	uxth	r0, r0
 8005e78:	8518      	strh	r0, [r3, #40]	; 0x28
 8005e7a:	4770      	bx	lr
 8005e7c:	2000226c 	.word	0x2000226c

08005e80 <printchar>:

#define putchar_s(c) debug_outbyte(c)

static void printchar(char **str, int c)
{
	if (str) {
 8005e80:	b128      	cbz	r0, 8005e8e <printchar+0xe>
		**str = c;
 8005e82:	6803      	ldr	r3, [r0, #0]
 8005e84:	7019      	strb	r1, [r3, #0]
		++(*str);
 8005e86:	6803      	ldr	r3, [r0, #0]
 8005e88:	3301      	adds	r3, #1
 8005e8a:	6003      	str	r3, [r0, #0]
 8005e8c:	4770      	bx	lr
	}
	else 
		putchar_s(c);
 8005e8e:	b2c8      	uxtb	r0, r1
 8005e90:	f7ff bfec 	b.w	8005e6c <debug_outbyte>

08005e94 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8005e94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 8005e98:	1e14      	subs	r4, r2, #0
{
 8005e9a:	4680      	mov	r8, r0
 8005e9c:	460d      	mov	r5, r1
	if (width > 0) {
 8005e9e:	dd27      	ble.n	8005ef0 <prints+0x5c>
 8005ea0:	460a      	mov	r2, r1
 8005ea2:	1b50      	subs	r0, r2, r5
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 8005ea4:	f812 1b01 	ldrb.w	r1, [r2], #1
 8005ea8:	2900      	cmp	r1, #0
 8005eaa:	d1fa      	bne.n	8005ea2 <prints+0xe>
		if (len >= width) width = 0;
 8005eac:	4284      	cmp	r4, r0
		else width -= len;
 8005eae:	bfcc      	ite	gt
 8005eb0:	1a24      	subgt	r4, r4, r0
		if (len >= width) width = 0;
 8005eb2:	460c      	movle	r4, r1
		if (pad & PAD_ZERO) padchar = '0';
 8005eb4:	f013 0f02 	tst.w	r3, #2
 8005eb8:	bf0c      	ite	eq
 8005eba:	2720      	moveq	r7, #32
 8005ebc:	2730      	movne	r7, #48	; 0x30
	}
	if (!(pad & PAD_RIGHT)) {
 8005ebe:	07db      	lsls	r3, r3, #31
 8005ec0:	d41e      	bmi.n	8005f00 <prints+0x6c>
 8005ec2:	4626      	mov	r6, r4
		for ( ; width > 0; --width) {
 8005ec4:	2e00      	cmp	r6, #0
 8005ec6:	dc15      	bgt.n	8005ef4 <prints+0x60>
 8005ec8:	ea24 73e4 	bic.w	r3, r4, r4, asr #31
 8005ecc:	1ae4      	subs	r4, r4, r3
 8005ece:	1b5e      	subs	r6, r3, r5
 8005ed0:	eb06 0905 	add.w	r9, r6, r5
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
 8005ed4:	f815 1b01 	ldrb.w	r1, [r5], #1
 8005ed8:	b9a1      	cbnz	r1, 8005f04 <prints+0x70>
 8005eda:	4625      	mov	r5, r4
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
 8005edc:	2d00      	cmp	r5, #0
 8005ede:	dc15      	bgt.n	8005f0c <prints+0x78>
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 8005ee0:	2c00      	cmp	r4, #0
 8005ee2:	bfac      	ite	ge
 8005ee4:	eb09 0004 	addge.w	r0, r9, r4
 8005ee8:	f109 0000 	addlt.w	r0, r9, #0
 8005eec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	register int pc = 0, padchar = ' ';
 8005ef0:	2720      	movs	r7, #32
 8005ef2:	e7e4      	b.n	8005ebe <prints+0x2a>
			printchar (out, padchar);
 8005ef4:	4639      	mov	r1, r7
 8005ef6:	4640      	mov	r0, r8
 8005ef8:	f7ff ffc2 	bl	8005e80 <printchar>
		for ( ; width > 0; --width) {
 8005efc:	3e01      	subs	r6, #1
 8005efe:	e7e1      	b.n	8005ec4 <prints+0x30>
	register int pc = 0, padchar = ' ';
 8005f00:	2300      	movs	r3, #0
 8005f02:	e7e4      	b.n	8005ece <prints+0x3a>
		printchar (out, *string);
 8005f04:	4640      	mov	r0, r8
 8005f06:	f7ff ffbb 	bl	8005e80 <printchar>
 8005f0a:	e7e1      	b.n	8005ed0 <prints+0x3c>
		printchar (out, padchar);
 8005f0c:	4639      	mov	r1, r7
 8005f0e:	4640      	mov	r0, r8
 8005f10:	f7ff ffb6 	bl	8005e80 <printchar>
	for ( ; width > 0; --width) {
 8005f14:	3d01      	subs	r5, #1
 8005f16:	e7e1      	b.n	8005edc <prints+0x48>

08005f18 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8005f18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005f1c:	b085      	sub	sp, #20
 8005f1e:	4681      	mov	r9, r0
 8005f20:	461d      	mov	r5, r3
 8005f22:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 8005f24:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;
 8005f28:	460c      	mov	r4, r1

	if (i == 0) {
 8005f2a:	b961      	cbnz	r1, 8005f46 <printi+0x2e>
		print_buf[0] = '0';
 8005f2c:	2330      	movs	r3, #48	; 0x30
 8005f2e:	f88d 3004 	strb.w	r3, [sp, #4]
		print_buf[1] = '\0';
 8005f32:	f88d 1005 	strb.w	r1, [sp, #5]
		return prints (out, print_buf, width, pad);
 8005f36:	4643      	mov	r3, r8
 8005f38:	463a      	mov	r2, r7
 8005f3a:	a901      	add	r1, sp, #4
 8005f3c:	f7ff ffaa 	bl	8005e94 <prints>
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
}
 8005f40:	b005      	add	sp, #20
 8005f42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (sg && b == 10 && i < 0) {
 8005f46:	b12b      	cbz	r3, 8005f54 <printi+0x3c>
 8005f48:	2a0a      	cmp	r2, #10
 8005f4a:	d11c      	bne.n	8005f86 <printi+0x6e>
 8005f4c:	2900      	cmp	r1, #0
 8005f4e:	da1a      	bge.n	8005f86 <printi+0x6e>
		u = -i;
 8005f50:	424c      	negs	r4, r1
		neg = 1;
 8005f52:	2501      	movs	r5, #1
	*s = '\0';
 8005f54:	ae04      	add	r6, sp, #16
 8005f56:	2300      	movs	r3, #0
 8005f58:	f806 3d01 	strb.w	r3, [r6, #-1]!
			t += letbase - '0' - 10;
 8005f5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8005f5e:	3b3a      	subs	r3, #58	; 0x3a
	while (u) {
 8005f60:	b99c      	cbnz	r4, 8005f8a <printi+0x72>
	if (neg) {
 8005f62:	b145      	cbz	r5, 8005f76 <printi+0x5e>
		if( width && (pad & PAD_ZERO) ) {
 8005f64:	b1ef      	cbz	r7, 8005fa2 <printi+0x8a>
 8005f66:	f018 0f02 	tst.w	r8, #2
 8005f6a:	d01a      	beq.n	8005fa2 <printi+0x8a>
			printchar (out, '-');
 8005f6c:	212d      	movs	r1, #45	; 0x2d
 8005f6e:	4648      	mov	r0, r9
 8005f70:	f7ff ff86 	bl	8005e80 <printchar>
			--width;
 8005f74:	3f01      	subs	r7, #1
	return pc + prints (out, s, width, pad);
 8005f76:	4643      	mov	r3, r8
 8005f78:	463a      	mov	r2, r7
 8005f7a:	4631      	mov	r1, r6
 8005f7c:	4648      	mov	r0, r9
 8005f7e:	f7ff ff89 	bl	8005e94 <prints>
 8005f82:	4428      	add	r0, r5
 8005f84:	e7dc      	b.n	8005f40 <printi+0x28>
	register int t, neg = 0, pc = 0;
 8005f86:	2500      	movs	r5, #0
 8005f88:	e7e4      	b.n	8005f54 <printi+0x3c>
		t = u % b;
 8005f8a:	fbb4 f1f2 	udiv	r1, r4, r2
 8005f8e:	fb02 4411 	mls	r4, r2, r1, r4
		if( t >= 10 )
 8005f92:	2c09      	cmp	r4, #9
			t += letbase - '0' - 10;
 8005f94:	bfc8      	it	gt
 8005f96:	18e4      	addgt	r4, r4, r3
		*--s = t + '0';
 8005f98:	3430      	adds	r4, #48	; 0x30
 8005f9a:	f806 4d01 	strb.w	r4, [r6, #-1]!
		u /= b;
 8005f9e:	460c      	mov	r4, r1
 8005fa0:	e7de      	b.n	8005f60 <printi+0x48>
			*--s = '-';
 8005fa2:	232d      	movs	r3, #45	; 0x2d
 8005fa4:	f806 3c01 	strb.w	r3, [r6, #-1]
	register int t, neg = 0, pc = 0;
 8005fa8:	2500      	movs	r5, #0
			*--s = '-';
 8005faa:	3e01      	subs	r6, #1
 8005fac:	e7e3      	b.n	8005f76 <printi+0x5e>
	...

08005fb0 <print>:

static int print(char **out, int *varg)
{
 8005fb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	register int width, pad;
	register int pc = 0;
	register char *format = (char *)(*varg++);
 8005fb4:	680e      	ldr	r6, [r1, #0]
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
				register char *s = *((char **)varg++);
				pc += prints (out, s?s:"(null)", width, pad);
 8005fb6:	f8df 9108 	ldr.w	r9, [pc, #264]	; 80060c0 <print+0x110>
{
 8005fba:	b086      	sub	sp, #24
 8005fbc:	4607      	mov	r7, r0
	register char *format = (char *)(*varg++);
 8005fbe:	1d0c      	adds	r4, r1, #4
	register int pc = 0;
 8005fc0:	2500      	movs	r5, #0
				width *= 10;
 8005fc2:	f04f 080a 	mov.w	r8, #10
	for (; *format != 0; ++format) {
 8005fc6:	7833      	ldrb	r3, [r6, #0]
 8005fc8:	b123      	cbz	r3, 8005fd4 <print+0x24>
		if (*format == '%') {
 8005fca:	2b25      	cmp	r3, #37	; 0x25
 8005fcc:	d16d      	bne.n	80060aa <print+0xfa>
			if (*format == '\0') break;
 8005fce:	7873      	ldrb	r3, [r6, #1]
			++format;
 8005fd0:	1c71      	adds	r1, r6, #1
			if (*format == '\0') break;
 8005fd2:	b92b      	cbnz	r3, 8005fe0 <print+0x30>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 8005fd4:	2f00      	cmp	r7, #0
 8005fd6:	d16e      	bne.n	80060b6 <print+0x106>
	return pc;
}
 8005fd8:	4628      	mov	r0, r5
 8005fda:	b006      	add	sp, #24
 8005fdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (*format == '%') goto out;
 8005fe0:	2b25      	cmp	r3, #37	; 0x25
 8005fe2:	d061      	beq.n	80060a8 <print+0xf8>
			if (*format == '-') {
 8005fe4:	2b2d      	cmp	r3, #45	; 0x2d
				++format;
 8005fe6:	bf06      	itte	eq
 8005fe8:	1cb1      	addeq	r1, r6, #2
				pad = PAD_RIGHT;
 8005fea:	2301      	moveq	r3, #1
			width = pad = 0;
 8005fec:	2300      	movne	r3, #0
			while (*format == '0') {
 8005fee:	780a      	ldrb	r2, [r1, #0]
 8005ff0:	2a30      	cmp	r2, #48	; 0x30
 8005ff2:	f101 0001 	add.w	r0, r1, #1
 8005ff6:	d017      	beq.n	8006028 <print+0x78>
 8005ff8:	2200      	movs	r2, #0
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8005ffa:	7808      	ldrb	r0, [r1, #0]
 8005ffc:	f1a0 0e30 	sub.w	lr, r0, #48	; 0x30
 8006000:	fa5f fc8e 	uxtb.w	ip, lr
 8006004:	f1bc 0f09 	cmp.w	ip, #9
 8006008:	460e      	mov	r6, r1
 800600a:	f101 0101 	add.w	r1, r1, #1
 800600e:	d90f      	bls.n	8006030 <print+0x80>
			if( *format == 's' ) {
 8006010:	2873      	cmp	r0, #115	; 0x73
 8006012:	d110      	bne.n	8006036 <print+0x86>
				register char *s = *((char **)varg++);
 8006014:	6821      	ldr	r1, [r4, #0]
 8006016:	f104 0a04 	add.w	sl, r4, #4
				pc += prints (out, s?s:"(null)", width, pad);
 800601a:	2900      	cmp	r1, #0
 800601c:	bf08      	it	eq
 800601e:	4649      	moveq	r1, r9
				pc += prints (out, scr, width, pad);
 8006020:	4638      	mov	r0, r7
 8006022:	f7ff ff37 	bl	8005e94 <prints>
 8006026:	e014      	b.n	8006052 <print+0xa2>
				pad |= PAD_ZERO;
 8006028:	f043 0302 	orr.w	r3, r3, #2
 800602c:	4601      	mov	r1, r0
 800602e:	e7de      	b.n	8005fee <print+0x3e>
				width += *format - '0';
 8006030:	fb08 e202 	mla	r2, r8, r2, lr
 8006034:	e7e1      	b.n	8005ffa <print+0x4a>
			if( *format == 'd' ) {
 8006036:	2864      	cmp	r0, #100	; 0x64
 8006038:	d10f      	bne.n	800605a <print+0xaa>
				pc += printi (out, *varg++, 10, 1, width, pad, 'a');
 800603a:	2161      	movs	r1, #97	; 0x61
 800603c:	e88d 000c 	stmia.w	sp, {r2, r3}
 8006040:	f104 0a04 	add.w	sl, r4, #4
 8006044:	9102      	str	r1, [sp, #8]
 8006046:	2301      	movs	r3, #1
 8006048:	220a      	movs	r2, #10
 800604a:	6821      	ldr	r1, [r4, #0]
 800604c:	4638      	mov	r0, r7
 800604e:	f7ff ff63 	bl	8005f18 <printi>
 8006052:	4405      	add	r5, r0
 8006054:	4654      	mov	r4, sl
	for (; *format != 0; ++format) {
 8006056:	3601      	adds	r6, #1
 8006058:	e7b5      	b.n	8005fc6 <print+0x16>
			if( *format == 'x' ) {
 800605a:	2878      	cmp	r0, #120	; 0x78
 800605c:	d108      	bne.n	8006070 <print+0xc0>
				pc += printi (out, *varg++, 16, 0, width, pad, 'a');
 800605e:	f104 0a04 	add.w	sl, r4, #4
 8006062:	2161      	movs	r1, #97	; 0x61
				pc += printi (out, *varg++, 16, 0, width, pad, 'A');
 8006064:	e88d 000c 	stmia.w	sp, {r2, r3}
 8006068:	9102      	str	r1, [sp, #8]
 800606a:	2300      	movs	r3, #0
 800606c:	2210      	movs	r2, #16
 800606e:	e7ec      	b.n	800604a <print+0x9a>
			if( *format == 'X' ) {
 8006070:	2858      	cmp	r0, #88	; 0x58
 8006072:	d103      	bne.n	800607c <print+0xcc>
				pc += printi (out, *varg++, 16, 0, width, pad, 'A');
 8006074:	f104 0a04 	add.w	sl, r4, #4
 8006078:	2141      	movs	r1, #65	; 0x41
 800607a:	e7f3      	b.n	8006064 <print+0xb4>
			if( *format == 'u' ) {
 800607c:	2875      	cmp	r0, #117	; 0x75
 800607e:	d107      	bne.n	8006090 <print+0xe0>
				pc += printi (out, *varg++, 10, 0, width, pad, 'a');
 8006080:	2161      	movs	r1, #97	; 0x61
 8006082:	e88d 000c 	stmia.w	sp, {r2, r3}
 8006086:	f104 0a04 	add.w	sl, r4, #4
 800608a:	9102      	str	r1, [sp, #8]
 800608c:	2300      	movs	r3, #0
 800608e:	e7db      	b.n	8006048 <print+0x98>
			if( *format == 'c' ) {
 8006090:	2863      	cmp	r0, #99	; 0x63
 8006092:	d1e0      	bne.n	8006056 <print+0xa6>
				scr[0] = *varg++;
 8006094:	6821      	ldr	r1, [r4, #0]
 8006096:	f88d 1014 	strb.w	r1, [sp, #20]
				scr[1] = '\0';
 800609a:	2100      	movs	r1, #0
 800609c:	f88d 1015 	strb.w	r1, [sp, #21]
				scr[0] = *varg++;
 80060a0:	f104 0a04 	add.w	sl, r4, #4
				pc += prints (out, scr, width, pad);
 80060a4:	a905      	add	r1, sp, #20
 80060a6:	e7bb      	b.n	8006020 <print+0x70>
			++format;
 80060a8:	460e      	mov	r6, r1
			printchar (out, *format);
 80060aa:	7831      	ldrb	r1, [r6, #0]
 80060ac:	4638      	mov	r0, r7
 80060ae:	f7ff fee7 	bl	8005e80 <printchar>
			++pc;
 80060b2:	3501      	adds	r5, #1
 80060b4:	e7cf      	b.n	8006056 <print+0xa6>
	if (out) **out = '\0';
 80060b6:	683b      	ldr	r3, [r7, #0]
 80060b8:	2200      	movs	r2, #0
 80060ba:	701a      	strb	r2, [r3, #0]
	return pc;
 80060bc:	e78c      	b.n	8005fd8 <print+0x28>
 80060be:	bf00      	nop
 80060c0:	08007a4a 	.word	0x08007a4a

080060c4 <debug_print>:
{
 80060c4:	b508      	push	{r3, lr}
 80060c6:	1e41      	subs	r1, r0, #1
	while(*str) {
 80060c8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 80060cc:	b900      	cbnz	r0, 80060d0 <debug_print+0xc>
}
 80060ce:	bd08      	pop	{r3, pc}
		debug_outbyte(*str);
 80060d0:	f7ff fecc 	bl	8005e6c <debug_outbyte>
 80060d4:	e7f8      	b.n	80060c8 <debug_print+0x4>

080060d6 <debug_printf>:

/* assuming sizeof(void *) == sizeof(int) */

int debug_printf(const char *format, ...)
{
 80060d6:	b40f      	push	{r0, r1, r2, r3}
 80060d8:	b508      	push	{r3, lr}
	register int *varg = (int *)(&format);
	return print(0, varg);
 80060da:	2000      	movs	r0, #0
 80060dc:	a902      	add	r1, sp, #8
 80060de:	f7ff ff67 	bl	8005fb0 <print>
}
 80060e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80060e6:	b004      	add	sp, #16
 80060e8:	4770      	bx	lr

080060ea <__LCD_Wait>:

/**
*	Wait LCD; place before sending instruction to LCD
*/
static void __LCD_Wait(void)
{	
 80060ea:	b082      	sub	sp, #8
	volatile int i = 0;
 80060ec:	2300      	movs	r3, #0
 80060ee:	9301      	str	r3, [sp, #4]
	for(i = 0; i < 200; i++) {};
 80060f0:	9301      	str	r3, [sp, #4]
 80060f2:	9b01      	ldr	r3, [sp, #4]
 80060f4:	2bc7      	cmp	r3, #199	; 0xc7
 80060f6:	dd01      	ble.n	80060fc <__LCD_Wait+0x12>
}
 80060f8:	b002      	add	sp, #8
 80060fa:	4770      	bx	lr
	for(i = 0; i < 200; i++) {};
 80060fc:	9b01      	ldr	r3, [sp, #4]
 80060fe:	3301      	adds	r3, #1
 8006100:	e7f6      	b.n	80060f0 <__LCD_Wait+0x6>
	...

08006104 <__LCD_Pulse>:
* Low level function
* To write data or instruction to LCD; Set EN, delay sometime and Reset EN to make negative edge
*/
static void __LCD_Pulse(void)
{		
    LCD_OUT |= LCD_PIN_EN; //EN=1; Enable
 8006104:	4b04      	ldr	r3, [pc, #16]	; (8006118 <__LCD_Pulse+0x14>)
 8006106:	695a      	ldr	r2, [r3, #20]
 8006108:	f042 0202 	orr.w	r2, r2, #2
 800610c:	615a      	str	r2, [r3, #20]
    int i = 0;
    for(i = 0; i < 10; i++) {};
    LCD_OUT &= (~LCD_PIN_EN); //EN: 1->0: write
 800610e:	695a      	ldr	r2, [r3, #20]
 8006110:	f022 0202 	bic.w	r2, r2, #2
 8006114:	615a      	str	r2, [r3, #20]
 8006116:	4770      	bx	lr
 8006118:	48000400 	.word	0x48000400

0800611c <__LCD_SendByte>:
	0x10		// Cursor move and shift to left
	0x14		// Cursor move and shift to right
	@param isData: TRUE or FALSE; if isData TRUE RS=0 else RS=1
**/
static void __LCD_SendByte(uint8_t ByteToSend, int IsData)
{		
 800611c:	b510      	push	{r4, lr}
	//Write first nibble
	__LCD_Wait();
	uint32_t currState = LCD_OUT;
 800611e:	4c13      	ldr	r4, [pc, #76]	; (800616c <__LCD_SendByte+0x50>)
	__LCD_Wait();
 8006120:	f7ff ffe3 	bl	80060ea <__LCD_Wait>
	uint32_t currState = LCD_OUT;
 8006124:	6962      	ldr	r2, [r4, #20]

	currState &= (~LCD_PIN_MASK); // Reset LCD OUT
	currState |= (ByteToSend & 0xF0);
 8006126:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
	currState &= (~LCD_PIN_MASK); // Reset LCD OUT
 800612a:	f022 02f3 	bic.w	r2, r2, #243	; 0xf3
	currState |= (ByteToSend & 0xF0);
 800612e:	4313      	orrs	r3, r2
		
    if (IsData == TRUE) {
 8006130:	2901      	cmp	r1, #1
    	currState |= LCD_PIN_RS;  // Set RS=1 to write data
 8006132:	bf0c      	ite	eq
 8006134:	f043 0301 	orreq.w	r3, r3, #1
    }
    else {
    	currState &= ~LCD_PIN_RS; //Inverse RS from 1 to 0 to write instruction
 8006138:	f023 0301 	bicne.w	r3, r3, #1
    }

    LCD_OUT = currState;
 800613c:	6163      	str	r3, [r4, #20]
    __LCD_Pulse();
 800613e:	f7ff ffe1 	bl	8006104 <__LCD_Pulse>
	
	//write second nibble
	__LCD_Wait();
 8006142:	f7ff ffd2 	bl	80060ea <__LCD_Wait>
	currState = LCD_OUT;
 8006146:	6963      	ldr	r3, [r4, #20]
	currState &= (~LCD_PIN_MASK);
	currState |= ((ByteToSend & 0x0F) << 4);
 8006148:	0100      	lsls	r0, r0, #4
	currState &= (~LCD_PIN_MASK);
 800614a:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
	currState |= ((ByteToSend & 0x0F) << 4);
 800614e:	b2c0      	uxtb	r0, r0
 8006150:	4318      	orrs	r0, r3

    if (IsData == TRUE) {
 8006152:	2901      	cmp	r1, #1
    }
    else {
    	currState &= ~LCD_PIN_RS;
    }

    LCD_OUT = currState;
 8006154:	4b05      	ldr	r3, [pc, #20]	; (800616c <__LCD_SendByte+0x50>)
    	currState |= LCD_PIN_RS;
 8006156:	bf0c      	ite	eq
 8006158:	f040 0001 	orreq.w	r0, r0, #1
    	currState &= ~LCD_PIN_RS;
 800615c:	f020 0001 	bicne.w	r0, r0, #1
    LCD_OUT = currState;
 8006160:	6158      	str	r0, [r3, #20]

	__LCD_Pulse();
}
 8006162:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__LCD_Pulse();
 8006166:	f7ff bfcd 	b.w	8006104 <__LCD_Pulse>
 800616a:	bf00      	nop
 800616c:	48000400 	.word	0x48000400

08006170 <myLCD_GotoXY>:
	@param Col [1-16]
	@retVal None
**/
void myLCD_GotoXY(uint8_t Row, uint8_t Col)
{	
	if(Row < 1 || Row > 2) {
 8006170:	1e43      	subs	r3, r0, #1
 8006172:	2b01      	cmp	r3, #1
 8006174:	d80f      	bhi.n	8006196 <myLCD_GotoXY+0x26>
		return;
	}

	if(Col < 1 ||Col > 16) {
 8006176:	3901      	subs	r1, #1
 8006178:	b2c9      	uxtb	r1, r1
 800617a:	290f      	cmp	r1, #15
 800617c:	d80b      	bhi.n	8006196 <myLCD_GotoXY+0x26>
		return;
	}
	
    uint8_t address;
	
	if (Row == 1) {
 800617e:	2801      	cmp	r0, #1
        address = 0;
    }
    else {
        address = 0x40;
 8006180:	bf0c      	ite	eq
 8006182:	2000      	moveq	r0, #0
 8006184:	2040      	movne	r0, #64	; 0x40
    }
	
    address |= Col - 1;
 8006186:	4301      	orrs	r1, r0
    __LCD_SendByte(0x80 | address, FALSE);
 8006188:	f001 007f 	and.w	r0, r1, #127	; 0x7f
 800618c:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8006190:	2100      	movs	r1, #0
 8006192:	f7ff bfc3 	b.w	800611c <__LCD_SendByte>
 8006196:	4770      	bx	lr

08006198 <myLCD_Clear>:
	@brief Clear entire display
	@param none
	@retVal none
**/
void myLCD_Clear(void)
{		
 8006198:	b508      	push	{r3, lr}
	__LCD_SendByte(0x01, FALSE);
 800619a:	2001      	movs	r0, #1
 800619c:	2100      	movs	r1, #0
 800619e:	f7ff ffbd 	bl	800611c <__LCD_SendByte>
	LCD_Delay(3);
 80061a2:	2003      	movs	r0, #3
}
 80061a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LCD_Delay(3);
 80061a8:	f7fd bf46 	b.w	8004038 <osDelay>

080061ac <myLCD_Init>:
	LCD_CLK_ENABLE();
 80061ac:	4b21      	ldr	r3, [pc, #132]	; (8006234 <myLCD_Init+0x88>)
{			
 80061ae:	b530      	push	{r4, r5, lr}
	LCD_CLK_ENABLE();
 80061b0:	695a      	ldr	r2, [r3, #20]
    HAL_GPIO_Init(LCD_GPIO_PORT, &LCD_IO_InitStruct);
 80061b2:	4c21      	ldr	r4, [pc, #132]	; (8006238 <myLCD_Init+0x8c>)
	LCD_CLK_ENABLE();
 80061b4:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80061b8:	615a      	str	r2, [r3, #20]
 80061ba:	695b      	ldr	r3, [r3, #20]
{			
 80061bc:	b087      	sub	sp, #28
	LCD_CLK_ENABLE();
 80061be:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80061c2:	9300      	str	r3, [sp, #0]
 80061c4:	9b00      	ldr	r3, [sp, #0]
    LCD_IO_InitStruct.Pin 	= LCD_PIN_RS | LCD_PIN_EN| LCD_PIN_RW |
 80061c6:	23f7      	movs	r3, #247	; 0xf7
    LCD_IO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80061c8:	2500      	movs	r5, #0
    HAL_GPIO_Init(LCD_GPIO_PORT, &LCD_IO_InitStruct);
 80061ca:	a901      	add	r1, sp, #4
    LCD_IO_InitStruct.Pin 	= LCD_PIN_RS | LCD_PIN_EN| LCD_PIN_RW |
 80061cc:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(LCD_GPIO_PORT, &LCD_IO_InitStruct);
 80061ce:	4620      	mov	r0, r4
    LCD_IO_InitStruct.Mode 	= GPIO_MODE_OUTPUT_PP;
 80061d0:	2301      	movs	r3, #1
 80061d2:	9302      	str	r3, [sp, #8]
    LCD_IO_InitStruct.Pull 	= GPIO_PULLUP;
 80061d4:	9303      	str	r3, [sp, #12]
    LCD_IO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80061d6:	9504      	str	r5, [sp, #16]
    HAL_GPIO_Init(LCD_GPIO_PORT, &LCD_IO_InitStruct);
 80061d8:	f7fb f840 	bl	800125c <HAL_GPIO_Init>
    LCD_Delay(20);					// Wait for power on stabilization
 80061dc:	2014      	movs	r0, #20
 80061de:	f7fd ff2b 	bl	8004038 <osDelay>
    LCD_OUT &= ~(LCD_PIN_RS);		// Will send instruction
 80061e2:	6963      	ldr	r3, [r4, #20]
 80061e4:	f023 0301 	bic.w	r3, r3, #1
 80061e8:	6163      	str	r3, [r4, #20]
    LCD_OUT &= ~(LCD_PIN_RW);		// Data direction MCU -> LCD
 80061ea:	6963      	ldr	r3, [r4, #20]
 80061ec:	f023 0304 	bic.w	r3, r3, #4
 80061f0:	6163      	str	r3, [r4, #20]
    LCD_OUT &= ~(LCD_PIN_EN);		// Reset EN
 80061f2:	6963      	ldr	r3, [r4, #20]
 80061f4:	f023 0302 	bic.w	r3, r3, #2
 80061f8:	6163      	str	r3, [r4, #20]
    LCD_OUT |= (LCD_PIN_EN);		// Enable EN
 80061fa:	6963      	ldr	r3, [r4, #20]
 80061fc:	f043 0302 	orr.w	r3, r3, #2
 8006200:	6163      	str	r3, [r4, #20]
    LCD_OUT |= (LCD_PIN_D5);		// Set pin D5 before enter to 4bit mode (avoid of error on reset)
 8006202:	6963      	ldr	r3, [r4, #20]
 8006204:	f043 0320 	orr.w	r3, r3, #32
 8006208:	6163      	str	r3, [r4, #20]
    LCD_OUT &= ~(LCD_PIN_EN);		// Write to LCD
 800620a:	6963      	ldr	r3, [r4, #20]
 800620c:	f023 0302 	bic.w	r3, r3, #2
 8006210:	6163      	str	r3, [r4, #20]
    __LCD_SendByte(0x28, FALSE);  	// Function set: Set 4bit mode 5x10 dot
 8006212:	4629      	mov	r1, r5
 8006214:	2028      	movs	r0, #40	; 0x28
 8006216:	f7ff ff81 	bl	800611c <__LCD_SendByte>
    __LCD_SendByte(0x0E, FALSE);  	// Display ON/OFF:Display On, cursor is displayed and does not blinks
 800621a:	4629      	mov	r1, r5
 800621c:	200e      	movs	r0, #14
 800621e:	f7ff ff7d 	bl	800611c <__LCD_SendByte>
    __LCD_SendByte(0x06, FALSE);  	// Entry mode set: increment address counter; display will be shifted to the right
 8006222:	4629      	mov	r1, r5
 8006224:	2006      	movs	r0, #6
 8006226:	f7ff ff79 	bl	800611c <__LCD_SendByte>
	myLCD_Clear();
 800622a:	f7ff ffb5 	bl	8006198 <myLCD_Clear>
}
 800622e:	b007      	add	sp, #28
 8006230:	bd30      	pop	{r4, r5, pc}
 8006232:	bf00      	nop
 8006234:	40021000 	.word	0x40021000
 8006238:	48000400 	.word	0x48000400

0800623c <myLCD_PrintStr>:
/**
* Print String 
*
*/
void myLCD_PrintStr(char *Text)
{
 800623c:	b510      	push	{r4, lr}
 800623e:	1e44      	subs	r4, r0, #1
    char *c = Text;

    while ((c != 0) && (*c != 0)) {
 8006240:	1c63      	adds	r3, r4, #1
 8006242:	d002      	beq.n	800624a <myLCD_PrintStr+0xe>
 8006244:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8006248:	b900      	cbnz	r0, 800624c <myLCD_PrintStr+0x10>
 800624a:	bd10      	pop	{r4, pc}
        __LCD_SendByte(*c, TRUE);
 800624c:	2101      	movs	r1, #1
 800624e:	f7ff ff65 	bl	800611c <__LCD_SendByte>
 8006252:	e7f5      	b.n	8006240 <myLCD_PrintStr+0x4>

08006254 <myLCD_PutChar>:
/**
* Put a char
*/
void myLCD_PutChar (char c)
{
	__LCD_SendByte(c,TRUE);
 8006254:	2101      	movs	r1, #1
 8006256:	f7ff bf61 	b.w	800611c <__LCD_SendByte>
	...

0800625c <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];
  
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
 800625c:	4b03      	ldr	r3, [pc, #12]	; (800626c <vApplicationGetIdleTaskMemory+0x10>)
 800625e:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
 8006260:	4b03      	ldr	r3, [pc, #12]	; (8006270 <vApplicationGetIdleTaskMemory+0x14>)
 8006262:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8006264:	2380      	movs	r3, #128	; 0x80
 8006266:	6013      	str	r3, [r2, #0]
 8006268:	4770      	bx	lr
 800626a:	bf00      	nop
 800626c:	20001634 	.word	0x20001634
 8006270:	20001434 	.word	0x20001434

08006274 <vApplicationGetTimerTaskMemory>:
static StaticTask_t xTimerTaskTCBBuffer;
static StackType_t xTimerStack[configTIMER_TASK_STACK_DEPTH];
  
void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize )  
{
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCBBuffer;
 8006274:	4b03      	ldr	r3, [pc, #12]	; (8006284 <vApplicationGetTimerTaskMemory+0x10>)
 8006276:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &xTimerStack[0];
 8006278:	4b03      	ldr	r3, [pc, #12]	; (8006288 <vApplicationGetTimerTaskMemory+0x14>)
 800627a:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 800627c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006280:	6013      	str	r3, [r2, #0]
 8006282:	4770      	bx	lr
 8006284:	20001a88 	.word	0x20001a88
 8006288:	20001688 	.word	0x20001688

0800628c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800628c:	b570      	push	{r4, r5, r6, lr}
 800628e:	b09e      	sub	sp, #120	; 0x78
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInit;

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI
 8006290:	230b      	movs	r3, #11
 8006292:	9305      	str	r3, [sp, #20]
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8006294:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8006298:	9306      	str	r3, [sp, #24]
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 800629a:	2300      	movs	r3, #0
 800629c:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 800629e:	2310      	movs	r3, #16
 80062a0:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80062a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80062a6:	2401      	movs	r4, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80062a8:	2602      	movs	r6, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80062aa:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80062ac:	a805      	add	r0, sp, #20
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 80062ae:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80062b2:	9409      	str	r4, [sp, #36]	; 0x24
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 80062b4:	940b      	str	r4, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80062b6:	960c      	str	r6, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
 80062b8:	930e      	str	r3, [sp, #56]	; 0x38
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80062ba:	f7fc fb0d 	bl	80028d8 <HAL_RCC_OscConfig>
 80062be:	b100      	cbz	r0, 80062c2 <SystemClock_Config+0x36>
 80062c0:	e7fe      	b.n	80062c0 <SystemClock_Config+0x34>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80062c2:	250f      	movs	r5, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80062c4:	9002      	str	r0, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80062c6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80062ca:	9004      	str	r0, [sp, #16]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80062cc:	4621      	mov	r1, r4
 80062ce:	4668      	mov	r0, sp
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80062d0:	e88d 0060 	stmia.w	sp, {r5, r6}
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80062d4:	9303      	str	r3, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 80062d6:	f7fc fda3 	bl	8002e20 <HAL_RCC_ClockConfig>
 80062da:	b100      	cbz	r0, 80062de <SystemClock_Config+0x52>
 80062dc:	e7fe      	b.n	80062dc <SystemClock_Config+0x50>
  {
    _Error_Handler(__FILE__, __LINE__);
  }

  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
 80062de:	4b11      	ldr	r3, [pc, #68]	; (8006324 <SystemClock_Config+0x98>)
 80062e0:	930f      	str	r3, [sp, #60]	; 0x3c
                              |RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_ADC12;
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
  PeriphClkInit.Adc12ClockSelection = RCC_ADC12PLLCLK_DIV1;
 80062e2:	f44f 7380 	mov.w	r3, #256	; 0x100
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80062e6:	9011      	str	r0, [sp, #68]	; 0x44
  PeriphClkInit.Adc12ClockSelection = RCC_ADC12PLLCLK_DIV1;
 80062e8:	9318      	str	r3, [sp, #96]	; 0x60
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
 80062ea:	9016      	str	r0, [sp, #88]	; 0x58
  PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL;
 80062ec:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80062f0:	a80f      	add	r0, sp, #60	; 0x3c
  PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL;
 80062f2:	931d      	str	r3, [sp, #116]	; 0x74
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80062f4:	f7fc fe8c 	bl	8003010 <HAL_RCCEx_PeriphCLKConfig>
 80062f8:	4604      	mov	r4, r0
 80062fa:	b100      	cbz	r0, 80062fe <SystemClock_Config+0x72>
 80062fc:	e7fe      	b.n	80062fc <SystemClock_Config+0x70>
    _Error_Handler(__FILE__, __LINE__);
  }

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 80062fe:	f7fc fe51 	bl	8002fa4 <HAL_RCC_GetHCLKFreq>
 8006302:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8006306:	fbb0 f0f3 	udiv	r0, r0, r3
 800630a:	f7fa fe2d 	bl	8000f68 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800630e:	2004      	movs	r0, #4
 8006310:	f7fa fe40 	bl	8000f94 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8006314:	4622      	mov	r2, r4
 8006316:	4629      	mov	r1, r5
 8006318:	f04f 30ff 	mov.w	r0, #4294967295
 800631c:	f7fa fde4 	bl	8000ee8 <HAL_NVIC_SetPriority>
}
 8006320:	b01e      	add	sp, #120	; 0x78
 8006322:	bd70      	pop	{r4, r5, r6, pc}
 8006324:	000200a1 	.word	0x000200a1

08006328 <main>:
{
 8006328:	b580      	push	{r7, lr}
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800632a:	4c87      	ldr	r4, [pc, #540]	; (8006548 <main+0x220>)
  hi2c1.Instance = I2C1;
 800632c:	4d87      	ldr	r5, [pc, #540]	; (800654c <main+0x224>)
  hi2c1.Init.Timing = 0x2000090E;
 800632e:	f8df 8254 	ldr.w	r8, [pc, #596]	; 8006584 <main+0x25c>
{
 8006332:	b09e      	sub	sp, #120	; 0x78
  HAL_Init();
 8006334:	f7f9 ffb0 	bl	8000298 <HAL_Init>
  SystemClock_Config();
 8006338:	f7ff ffa8 	bl	800628c <SystemClock_Config>
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800633c:	6963      	ldr	r3, [r4, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 800633e:	4884      	ldr	r0, [pc, #528]	; (8006550 <main+0x228>)
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8006340:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8006344:	6163      	str	r3, [r4, #20]
 8006346:	6963      	ldr	r3, [r4, #20]
 8006348:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800634c:	9303      	str	r3, [sp, #12]
 800634e:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8006350:	6963      	ldr	r3, [r4, #20]
 8006352:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8006356:	6163      	str	r3, [r4, #20]
 8006358:	6963      	ldr	r3, [r4, #20]
 800635a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800635e:	9304      	str	r3, [sp, #16]
 8006360:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8006362:	6963      	ldr	r3, [r4, #20]
 8006364:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8006368:	6163      	str	r3, [r4, #20]
 800636a:	6963      	ldr	r3, [r4, #20]
 800636c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8006370:	9305      	str	r3, [sp, #20]
 8006372:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8006374:	6963      	ldr	r3, [r4, #20]
 8006376:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800637a:	6163      	str	r3, [r4, #20]
 800637c:	6963      	ldr	r3, [r4, #20]
 800637e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8006382:	9306      	str	r3, [sp, #24]
 8006384:	9b06      	ldr	r3, [sp, #24]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8006386:	6963      	ldr	r3, [r4, #20]
 8006388:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800638c:	6163      	str	r3, [r4, #20]
 800638e:	6963      	ldr	r3, [r4, #20]
 8006390:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 8006394:	2200      	movs	r2, #0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8006396:	9307      	str	r3, [sp, #28]
  HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 8006398:	f64f 7108 	movw	r1, #65288	; 0xff08
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800639c:	9b07      	ldr	r3, [sp, #28]
  HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 800639e:	f7fb f81f 	bl	80013e0 <HAL_GPIO_WritePin>
                          |LD7_Pin|LD9_Pin|LD10_Pin|LD8_Pin 
                          |LD6_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : DRDY_Pin MEMS_INT3_Pin MEMS_INT4_Pin MEMS_INT1_Pin 
                           MEMS_INT2_Pin */
  GPIO_InitStruct.Pin = DRDY_Pin|MEMS_INT3_Pin|MEMS_INT4_Pin|MEMS_INT1_Pin 
 80063a2:	2337      	movs	r3, #55	; 0x37
                          |MEMS_INT2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80063a4:	2600      	movs	r6, #0
  GPIO_InitStruct.Pin = DRDY_Pin|MEMS_INT3_Pin|MEMS_INT4_Pin|MEMS_INT1_Pin 
 80063a6:	9317      	str	r3, [sp, #92]	; 0x5c
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80063a8:	a917      	add	r1, sp, #92	; 0x5c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80063aa:	4b6a      	ldr	r3, [pc, #424]	; (8006554 <main+0x22c>)
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80063ac:	4868      	ldr	r0, [pc, #416]	; (8006550 <main+0x228>)
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80063ae:	9318      	str	r3, [sp, #96]	; 0x60
                           LD7_Pin LD9_Pin LD10_Pin LD8_Pin 
                           LD6_Pin */
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
                          |LD7_Pin|LD9_Pin|LD10_Pin|LD8_Pin 
                          |LD6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80063b0:	2701      	movs	r7, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80063b2:	9619      	str	r6, [sp, #100]	; 0x64
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80063b4:	f7fa ff52 	bl	800125c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 80063b8:	f64f 7308 	movw	r3, #65288	; 0xff08
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80063bc:	a917      	add	r1, sp, #92	; 0x5c
 80063be:	4864      	ldr	r0, [pc, #400]	; (8006550 <main+0x228>)
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin 
 80063c0:	9317      	str	r3, [sp, #92]	; 0x5c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80063c2:	9718      	str	r7, [sp, #96]	; 0x60
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80063c4:	9619      	str	r6, [sp, #100]	; 0x64
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80063c6:	961a      	str	r6, [sp, #104]	; 0x68
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80063c8:	f7fa ff48 	bl	800125c <HAL_GPIO_Init>

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 80063cc:	a917      	add	r1, sp, #92	; 0x5c
 80063ce:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pin = B1_Pin;
 80063d2:	9717      	str	r7, [sp, #92]	; 0x5c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80063d4:	9618      	str	r6, [sp, #96]	; 0x60
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80063d6:	9619      	str	r6, [sp, #100]	; 0x64
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 80063d8:	f7fa ff40 	bl	800125c <HAL_GPIO_Init>
  __HAL_RCC_DMA2_CLK_ENABLE();
 80063dc:	6963      	ldr	r3, [r4, #20]
 80063de:	f043 0302 	orr.w	r3, r3, #2
 80063e2:	6163      	str	r3, [r4, #20]
 80063e4:	6963      	ldr	r3, [r4, #20]
 80063e6:	f003 0302 	and.w	r3, r3, #2
  HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
 80063ea:	2105      	movs	r1, #5
 80063ec:	4632      	mov	r2, r6
  __HAL_RCC_DMA2_CLK_ENABLE();
 80063ee:	9302      	str	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
 80063f0:	2038      	movs	r0, #56	; 0x38
  __HAL_RCC_DMA2_CLK_ENABLE();
 80063f2:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
 80063f4:	f7fa fd78 	bl	8000ee8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
 80063f8:	2038      	movs	r0, #56	; 0x38
 80063fa:	f7fa fda9 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  hi2c1.Init.Timing = 0x2000090E;
 80063fe:	4b56      	ldr	r3, [pc, #344]	; (8006558 <main+0x230>)
  hi2c1.Init.OwnAddress1 = 0;
 8006400:	60ae      	str	r6, [r5, #8]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8006402:	4628      	mov	r0, r5
  hi2c1.Init.Timing = 0x2000090E;
 8006404:	e885 0108 	stmia.w	r5, {r3, r8}
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8006408:	60ef      	str	r7, [r5, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800640a:	612e      	str	r6, [r5, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800640c:	616e      	str	r6, [r5, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800640e:	61ae      	str	r6, [r5, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8006410:	61ee      	str	r6, [r5, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8006412:	622e      	str	r6, [r5, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8006414:	f7fb f829 	bl	800146a <HAL_I2C_Init>
 8006418:	4601      	mov	r1, r0
 800641a:	b100      	cbz	r0, 800641e <main+0xf6>
 800641c:	e7fe      	b.n	800641c <main+0xf4>
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800641e:	4628      	mov	r0, r5
 8006420:	f7fb faee 	bl	8001a00 <HAL_I2CEx_ConfigAnalogFilter>
 8006424:	4601      	mov	r1, r0
 8006426:	b100      	cbz	r0, 800642a <main+0x102>
 8006428:	e7fe      	b.n	8006428 <main+0x100>
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 800642a:	4628      	mov	r0, r5
 800642c:	f7fb fb0e 	bl	8001a4c <HAL_I2CEx_ConfigDigitalFilter>
 8006430:	b100      	cbz	r0, 8006434 <main+0x10c>
 8006432:	e7fe      	b.n	8006432 <main+0x10a>
  hspi1.Instance = SPI1;
 8006434:	4b49      	ldr	r3, [pc, #292]	; (800655c <main+0x234>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8006436:	4a4a      	ldr	r2, [pc, #296]	; (8006560 <main+0x238>)
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8006438:	6098      	str	r0, [r3, #8]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 800643a:	f44f 7c82 	mov.w	ip, #260	; 0x104
 800643e:	e883 1004 	stmia.w	r3, {r2, ip}
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 8006442:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006446:	60da      	str	r2, [r3, #12]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8006448:	f44f 7200 	mov.w	r2, #512	; 0x200
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800644c:	2608      	movs	r6, #8
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800644e:	6118      	str	r0, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8006450:	6158      	str	r0, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8006452:	619a      	str	r2, [r3, #24]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8006454:	6218      	str	r0, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8006456:	6258      	str	r0, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8006458:	6298      	str	r0, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 800645a:	2207      	movs	r2, #7
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 800645c:	6318      	str	r0, [r3, #48]	; 0x30
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800645e:	4618      	mov	r0, r3
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 8006460:	61de      	str	r6, [r3, #28]
  hspi1.Init.CRCPolynomial = 7;
 8006462:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8006464:	635e      	str	r6, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8006466:	f7fc fed9 	bl	800321c <HAL_SPI_Init>
 800646a:	b100      	cbz	r0, 800646e <main+0x146>
 800646c:	e7fe      	b.n	800646c <main+0x144>
  huart1.Instance = USART1;
 800646e:	4d3d      	ldr	r5, [pc, #244]	; (8006564 <main+0x23c>)
  huart1.Init.BaudRate = 115200;
 8006470:	4b3d      	ldr	r3, [pc, #244]	; (8006568 <main+0x240>)
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8006472:	60a8      	str	r0, [r5, #8]
  huart1.Init.BaudRate = 115200;
 8006474:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
 8006478:	e885 4008 	stmia.w	r5, {r3, lr}
  huart1.Init.StopBits = UART_STOPBITS_1;
 800647c:	60e8      	str	r0, [r5, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 800647e:	6128      	str	r0, [r5, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8006480:	230c      	movs	r3, #12
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006482:	61a8      	str	r0, [r5, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8006484:	61e8      	str	r0, [r5, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8006486:	6228      	str	r0, [r5, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8006488:	6268      	str	r0, [r5, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800648a:	4628      	mov	r0, r5
  huart1.Init.Mode = UART_MODE_TX_RX;
 800648c:	616b      	str	r3, [r5, #20]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 800648e:	f7fd f958 	bl	8003742 <HAL_UART_Init>
 8006492:	4680      	mov	r8, r0
 8006494:	b100      	cbz	r0, 8006498 <main+0x170>
 8006496:	e7fe      	b.n	8006496 <main+0x16e>
  __HAL_UART_ENABLE_IT(&huart1, UART_IT_RXNE);
 8006498:	682a      	ldr	r2, [r5, #0]
 800649a:	6813      	ldr	r3, [r2, #0]
 800649c:	f043 0320 	orr.w	r3, r3, #32
 80064a0:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriority(USART1_IRQn, 10, 0);
 80064a2:	210a      	movs	r1, #10
 80064a4:	4602      	mov	r2, r0
 80064a6:	2025      	movs	r0, #37	; 0x25
 80064a8:	f7fa fd1e 	bl	8000ee8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART1_IRQn);
 80064ac:	2025      	movs	r0, #37	; 0x25
 80064ae:	f7fa fd4f 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  hcrc.Instance = CRC;
 80064b2:	482e      	ldr	r0, [pc, #184]	; (800656c <main+0x244>)
 80064b4:	4b2e      	ldr	r3, [pc, #184]	; (8006570 <main+0x248>)
 80064b6:	6003      	str	r3, [r0, #0]
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 80064b8:	f880 8004 	strb.w	r8, [r0, #4]
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
 80064bc:	f880 8005 	strb.w	r8, [r0, #5]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 80064c0:	f8c0 8014 	str.w	r8, [r0, #20]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 80064c4:	f8c0 8018 	str.w	r8, [r0, #24]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 80064c8:	6207      	str	r7, [r0, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 80064ca:	f7fa fd6f 	bl	8000fac <HAL_CRC_Init>
 80064ce:	b100      	cbz	r0, 80064d2 <main+0x1aa>
 80064d0:	e7fe      	b.n	80064d0 <main+0x1a8>
  hiwdg.Instance = IWDG;
 80064d2:	4828      	ldr	r0, [pc, #160]	; (8006574 <main+0x24c>)
  hiwdg.Init.Prescaler = IWDG_PRESCALER_16;
 80064d4:	4b28      	ldr	r3, [pc, #160]	; (8006578 <main+0x250>)
 80064d6:	f04f 0802 	mov.w	r8, #2
 80064da:	e880 0108 	stmia.w	r0, {r3, r8}
  hiwdg.Init.Window = 4095;
 80064de:	f640 73ff 	movw	r3, #4095	; 0xfff
 80064e2:	60c3      	str	r3, [r0, #12]
  hiwdg.Init.Reload = 4095;
 80064e4:	6083      	str	r3, [r0, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 80064e6:	f7fb fad6 	bl	8001a96 <HAL_IWDG_Init>
 80064ea:	b100      	cbz	r0, 80064ee <main+0x1c6>
 80064ec:	e7fe      	b.n	80064ec <main+0x1c4>
  hadc2.Instance 					= ADC2;
 80064ee:	4d23      	ldr	r5, [pc, #140]	; (800657c <main+0x254>)
 80064f0:	4b23      	ldr	r3, [pc, #140]	; (8006580 <main+0x258>)
  hadc2.Init.ClockPrescaler 		= ADC_CLOCK_ASYNC_DIV1;
 80064f2:	6068      	str	r0, [r5, #4]
  hadc2.Init.Resolution 			= ADC_RESOLUTION_12B;
 80064f4:	60a8      	str	r0, [r5, #8]
  hadc2.Init.ContinuousConvMode 	= DISABLE;
 80064f6:	61e8      	str	r0, [r5, #28]
  hadc2.Init.DiscontinuousConvMode 	= DISABLE;
 80064f8:	6268      	str	r0, [r5, #36]	; 0x24
  hadc2.Init.ExternalTrigConvEdge 	= ADC_EXTERNALTRIGCONVEDGE_NONE;
 80064fa:	6328      	str	r0, [r5, #48]	; 0x30
  hadc2.Init.DataAlign 				= ADC_DATAALIGN_RIGHT;
 80064fc:	60e8      	str	r0, [r5, #12]
  hadc2.Init.LowPowerAutoWait 		= DISABLE;
 80064fe:	61a8      	str	r0, [r5, #24]
  hadc2.Init.Overrun 				= ADC_OVR_DATA_OVERWRITTEN;
 8006500:	63a8      	str	r0, [r5, #56]	; 0x38
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8006502:	4628      	mov	r0, r5
  hadc2.Instance 					= ADC2;
 8006504:	602b      	str	r3, [r5, #0]
  hadc2.Init.ScanConvMode 			= ADC_SCAN_ENABLE;
 8006506:	612f      	str	r7, [r5, #16]
  hadc2.Init.ExternalTrigConv 		= ADC_SOFTWARE_START;
 8006508:	62ef      	str	r7, [r5, #44]	; 0x2c
  hadc2.Init.NbrOfConversion 		= 2;
 800650a:	f8c5 8020 	str.w	r8, [r5, #32]
  hadc2.Init.DMAContinuousRequests 	= ENABLE;
 800650e:	636f      	str	r7, [r5, #52]	; 0x34
  hadc2.Init.EOCSelection 			= ADC_EOC_SEQ_CONV;
 8006510:	616e      	str	r6, [r5, #20]
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8006512:	f7f9 ff79 	bl	8000408 <HAL_ADC_Init>
 8006516:	b100      	cbz	r0, 800651a <main+0x1f2>
 8006518:	e7fe      	b.n	8006518 <main+0x1f0>
  sConfig.SingleDiff 				= ADC_SINGLE_ENDED;
 800651a:	901a      	str	r0, [sp, #104]	; 0x68
  sConfig.SamplingTime 				= ADC_SAMPLETIME_1CYCLE_5;
 800651c:	9019      	str	r0, [sp, #100]	; 0x64
  sConfig.OffsetNumber 				= ADC_OFFSET_NONE;
 800651e:	901b      	str	r0, [sp, #108]	; 0x6c
  sConfig.Offset 					= 0;
 8006520:	901c      	str	r0, [sp, #112]	; 0x70
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8006522:	a917      	add	r1, sp, #92	; 0x5c
 8006524:	4628      	mov	r0, r5
  sConfig.Channel 					= ADC_CHANNEL_1;
 8006526:	9717      	str	r7, [sp, #92]	; 0x5c
  sConfig.Rank 						= ADC_REGULAR_RANK_1;
 8006528:	9718      	str	r7, [sp, #96]	; 0x60
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 800652a:	f7fa fb33 	bl	8000b94 <HAL_ADC_ConfigChannel>
 800652e:	b100      	cbz	r0, 8006532 <main+0x20a>
 8006530:	e7fe      	b.n	8006530 <main+0x208>
  sConfig.Channel					= ADC_CHANNEL_6;
 8006532:	2306      	movs	r3, #6
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8006534:	a917      	add	r1, sp, #92	; 0x5c
 8006536:	4628      	mov	r0, r5
  sConfig.Channel					= ADC_CHANNEL_6;
 8006538:	9317      	str	r3, [sp, #92]	; 0x5c
  sConfig.Rank 						= ADC_REGULAR_RANK_2;
 800653a:	f8cd 8060 	str.w	r8, [sp, #96]	; 0x60
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 800653e:	f7fa fb29 	bl	8000b94 <HAL_ADC_ConfigChannel>
 8006542:	b308      	cbz	r0, 8006588 <main+0x260>
 8006544:	e7fe      	b.n	8006544 <main+0x21c>
 8006546:	bf00      	nop
 8006548:	40021000 	.word	0x40021000
 800654c:	200021a8 	.word	0x200021a8
 8006550:	48001000 	.word	0x48001000
 8006554:	10120000 	.word	0x10120000
 8006558:	40005400 	.word	0x40005400
 800655c:	200022dc 	.word	0x200022dc
 8006560:	40013000 	.word	0x40013000
 8006564:	2000226c 	.word	0x2000226c
 8006568:	40013800 	.word	0x40013800
 800656c:	20002204 	.word	0x20002204
 8006570:	40023000 	.word	0x40023000
 8006574:	200021f4 	.word	0x200021f4
 8006578:	40003000 	.word	0x40003000
 800657c:	20002154 	.word	0x20002154
 8006580:	50000100 	.word	0x50000100
 8006584:	2000090e 	.word	0x2000090e
  __HAL_ADC_ENABLE_IT(&hadc2, ADC_IT_EOC);
 8006588:	682a      	ldr	r2, [r5, #0]
 800658a:	6853      	ldr	r3, [r2, #4]
 800658c:	f043 0304 	orr.w	r3, r3, #4
 8006590:	6053      	str	r3, [r2, #4]
  HAL_NVIC_SetPriority(ADC1_2_IRQn, 10, 0);
 8006592:	210a      	movs	r1, #10
 8006594:	2200      	movs	r2, #0
 8006596:	2012      	movs	r0, #18
 8006598:	f7fa fca6 	bl	8000ee8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 800659c:	2012      	movs	r0, #18
 800659e:	f7fa fcd7 	bl	8000f50 <HAL_NVIC_EnableIRQ>

extern void DMA1Chan1_Complete(struct __DMA_HandleTypeDef * hdma);
static void DMA1_Init (void)
{
#if DMA1_TEST_EN
	__HAL_RCC_DMA1_CLK_ENABLE();
 80065a2:	6963      	ldr	r3, [r4, #20]

	hdma1.Instance 					= DMA1_Channel1;
	hdma1.Init.Direction			= DMA_MEMORY_TO_MEMORY;
	hdma1.Init.PeriphInc			= DMA_PINC_ENABLE;
	hdma1.Init.MemInc				= DMA_MINC_ENABLE;
 80065a4:	4839      	ldr	r0, [pc, #228]	; (800668c <main+0x364>)
	__HAL_RCC_DMA1_CLK_ENABLE();
 80065a6:	f043 0301 	orr.w	r3, r3, #1
 80065aa:	6163      	str	r3, [r4, #20]
 80065ac:	6963      	ldr	r3, [r4, #20]
	hdma1.Instance 					= DMA1_Channel1;
 80065ae:	4c38      	ldr	r4, [pc, #224]	; (8006690 <main+0x368>)
	__HAL_RCC_DMA1_CLK_ENABLE();
 80065b0:	f003 0301 	and.w	r3, r3, #1
 80065b4:	9301      	str	r3, [sp, #4]
	hdma1.Init.MemInc				= DMA_MINC_ENABLE;
 80065b6:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80065ba:	2240      	movs	r2, #64	; 0x40
	__HAL_RCC_DMA1_CLK_ENABLE();
 80065bc:	9b01      	ldr	r3, [sp, #4]
	hdma1.Init.MemInc				= DMA_MINC_ENABLE;
 80065be:	2380      	movs	r3, #128	; 0x80
	hdma1.Init.PeriphDataAlignment 	= DMA_PDATAALIGN_BYTE;
 80065c0:	2500      	movs	r5, #0
	hdma1.Init.MemInc				= DMA_MINC_ENABLE;
 80065c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	hdma1.Init.MemDataAlignment		= DMA_PDATAALIGN_BYTE;
	hdma1.Init.Mode					= DMA_NORMAL;
	hdma1.Init.Priority				= DMA_PRIORITY_MEDIUM;
 80065c6:	f44f 5380 	mov.w	r3, #4096	; 0x1000

	HAL_DMA_Init(&hdma1);
 80065ca:	4620      	mov	r0, r4
	hdma1.Init.Priority				= DMA_PRIORITY_MEDIUM;
 80065cc:	61e3      	str	r3, [r4, #28]
	hdma1.Init.PeriphDataAlignment 	= DMA_PDATAALIGN_BYTE;
 80065ce:	6125      	str	r5, [r4, #16]
	hdma1.Init.MemDataAlignment		= DMA_PDATAALIGN_BYTE;
 80065d0:	6165      	str	r5, [r4, #20]
	hdma1.Init.Mode					= DMA_NORMAL;
 80065d2:	61a5      	str	r5, [r4, #24]
	HAL_DMA_Init(&hdma1);
 80065d4:	f7fa fd6e 	bl	80010b4 <HAL_DMA_Init>
	__HAL_DMA_ENABLE_IT(&hdma1, DMA_IT_TC);
 80065d8:	6822      	ldr	r2, [r4, #0]
 80065da:	6813      	ldr	r3, [r2, #0]
 80065dc:	f043 0302 	orr.w	r3, r3, #2
 80065e0:	6013      	str	r3, [r2, #0]

	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 6, 0);
 80065e2:	2106      	movs	r1, #6
 80065e4:	462a      	mov	r2, r5
 80065e6:	200b      	movs	r0, #11
 80065e8:	f7fa fc7e 	bl	8000ee8 <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 80065ec:	200b      	movs	r0, #11
 80065ee:	f7fa fcaf 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  debug_printf("STM32F3Discovery build %s - %s\r\n", __DATE__, __TIME__);
 80065f2:	4a28      	ldr	r2, [pc, #160]	; (8006694 <main+0x36c>)

	hdma1.XferCpltCallback 	= DMA1Chan1_Complete;
 80065f4:	4b28      	ldr	r3, [pc, #160]	; (8006698 <main+0x370>)
  debug_printf("STM32F3Discovery build %s - %s\r\n", __DATE__, __TIME__);
 80065f6:	4929      	ldr	r1, [pc, #164]	; (800669c <main+0x374>)
 80065f8:	4829      	ldr	r0, [pc, #164]	; (80066a0 <main+0x378>)
	hdma1.XferCpltCallback 	= DMA1Chan1_Complete;
 80065fa:	62a3      	str	r3, [r4, #40]	; 0x28
  debug_printf("STM32F3Discovery build %s - %s\r\n", __DATE__, __TIME__);
 80065fc:	f7ff fd6b 	bl	80060d6 <debug_printf>
  myBinarySem01Handle = osSemaphoreCreate(osSemaphore(myBinarySem01), 1);
 8006600:	2101      	movs	r1, #1
 8006602:	a808      	add	r0, sp, #32
  osSemaphoreDef(myBinarySem01);
 8006604:	9508      	str	r5, [sp, #32]
 8006606:	9509      	str	r5, [sp, #36]	; 0x24
  myBinarySem01Handle = osSemaphoreCreate(osSemaphore(myBinarySem01), 1);
 8006608:	f7fd fd64 	bl	80040d4 <osSemaphoreCreate>
 800660c:	4b25      	ldr	r3, [pc, #148]	; (80066a4 <main+0x37c>)
  osSemaphoreDef(lcdSem);
 800660e:	950a      	str	r5, [sp, #40]	; 0x28
  myBinarySem01Handle = osSemaphoreCreate(osSemaphore(myBinarySem01), 1);
 8006610:	6018      	str	r0, [r3, #0]
  lcdSemHandle = osSemaphoreCreate(osSemaphore(lcdSem), 1);
 8006612:	2101      	movs	r1, #1
 8006614:	a80a      	add	r0, sp, #40	; 0x28
  osSemaphoreDef(lcdSem);
 8006616:	950b      	str	r5, [sp, #44]	; 0x2c
  lcdSemHandle = osSemaphoreCreate(osSemaphore(lcdSem), 1);
 8006618:	f7fd fd5c 	bl	80040d4 <osSemaphoreCreate>
 800661c:	4b22      	ldr	r3, [pc, #136]	; (80066a8 <main+0x380>)
  osSemaphoreDef(dma1Sem);
 800661e:	950c      	str	r5, [sp, #48]	; 0x30
  lcdSemHandle = osSemaphoreCreate(osSemaphore(lcdSem), 1);
 8006620:	6018      	str	r0, [r3, #0]
  dma1SemHandle= osSemaphoreCreate(osSemaphore(dma1Sem), 1);
 8006622:	2101      	movs	r1, #1
 8006624:	a80c      	add	r0, sp, #48	; 0x30
  osSemaphoreDef(dma1Sem);
 8006626:	950d      	str	r5, [sp, #52]	; 0x34
  dma1SemHandle= osSemaphoreCreate(osSemaphore(dma1Sem), 1);
 8006628:	f7fd fd54 	bl	80040d4 <osSemaphoreCreate>
 800662c:	4b1f      	ldr	r3, [pc, #124]	; (80066ac <main+0x384>)
  osThreadDef(defaultTask, DefaultTask, osPriorityNormal, 0, 128);
 800662e:	4c20      	ldr	r4, [pc, #128]	; (80066b0 <main+0x388>)
  dma1SemHandle= osSemaphoreCreate(osSemaphore(dma1Sem), 1);
 8006630:	6018      	str	r0, [r3, #0]
  osSemaphoreWait(dma1SemHandle, portMAX_DELAY);
 8006632:	f04f 31ff 	mov.w	r1, #4294967295
 8006636:	f7fd fd7d 	bl	8004134 <osSemaphoreWait>
  osTimerDef(SwTmr01, SwTmrCallback);
 800663a:	4b1e      	ldr	r3, [pc, #120]	; (80066b4 <main+0x38c>)
 800663c:	930e      	str	r3, [sp, #56]	; 0x38
  SwTmr01Handle = osTimerCreate(osTimer(SwTmr01), osTimerPeriodic, NULL);
 800663e:	462a      	mov	r2, r5
 8006640:	2101      	movs	r1, #1
 8006642:	a80e      	add	r0, sp, #56	; 0x38
  osTimerDef(SwTmr01, SwTmrCallback);
 8006644:	950f      	str	r5, [sp, #60]	; 0x3c
  SwTmr01Handle = osTimerCreate(osTimer(SwTmr01), osTimerPeriodic, NULL);
 8006646:	f7fd fcff 	bl	8004048 <osTimerCreate>
 800664a:	4b1b      	ldr	r3, [pc, #108]	; (80066b8 <main+0x390>)
 800664c:	6018      	str	r0, [r3, #0]
  osThreadDef(defaultTask, DefaultTask, osPriorityNormal, 0, 128);
 800664e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006650:	ae10      	add	r6, sp, #64	; 0x40
 8006652:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8006654:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8006658:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  DefaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 800665c:	4629      	mov	r1, r5
 800665e:	a810      	add	r0, sp, #64	; 0x40
 8006660:	f7fd fcc2 	bl	8003fe8 <osThreadCreate>
 8006664:	4b15      	ldr	r3, [pc, #84]	; (80066bc <main+0x394>)
  osThreadDef(crcTask, ProcessCmdTask, osPriorityAboveNormal, 0, 128);
 8006666:	340c      	adds	r4, #12
  DefaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8006668:	6018      	str	r0, [r3, #0]
  osThreadDef(crcTask, ProcessCmdTask, osPriorityAboveNormal, 0, 128);
 800666a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800666c:	ae17      	add	r6, sp, #92	; 0x5c
 800666e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8006670:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8006674:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  ProcessCmdTaskHandle = osThreadCreate(osThread(crcTask), NULL);
 8006678:	4629      	mov	r1, r5
 800667a:	a817      	add	r0, sp, #92	; 0x5c
 800667c:	f7fd fcb4 	bl	8003fe8 <osThreadCreate>
 8006680:	4b0f      	ldr	r3, [pc, #60]	; (80066c0 <main+0x398>)
 8006682:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8006684:	f7fd fcab 	bl	8003fde <osKernelStart>
 8006688:	e7fe      	b.n	8006688 <main+0x360>
 800668a:	bf00      	nop
 800668c:	40020008 	.word	0x40020008
 8006690:	20002228 	.word	0x20002228
 8006694:	08007a51 	.word	0x08007a51
 8006698:	080069f5 	.word	0x080069f5
 800669c:	08007a5a 	.word	0x08007a5a
 80066a0:	08007a66 	.word	0x08007a66
 80066a4:	20002394 	.word	0x20002394
 80066a8:	2000239c 	.word	0x2000239c
 80066ac:	2000238c 	.word	0x2000238c
 80066b0:	080079dc 	.word	0x080079dc
 80066b4:	08006b85 	.word	0x08006b85
 80066b8:	20002388 	.word	0x20002388
 80066bc:	20002384 	.word	0x20002384
 80066c0:	20002398 	.word	0x20002398

080066c4 <_Error_Handler>:
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
 80066c4:	e7fe      	b.n	80066c4 <_Error_Handler>
	...

080066c8 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80066c8:	4b1d      	ldr	r3, [pc, #116]	; (8006740 <HAL_MspInit+0x78>)
{
 80066ca:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80066cc:	699a      	ldr	r2, [r3, #24]
 80066ce:	f042 0201 	orr.w	r2, r2, #1
 80066d2:	619a      	str	r2, [r3, #24]
 80066d4:	699b      	ldr	r3, [r3, #24]
 80066d6:	f003 0301 	and.w	r3, r3, #1
 80066da:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80066dc:	2003      	movs	r0, #3
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80066de:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80066e0:	f7fa fbf0 	bl	8000ec4 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80066e4:	2200      	movs	r2, #0
 80066e6:	4611      	mov	r1, r2
 80066e8:	f06f 000b 	mvn.w	r0, #11
 80066ec:	f7fa fbfc 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80066f0:	2200      	movs	r2, #0
 80066f2:	4611      	mov	r1, r2
 80066f4:	f06f 000a 	mvn.w	r0, #10
 80066f8:	f7fa fbf6 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80066fc:	2200      	movs	r2, #0
 80066fe:	4611      	mov	r1, r2
 8006700:	f06f 0009 	mvn.w	r0, #9
 8006704:	f7fa fbf0 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8006708:	2200      	movs	r2, #0
 800670a:	4611      	mov	r1, r2
 800670c:	f06f 0004 	mvn.w	r0, #4
 8006710:	f7fa fbea 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8006714:	2200      	movs	r2, #0
 8006716:	4611      	mov	r1, r2
 8006718:	f06f 0003 	mvn.w	r0, #3
 800671c:	f7fa fbe4 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8006720:	2200      	movs	r2, #0
 8006722:	210f      	movs	r1, #15
 8006724:	f06f 0001 	mvn.w	r0, #1
 8006728:	f7fa fbde 	bl	8000ee8 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 800672c:	2200      	movs	r2, #0
 800672e:	210f      	movs	r1, #15
 8006730:	f04f 30ff 	mov.w	r0, #4294967295
 8006734:	f7fa fbd8 	bl	8000ee8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8006738:	b003      	add	sp, #12
 800673a:	f85d fb04 	ldr.w	pc, [sp], #4
 800673e:	bf00      	nop
 8006740:	40021000 	.word	0x40021000

08006744 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8006744:	b570      	push	{r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hadc->Instance==ADC2)
 8006746:	6802      	ldr	r2, [r0, #0]
 8006748:	4b22      	ldr	r3, [pc, #136]	; (80067d4 <HAL_ADC_MspInit+0x90>)
 800674a:	429a      	cmp	r2, r3
{
 800674c:	b086      	sub	sp, #24
 800674e:	4606      	mov	r6, r0
  if(hadc->Instance==ADC2)
 8006750:	d13d      	bne.n	80067ce <HAL_ADC_MspInit+0x8a>
  {
  /* USER CODE BEGIN ADC2_MspInit 0 */

  /* USER CODE END ADC2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC12_CLK_ENABLE();
 8006752:	4b21      	ldr	r3, [pc, #132]	; (80067d8 <HAL_ADC_MspInit+0x94>)
 8006754:	695a      	ldr	r2, [r3, #20]
 8006756:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800675a:	615a      	str	r2, [r3, #20]
 800675c:	695b      	ldr	r3, [r3, #20]
 800675e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8006762:	9300      	str	r3, [sp, #0]
    /**ADC2 GPIO Configuration    
    PA4     ------> ADC2_IN1 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006764:	2500      	movs	r5, #0
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006766:	2403      	movs	r4, #3
    __HAL_RCC_ADC12_CLK_ENABLE();
 8006768:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800676a:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 800676c:	2310      	movs	r3, #16
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800676e:	a901      	add	r1, sp, #4
 8006770:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Pin = GPIO_PIN_4;
 8006774:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006776:	9503      	str	r5, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006778:	f7fa fd70 	bl	800125c <HAL_GPIO_Init>

    /*
     * PC0 --> ADC2_IN6
     */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 800677c:	2301      	movs	r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800677e:	4817      	ldr	r0, [pc, #92]	; (80067dc <HAL_ADC_MspInit+0x98>)
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8006780:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006782:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006784:	9402      	str	r4, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006786:	9503      	str	r5, [sp, #12]

    /* ADC2 DMA Init */
    /* ADC2 Init */
    hdma_adc2.Instance = DMA2_Channel1;
 8006788:	4c15      	ldr	r4, [pc, #84]	; (80067e0 <HAL_ADC_MspInit+0x9c>)
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800678a:	f7fa fd67 	bl	800125c <HAL_GPIO_Init>
    hdma_adc2.Instance = DMA2_Channel1;
 800678e:	4b15      	ldr	r3, [pc, #84]	; (80067e4 <HAL_ADC_MspInit+0xa0>)
    hdma_adc2.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc2.Init.PeriphInc = DMA_PINC_DISABLE;
 8006790:	60a5      	str	r5, [r4, #8]
    hdma_adc2.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8006792:	e884 0028 	stmia.w	r4, {r3, r5}
    hdma_adc2.Init.MemInc = DMA_MINC_ENABLE;
 8006796:	2380      	movs	r3, #128	; 0x80
 8006798:	60e3      	str	r3, [r4, #12]
    hdma_adc2.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800679a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800679e:	6123      	str	r3, [r4, #16]
    hdma_adc2.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc2.Init.Mode = DMA_NORMAL;
    hdma_adc2.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_adc2) != HAL_OK)
 80067a0:	4620      	mov	r0, r4
    hdma_adc2.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 80067a2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80067a6:	6163      	str	r3, [r4, #20]
    hdma_adc2.Init.Mode = DMA_NORMAL;
 80067a8:	61a5      	str	r5, [r4, #24]
    hdma_adc2.Init.Priority = DMA_PRIORITY_LOW;
 80067aa:	61e5      	str	r5, [r4, #28]
    if (HAL_DMA_Init(&hdma_adc2) != HAL_OK)
 80067ac:	f7fa fc82 	bl	80010b4 <HAL_DMA_Init>
 80067b0:	b118      	cbz	r0, 80067ba <HAL_ADC_MspInit+0x76>
    {
      _Error_Handler(__FILE__, __LINE__);
 80067b2:	2185      	movs	r1, #133	; 0x85
 80067b4:	480c      	ldr	r0, [pc, #48]	; (80067e8 <HAL_ADC_MspInit+0xa4>)
 80067b6:	f7ff ff85 	bl	80066c4 <_Error_Handler>
    }

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc2);

    /* ADC2 interrupt Init */
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 6, 0);
 80067ba:	2012      	movs	r0, #18
    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc2);
 80067bc:	63f4      	str	r4, [r6, #60]	; 0x3c
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 6, 0);
 80067be:	2200      	movs	r2, #0
 80067c0:	2106      	movs	r1, #6
    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc2);
 80067c2:	6266      	str	r6, [r4, #36]	; 0x24
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 6, 0);
 80067c4:	f7fa fb90 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 80067c8:	2012      	movs	r0, #18
 80067ca:	f7fa fbc1 	bl	8000f50 <HAL_NVIC_EnableIRQ>

  }
}
 80067ce:	b006      	add	sp, #24
 80067d0:	bd70      	pop	{r4, r5, r6, pc}
 80067d2:	bf00      	nop
 80067d4:	50000100 	.word	0x50000100
 80067d8:	40021000 	.word	0x40021000
 80067dc:	48000800 	.word	0x48000800
 80067e0:	20002340 	.word	0x20002340
 80067e4:	40020408 	.word	0x40020408
 80067e8:	08007a9b 	.word	0x08007a9b

080067ec <HAL_CRC_MspInit>:
}

void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{

  if(hcrc->Instance==CRC)
 80067ec:	6802      	ldr	r2, [r0, #0]
 80067ee:	4b08      	ldr	r3, [pc, #32]	; (8006810 <HAL_CRC_MspInit+0x24>)
 80067f0:	429a      	cmp	r2, r3
{
 80067f2:	b082      	sub	sp, #8
  if(hcrc->Instance==CRC)
 80067f4:	d10a      	bne.n	800680c <HAL_CRC_MspInit+0x20>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 80067f6:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
 80067fa:	695a      	ldr	r2, [r3, #20]
 80067fc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006800:	615a      	str	r2, [r3, #20]
 8006802:	695b      	ldr	r3, [r3, #20]
 8006804:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006808:	9301      	str	r3, [sp, #4]
 800680a:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 800680c:	b002      	add	sp, #8
 800680e:	4770      	bx	lr
 8006810:	40023000 	.word	0x40023000

08006814 <HAL_I2C_MspInit>:
  }

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8006814:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hi2c->Instance==I2C1)
 8006816:	6802      	ldr	r2, [r0, #0]
 8006818:	4b17      	ldr	r3, [pc, #92]	; (8006878 <HAL_I2C_MspInit+0x64>)
 800681a:	429a      	cmp	r2, r3
 800681c:	d128      	bne.n	8006870 <HAL_I2C_MspInit+0x5c>
  
    /**I2C1 GPIO Configuration    
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = I2C1_SCL_Pin|I2C1_SDA_Pin;
 800681e:	23c0      	movs	r3, #192	; 0xc0
 8006820:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8006822:	2312      	movs	r3, #18
 8006824:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8006826:	2301      	movs	r3, #1
 8006828:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800682a:	2303      	movs	r3, #3
 800682c:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 800682e:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006830:	eb0d 0103 	add.w	r1, sp, r3
 8006834:	4811      	ldr	r0, [pc, #68]	; (800687c <HAL_I2C_MspInit+0x68>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8006836:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006838:	f7fa fd10 	bl	800125c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 800683c:	4b10      	ldr	r3, [pc, #64]	; (8006880 <HAL_I2C_MspInit+0x6c>)
 800683e:	69da      	ldr	r2, [r3, #28]
 8006840:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8006844:	61da      	str	r2, [r3, #28]
 8006846:	69db      	ldr	r3, [r3, #28]
 8006848:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
 800684c:	2200      	movs	r2, #0
 800684e:	2105      	movs	r1, #5
    __HAL_RCC_I2C1_CLK_ENABLE();
 8006850:	9300      	str	r3, [sp, #0]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
 8006852:	201f      	movs	r0, #31
    __HAL_RCC_I2C1_CLK_ENABLE();
 8006854:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 5, 0);
 8006856:	f7fa fb47 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 800685a:	201f      	movs	r0, #31
 800685c:	f7fa fb78 	bl	8000f50 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 5, 0);
 8006860:	2020      	movs	r0, #32
 8006862:	2200      	movs	r2, #0
 8006864:	2105      	movs	r1, #5
 8006866:	f7fa fb3f 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 800686a:	2020      	movs	r0, #32
 800686c:	f7fa fb70 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 8006870:	b007      	add	sp, #28
 8006872:	f85d fb04 	ldr.w	pc, [sp], #4
 8006876:	bf00      	nop
 8006878:	40005400 	.word	0x40005400
 800687c:	48000400 	.word	0x48000400
 8006880:	40021000 	.word	0x40021000

08006884 <HAL_SPI_MspInit>:
  }

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8006884:	b530      	push	{r4, r5, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI1)
 8006886:	6802      	ldr	r2, [r0, #0]
 8006888:	4b13      	ldr	r3, [pc, #76]	; (80068d8 <HAL_SPI_MspInit+0x54>)
 800688a:	429a      	cmp	r2, r3
{
 800688c:	b087      	sub	sp, #28
  if(hspi->Instance==SPI1)
 800688e:	d121      	bne.n	80068d4 <HAL_SPI_MspInit+0x50>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8006890:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI 
    */
    GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MISOA7_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006894:	2500      	movs	r5, #0
    __HAL_RCC_SPI1_CLK_ENABLE();
 8006896:	699a      	ldr	r2, [r3, #24]
 8006898:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800689c:	619a      	str	r2, [r3, #24]
 800689e:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80068a0:	9503      	str	r5, [sp, #12]
    __HAL_RCC_SPI1_CLK_ENABLE();
 80068a2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80068a6:	9300      	str	r3, [sp, #0]
 80068a8:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MISOA7_Pin;
 80068aa:	23e0      	movs	r3, #224	; 0xe0
 80068ac:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80068ae:	2302      	movs	r3, #2
 80068b0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80068b2:	2405      	movs	r4, #5
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80068b4:	2303      	movs	r3, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80068b6:	a901      	add	r1, sp, #4
 80068b8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80068bc:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80068be:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80068c0:	f7fa fccc 	bl	800125c <HAL_GPIO_Init>

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 80068c4:	2023      	movs	r0, #35	; 0x23
 80068c6:	462a      	mov	r2, r5
 80068c8:	4621      	mov	r1, r4
 80068ca:	f7fa fb0d 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 80068ce:	2023      	movs	r0, #35	; 0x23
 80068d0:	f7fa fb3e 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 80068d4:	b007      	add	sp, #28
 80068d6:	bd30      	pop	{r4, r5, pc}
 80068d8:	40013000 	.word	0x40013000

080068dc <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80068dc:	b510      	push	{r4, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART1)
 80068de:	6802      	ldr	r2, [r0, #0]
 80068e0:	4b13      	ldr	r3, [pc, #76]	; (8006930 <HAL_UART_MspInit+0x54>)
 80068e2:	429a      	cmp	r2, r3
{
 80068e4:	b086      	sub	sp, #24
  if(huart->Instance==USART1)
 80068e6:	d120      	bne.n	800692a <HAL_UART_MspInit+0x4e>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 80068e8:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
    PC4     ------> USART1_TX
    PC5     ------> USART1_RX 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80068ec:	2400      	movs	r4, #0
    __HAL_RCC_USART1_CLK_ENABLE();
 80068ee:	699a      	ldr	r2, [r3, #24]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80068f0:	4810      	ldr	r0, [pc, #64]	; (8006934 <HAL_UART_MspInit+0x58>)
    __HAL_RCC_USART1_CLK_ENABLE();
 80068f2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80068f6:	619a      	str	r2, [r3, #24]
 80068f8:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80068fa:	9403      	str	r4, [sp, #12]
    __HAL_RCC_USART1_CLK_ENABLE();
 80068fc:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8006900:	9300      	str	r3, [sp, #0]
 8006902:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
 8006904:	2330      	movs	r3, #48	; 0x30
 8006906:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006908:	2302      	movs	r3, #2
 800690a:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800690c:	2303      	movs	r3, #3
 800690e:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006910:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8006912:	2307      	movs	r3, #7
 8006914:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006916:	f7fa fca1 	bl	800125c <HAL_GPIO_Init>

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 800691a:	2025      	movs	r0, #37	; 0x25
 800691c:	4622      	mov	r2, r4
 800691e:	2105      	movs	r1, #5
 8006920:	f7fa fae2 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8006924:	2025      	movs	r0, #37	; 0x25
 8006926:	f7fa fb13 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 800692a:	b006      	add	sp, #24
 800692c:	bd10      	pop	{r4, pc}
 800692e:	bf00      	nop
 8006930:	40013800 	.word	0x40013800
 8006934:	48000800 	.word	0x48000800

08006938 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 8006938:	b508      	push	{r3, lr}
  HAL_IncTick();
 800693a:	f7f9 fcbf 	bl	80002bc <HAL_IncTick>
  osSystickHandler();
}
 800693e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  osSystickHandler();
 8006942:	f7fd bc43 	b.w	80041cc <osSystickHandler>
	...

08006948 <ADC1_2_IRQHandler>:
*/
extern volatile int ADC2_Chan15_EOS;
void ADC1_2_IRQHandler(void)
{
#if ADC2_INTR_MODE
	HAL_ADC_IRQHandler(&hadc2);
 8006948:	4801      	ldr	r0, [pc, #4]	; (8006950 <ADC1_2_IRQHandler+0x8>)
 800694a:	f7f9 bf27 	b.w	800079c <HAL_ADC_IRQHandler>
 800694e:	bf00      	nop
 8006950:	20002154 	.word	0x20002154

08006954 <HAL_ADC_ConvCpltCallback>:
	}
}

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
	if(hadc == &hadc2) {
 8006954:	4b03      	ldr	r3, [pc, #12]	; (8006964 <HAL_ADC_ConvCpltCallback+0x10>)
 8006956:	4283      	cmp	r3, r0
		ADC2_Chan15_EOS = 1;
 8006958:	bf02      	ittt	eq
 800695a:	4b03      	ldreq	r3, [pc, #12]	; (8006968 <HAL_ADC_ConvCpltCallback+0x14>)
 800695c:	2201      	moveq	r2, #1
 800695e:	601a      	streq	r2, [r3, #0]
 8006960:	4770      	bx	lr
 8006962:	bf00      	nop
 8006964:	20002154 	.word	0x20002154
 8006968:	20001adc 	.word	0x20001adc

0800696c <HAL_ADCEx_InjectedConvCpltCallback>:
 800696c:	f7ff bff2 	b.w	8006954 <HAL_ADC_ConvCpltCallback>

08006970 <USB_LP_CAN_RX0_IRQHandler>:
/**
* @brief This function handles USB low priority or CAN_RX0 interrupts.
*/
void USB_LP_CAN_RX0_IRQHandler(void)
{
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 8006970:	4801      	ldr	r0, [pc, #4]	; (8006978 <USB_LP_CAN_RX0_IRQHandler+0x8>)
 8006972:	f7fb bc75 	b.w	8002260 <HAL_PCD_IRQHandler>
 8006976:	bf00      	nop
 8006978:	20002d98 	.word	0x20002d98

0800697c <I2C1_EV_IRQHandler>:
/**
* @brief This function handles I2C1 event global interrupt / I2C1 wake-up interrupt through EXTI line 23.
*/
void I2C1_EV_IRQHandler(void)
{
  HAL_I2C_EV_IRQHandler(&hi2c1);
 800697c:	4801      	ldr	r0, [pc, #4]	; (8006984 <I2C1_EV_IRQHandler+0x8>)
 800697e:	f7fa bdc5 	b.w	800150c <HAL_I2C_EV_IRQHandler>
 8006982:	bf00      	nop
 8006984:	200021a8 	.word	0x200021a8

08006988 <I2C1_ER_IRQHandler>:
/**
* @brief This function handles I2C1 error interrupt.
*/
void I2C1_ER_IRQHandler(void)
{
  HAL_I2C_ER_IRQHandler(&hi2c1);
 8006988:	4801      	ldr	r0, [pc, #4]	; (8006990 <I2C1_ER_IRQHandler+0x8>)
 800698a:	f7fa bfef 	b.w	800196c <HAL_I2C_ER_IRQHandler>
 800698e:	bf00      	nop
 8006990:	200021a8 	.word	0x200021a8

08006994 <SPI1_IRQHandler>:
void SPI1_IRQHandler(void)
{
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 8006994:	4801      	ldr	r0, [pc, #4]	; (800699c <SPI1_IRQHandler+0x8>)
 8006996:	f7fc bc97 	b.w	80032c8 <HAL_SPI_IRQHandler>
 800699a:	bf00      	nop
 800699c:	200022dc 	.word	0x200022dc

080069a0 <USART1_IRQHandler>:
* @brief This function handles USART1 global interrupt / USART1 wake-up interrupt through EXTI line 25.
*/
extern osSemaphoreId myBinarySem01Handle;
extern char rxChar;
void USART1_IRQHandler(void)
{
 80069a0:	b508      	push	{r3, lr}
	uint32_t isrflags   = READ_REG(huart1.Instance->ISR);
 80069a2:	4b0a      	ldr	r3, [pc, #40]	; (80069cc <USART1_IRQHandler+0x2c>)
 80069a4:	681b      	ldr	r3, [r3, #0]
 80069a6:	69da      	ldr	r2, [r3, #28]
	if(isrflags & USART_ISR_RXNE) {
 80069a8:	0692      	lsls	r2, r2, #26
 80069aa:	d50d      	bpl.n	80069c8 <USART1_IRQHandler+0x28>
		rxChar = (char) READ_REG(huart1.Instance->RDR);
 80069ac:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80069ae:	4b08      	ldr	r3, [pc, #32]	; (80069d0 <USART1_IRQHandler+0x30>)
		HAL_GPIO_TogglePin(GPIOE, LD7_Pin);
 80069b0:	4808      	ldr	r0, [pc, #32]	; (80069d4 <USART1_IRQHandler+0x34>)
		rxChar = (char) READ_REG(huart1.Instance->RDR);
 80069b2:	701a      	strb	r2, [r3, #0]
		HAL_GPIO_TogglePin(GPIOE, LD7_Pin);
 80069b4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80069b8:	f7fa fd17 	bl	80013ea <HAL_GPIO_TogglePin>
		osSemaphoreRelease(myBinarySem01Handle);
 80069bc:	4b06      	ldr	r3, [pc, #24]	; (80069d8 <USART1_IRQHandler+0x38>)
 80069be:	6818      	ldr	r0, [r3, #0]
	}
}
 80069c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		osSemaphoreRelease(myBinarySem01Handle);
 80069c4:	f7fd bbde 	b.w	8004184 <osSemaphoreRelease>
 80069c8:	bd08      	pop	{r3, pc}
 80069ca:	bf00      	nop
 80069cc:	2000226c 	.word	0x2000226c
 80069d0:	20002390 	.word	0x20002390
 80069d4:	48001000 	.word	0x48001000
 80069d8:	20002394 	.word	0x20002394

080069dc <DMA2_Channel1_IRQHandler>:
/**
* @brief This function handles DMA2 channel1 global interrupt.
*/
void DMA2_Channel1_IRQHandler(void)
{
  HAL_DMA_IRQHandler(&hdma_adc2);
 80069dc:	4801      	ldr	r0, [pc, #4]	; (80069e4 <DMA2_Channel1_IRQHandler+0x8>)
 80069de:	f7fa bbf5 	b.w	80011cc <HAL_DMA_IRQHandler>
 80069e2:	bf00      	nop
 80069e4:	20002340 	.word	0x20002340

080069e8 <DMA1_Channel1_IRQHandler>:


extern DMA_HandleTypeDef	hdma1;
void DMA1_Channel1_IRQHandler(void)
{
	HAL_DMA_IRQHandler(&hdma1);
 80069e8:	4801      	ldr	r0, [pc, #4]	; (80069f0 <DMA1_Channel1_IRQHandler+0x8>)
 80069ea:	f7fa bbef 	b.w	80011cc <HAL_DMA_IRQHandler>
 80069ee:	bf00      	nop
 80069f0:	20002228 	.word	0x20002228

080069f4 <DMA1Chan1_Complete>:
}

extern osSemaphoreId dma1SemHandle;
void DMA1Chan1_Complete(struct __DMA_HandleTypeDef * hdma)
{
	osSemaphoreRelease(dma1SemHandle);
 80069f4:	4b01      	ldr	r3, [pc, #4]	; (80069fc <DMA1Chan1_Complete+0x8>)
 80069f6:	6818      	ldr	r0, [r3, #0]
 80069f8:	f7fd bbc4 	b.w	8004184 <osSemaphoreRelease>
 80069fc:	2000238c 	.word	0x2000238c

08006a00 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006a00:	4915      	ldr	r1, [pc, #84]	; (8006a58 <SystemInit+0x58>)
 8006a02:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8006a06:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8006a0a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;
 8006a0e:	4b13      	ldr	r3, [pc, #76]	; (8006a5c <SystemInit+0x5c>)
 8006a10:	681a      	ldr	r2, [r3, #0]
 8006a12:	f042 0201 	orr.w	r2, r2, #1
 8006a16:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR &= 0xF87FC00CU;
 8006a18:	6858      	ldr	r0, [r3, #4]
 8006a1a:	4a11      	ldr	r2, [pc, #68]	; (8006a60 <SystemInit+0x60>)
 8006a1c:	4002      	ands	r2, r0
 8006a1e:	605a      	str	r2, [r3, #4]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;
 8006a20:	681a      	ldr	r2, [r3, #0]
 8006a22:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8006a26:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006a2a:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8006a2c:	681a      	ldr	r2, [r3, #0]
 8006a2e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006a32:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;
 8006a34:	685a      	ldr	r2, [r3, #4]
 8006a36:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8006a3a:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= 0xFFFFFFF0U;
 8006a3c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006a3e:	f022 020f 	bic.w	r2, r2, #15
 8006a42:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= 0xFF00FCCCU;
 8006a44:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006a46:	4a07      	ldr	r2, [pc, #28]	; (8006a64 <SystemInit+0x64>)
 8006a48:	4002      	ands	r2, r0
 8006a4a:	631a      	str	r2, [r3, #48]	; 0x30

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 8006a4c:	2200      	movs	r2, #0
 8006a4e:	609a      	str	r2, [r3, #8]

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006a50:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8006a54:	608b      	str	r3, [r1, #8]
 8006a56:	4770      	bx	lr
 8006a58:	e000ed00 	.word	0xe000ed00
 8006a5c:	40021000 	.word	0x40021000
 8006a60:	f87fc00c 	.word	0xf87fc00c
 8006a64:	ff00fccc 	.word	0xff00fccc

08006a68 <DefaultTask>:
extern DMA_HandleTypeDef	hdma1;


/* StartDefaultTask function */
void DefaultTask(void const * argument)
{
 8006a68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006a6c:	b088      	sub	sp, #32
	/* init code for USB_DEVICE */
	MX_USB_DEVICE_Init();
 8006a6e:	f000 f94f 	bl	8006d10 <MX_USB_DEVICE_Init>

	osTimerStart(SwTmr01Handle, 2000);
 8006a72:	4b20      	ldr	r3, [pc, #128]	; (8006af4 <DefaultTask+0x8c>)

	uint8_t count = 0;
	for(;;)
	{
		osDelay(1000);
		HAL_GPIO_TogglePin(GPIOE, LD3_Pin);
 8006a74:	f8df 8094 	ldr.w	r8, [pc, #148]	; 8006b0c <DefaultTask+0xa4>
	osTimerStart(SwTmr01Handle, 2000);
 8006a78:	6818      	ldr	r0, [r3, #0]
		HAL_IWDG_Refresh(&hiwdg);
 8006a7a:	4f1f      	ldr	r7, [pc, #124]	; (8006af8 <DefaultTask+0x90>)

		sprintf(buildVersion, "%03d", count);
 8006a7c:	4e1f      	ldr	r6, [pc, #124]	; (8006afc <DefaultTask+0x94>)
	osTimerStart(SwTmr01Handle, 2000);
 8006a7e:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8006a82:	f7fd fafd 	bl	8004080 <osTimerStart>
	myLCD_Init();
 8006a86:	f7ff fb91 	bl	80061ac <myLCD_Init>
	myLCD_GotoXY(1, 1);
 8006a8a:	2101      	movs	r1, #1
 8006a8c:	4608      	mov	r0, r1
 8006a8e:	f7ff fb6f 	bl	8006170 <myLCD_GotoXY>
	osDelay(100);
 8006a92:	2064      	movs	r0, #100	; 0x64
 8006a94:	f7fd fad0 	bl	8004038 <osDelay>
	sprintf(buildVersion, "STM32 %s", __TIME__);
 8006a98:	4a19      	ldr	r2, [pc, #100]	; (8006b00 <DefaultTask+0x98>)
 8006a9a:	491a      	ldr	r1, [pc, #104]	; (8006b04 <DefaultTask+0x9c>)
 8006a9c:	4668      	mov	r0, sp
 8006a9e:	f000 fb71 	bl	8007184 <siprintf>
	myLCD_PrintStr(buildVersion);
 8006aa2:	4668      	mov	r0, sp
 8006aa4:	f7ff fbca 	bl	800623c <myLCD_PrintStr>
	uint8_t count = 0;
 8006aa8:	2400      	movs	r4, #0
		osDelay(1000);
 8006aaa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006aae:	f7fd fac3 	bl	8004038 <osDelay>
		HAL_GPIO_TogglePin(GPIOE, LD3_Pin);
 8006ab2:	f44f 7100 	mov.w	r1, #512	; 0x200
 8006ab6:	4640      	mov	r0, r8
 8006ab8:	f7fa fc97 	bl	80013ea <HAL_GPIO_TogglePin>
		osSemaphoreWait(lcdSemHandle, portMAX_DELAY);
 8006abc:	4d12      	ldr	r5, [pc, #72]	; (8006b08 <DefaultTask+0xa0>)
		HAL_IWDG_Refresh(&hiwdg);
 8006abe:	4638      	mov	r0, r7
 8006ac0:	f7fb f80f 	bl	8001ae2 <HAL_IWDG_Refresh>
		sprintf(buildVersion, "%03d", count);
 8006ac4:	4622      	mov	r2, r4
 8006ac6:	4631      	mov	r1, r6
 8006ac8:	4668      	mov	r0, sp
 8006aca:	f000 fb5b 	bl	8007184 <siprintf>
		osSemaphoreWait(lcdSemHandle, portMAX_DELAY);
 8006ace:	f04f 31ff 	mov.w	r1, #4294967295
 8006ad2:	6828      	ldr	r0, [r5, #0]
 8006ad4:	f7fd fb2e 	bl	8004134 <osSemaphoreWait>
		myLCD_GotoXY(2, 14);
 8006ad8:	210e      	movs	r1, #14
 8006ada:	2002      	movs	r0, #2
 8006adc:	f7ff fb48 	bl	8006170 <myLCD_GotoXY>
		myLCD_PrintStr(buildVersion);
 8006ae0:	4668      	mov	r0, sp
 8006ae2:	f7ff fbab 	bl	800623c <myLCD_PrintStr>
		osSemaphoreRelease(lcdSemHandle);
		count++;
 8006ae6:	3401      	adds	r4, #1
		osSemaphoreRelease(lcdSemHandle);
 8006ae8:	6828      	ldr	r0, [r5, #0]
 8006aea:	f7fd fb4b 	bl	8004184 <osSemaphoreRelease>
		count++;
 8006aee:	b2e4      	uxtb	r4, r4
 8006af0:	e7db      	b.n	8006aaa <DefaultTask+0x42>
 8006af2:	bf00      	nop
 8006af4:	20002388 	.word	0x20002388
 8006af8:	200021f4 	.word	0x200021f4
 8006afc:	08007ae0 	.word	0x08007ae0
 8006b00:	08007ace 	.word	0x08007ace
 8006b04:	08007ad7 	.word	0x08007ad7
 8006b08:	2000239c 	.word	0x2000239c
 8006b0c:	48001000 	.word	0x48001000

08006b10 <ProcessCmdTask>:
	}
}

void ProcessCmdTask(void const * argument)
{
 8006b10:	b580      	push	{r7, lr}
	while(1)
	{
		osSemaphoreWait(myBinarySem01Handle, portMAX_DELAY);
 8006b12:	4e18      	ldr	r6, [pc, #96]	; (8006b74 <ProcessCmdTask+0x64>)
		HAL_GPIO_TogglePin(GPIOE, LD6_Pin);
 8006b14:	4f18      	ldr	r7, [pc, #96]	; (8006b78 <ProcessCmdTask+0x68>)
		osSemaphoreWait(lcdSemHandle, portMAX_DELAY);
 8006b16:	4d19      	ldr	r5, [pc, #100]	; (8006b7c <ProcessCmdTask+0x6c>)
		osSemaphoreWait(myBinarySem01Handle, portMAX_DELAY);
 8006b18:	6830      	ldr	r0, [r6, #0]
		myLCD_GotoXY(2,1);
		myLCD_PutChar(rxChar);
 8006b1a:	4c19      	ldr	r4, [pc, #100]	; (8006b80 <ProcessCmdTask+0x70>)
		osSemaphoreWait(myBinarySem01Handle, portMAX_DELAY);
 8006b1c:	f04f 31ff 	mov.w	r1, #4294967295
 8006b20:	f7fd fb08 	bl	8004134 <osSemaphoreWait>
		HAL_GPIO_TogglePin(GPIOE, LD6_Pin);
 8006b24:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8006b28:	4638      	mov	r0, r7
 8006b2a:	f7fa fc5e 	bl	80013ea <HAL_GPIO_TogglePin>
		osSemaphoreWait(lcdSemHandle, portMAX_DELAY);
 8006b2e:	f04f 31ff 	mov.w	r1, #4294967295
 8006b32:	6828      	ldr	r0, [r5, #0]
 8006b34:	f7fd fafe 	bl	8004134 <osSemaphoreWait>
		myLCD_GotoXY(2,1);
 8006b38:	2101      	movs	r1, #1
 8006b3a:	2002      	movs	r0, #2
 8006b3c:	f7ff fb18 	bl	8006170 <myLCD_GotoXY>
		myLCD_PutChar(rxChar);
 8006b40:	7820      	ldrb	r0, [r4, #0]
 8006b42:	f7ff fb87 	bl	8006254 <myLCD_PutChar>
		osSemaphoreRelease(lcdSemHandle);
 8006b46:	6828      	ldr	r0, [r5, #0]
 8006b48:	f7fd fb1c 	bl	8004184 <osSemaphoreRelease>

		switch(rxChar) {
 8006b4c:	7820      	ldrb	r0, [r4, #0]
 8006b4e:	2863      	cmp	r0, #99	; 0x63
 8006b50:	d009      	beq.n	8006b66 <ProcessCmdTask+0x56>
 8006b52:	2864      	cmp	r0, #100	; 0x64
 8006b54:	d004      	beq.n	8006b60 <ProcessCmdTask+0x50>
 8006b56:	2861      	cmp	r0, #97	; 0x61
 8006b58:	d108      	bne.n	8006b6c <ProcessCmdTask+0x5c>
		case 'd':
			DMA1_Test();
			break;

		case 'a':
			ADC2_Test();
 8006b5a:	f000 f89b 	bl	8006c94 <ADC2_Test>
			break;
 8006b5e:	e7da      	b.n	8006b16 <ProcessCmdTask+0x6>
			DMA1_Test();
 8006b60:	f000 f818 	bl	8006b94 <DMA1_Test>
			break;
 8006b64:	e7d7      	b.n	8006b16 <ProcessCmdTask+0x6>

		case 'c':
			myLCD_Clear();
 8006b66:	f7ff fb17 	bl	8006198 <myLCD_Clear>
			break;
 8006b6a:	e7d4      	b.n	8006b16 <ProcessCmdTask+0x6>

		default:
			debug_outbyte(rxChar);
 8006b6c:	f7ff f97e 	bl	8005e6c <debug_outbyte>
			break;
 8006b70:	e7d1      	b.n	8006b16 <ProcessCmdTask+0x6>
 8006b72:	bf00      	nop
 8006b74:	20002394 	.word	0x20002394
 8006b78:	48001000 	.word	0x48001000
 8006b7c:	2000239c 	.word	0x2000239c
 8006b80:	20002390 	.word	0x20002390

08006b84 <SwTmrCallback>:
}

/* SwTmr01Callback function */
void SwTmrCallback(void const * argument)
{
	HAL_GPIO_TogglePin(GPIOE, LD4_Pin);
 8006b84:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006b88:	4801      	ldr	r0, [pc, #4]	; (8006b90 <SwTmrCallback+0xc>)
 8006b8a:	f7fa bc2e 	b.w	80013ea <HAL_GPIO_TogglePin>
 8006b8e:	bf00      	nop
 8006b90:	48001000 	.word	0x48001000

08006b94 <DMA1_Test>:
static int dst_buf[BUF_MAX_SIZE];
static int startVal = 1;
static int  length = 16;

void DMA1_Test(void)
{
 8006b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	debug_print("DMA1 M2M test\r\n");
 8006b96:	4834      	ldr	r0, [pc, #208]	; (8006c68 <DMA1_Test+0xd4>)
	memset(src_buf, 0, sizeof(src_buf));
	memset(dst_buf, 0, sizeof(dst_buf));

	reset_timer();
	start_timer();
	for(i = 0; i < length; i++) {
 8006b98:	4c34      	ldr	r4, [pc, #208]	; (8006c6c <DMA1_Test+0xd8>)
		src_buf[i] = startVal + i;
 8006b9a:	4d35      	ldr	r5, [pc, #212]	; (8006c70 <DMA1_Test+0xdc>)
	debug_print("DMA1 M2M test\r\n");
 8006b9c:	f7ff fa92 	bl	80060c4 <debug_print>
	memset(src_buf, 0, sizeof(src_buf));
 8006ba0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006ba4:	2100      	movs	r1, #0
 8006ba6:	4833      	ldr	r0, [pc, #204]	; (8006c74 <DMA1_Test+0xe0>)
 8006ba8:	f000 fae3 	bl	8007172 <memset>
	memset(dst_buf, 0, sizeof(dst_buf));
 8006bac:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006bb0:	2100      	movs	r1, #0
 8006bb2:	4831      	ldr	r0, [pc, #196]	; (8006c78 <DMA1_Test+0xe4>)
 8006bb4:	f000 fadd 	bl	8007172 <memset>
	reset_timer();
 8006bb8:	f7ff f92c 	bl	8005e14 <reset_timer>
	start_timer();
 8006bbc:	f7ff f93e 	bl	8005e3c <start_timer>
	for(i = 0; i < length; i++) {
 8006bc0:	6822      	ldr	r2, [r4, #0]
		src_buf[i] = startVal + i;
 8006bc2:	6829      	ldr	r1, [r5, #0]
 8006bc4:	482b      	ldr	r0, [pc, #172]	; (8006c74 <DMA1_Test+0xe0>)
	for(i = 0; i < length; i++) {
 8006bc6:	2300      	movs	r3, #0
 8006bc8:	4293      	cmp	r3, r2
 8006bca:	db3c      	blt.n	8006c46 <DMA1_Test+0xb2>
	}
	stop_timer();
 8006bcc:	f7ff f940 	bl	8005e50 <stop_timer>
	uint32_t count = getCycles();
 8006bd0:	f7ff f946 	bl	8005e60 <getCycles>
	debug_printf("Fill %d bytes, %d cycles\r\n", length * 4, count);
 8006bd4:	6821      	ldr	r1, [r4, #0]
		length = 16;
	}

	int result = 0;
	for(i = 0; i < length; i++) {
		if(src_buf[i] != dst_buf[i]) {
 8006bd6:	4e28      	ldr	r6, [pc, #160]	; (8006c78 <DMA1_Test+0xe4>)
	debug_printf("Fill %d bytes, %d cycles\r\n", length * 4, count);
 8006bd8:	4602      	mov	r2, r0
 8006bda:	0089      	lsls	r1, r1, #2
 8006bdc:	4827      	ldr	r0, [pc, #156]	; (8006c7c <DMA1_Test+0xe8>)
 8006bde:	f7ff fa7a 	bl	80060d6 <debug_printf>
	reset_timer();
 8006be2:	f7ff f917 	bl	8005e14 <reset_timer>
	start_timer();
 8006be6:	f7ff f929 	bl	8005e3c <start_timer>
	HAL_DMA_Start_IT(&hdma1, (uint32_t) &src_buf[0], (uint32_t )&dst_buf[0], length * 4);
 8006bea:	6823      	ldr	r3, [r4, #0]
 8006bec:	4a22      	ldr	r2, [pc, #136]	; (8006c78 <DMA1_Test+0xe4>)
 8006bee:	4921      	ldr	r1, [pc, #132]	; (8006c74 <DMA1_Test+0xe0>)
 8006bf0:	4823      	ldr	r0, [pc, #140]	; (8006c80 <DMA1_Test+0xec>)
 8006bf2:	009b      	lsls	r3, r3, #2
 8006bf4:	f7fa fa89 	bl	800110a <HAL_DMA_Start_IT>
	osSemaphoreWait(dma1SemHandle, portMAX_DELAY);
 8006bf8:	4b22      	ldr	r3, [pc, #136]	; (8006c84 <DMA1_Test+0xf0>)
 8006bfa:	f04f 31ff 	mov.w	r1, #4294967295
 8006bfe:	6818      	ldr	r0, [r3, #0]
 8006c00:	f7fd fa98 	bl	8004134 <osSemaphoreWait>
	stop_timer();
 8006c04:	f7ff f924 	bl	8005e50 <stop_timer>
	count = getCycles();
 8006c08:	f7ff f92a 	bl	8005e60 <getCycles>
	debug_printf("DMA %d bytes, %d cycles : ", length * 4, count);
 8006c0c:	6821      	ldr	r1, [r4, #0]
 8006c0e:	4602      	mov	r2, r0
 8006c10:	0089      	lsls	r1, r1, #2
 8006c12:	481d      	ldr	r0, [pc, #116]	; (8006c88 <DMA1_Test+0xf4>)
 8006c14:	f7ff fa5f 	bl	80060d6 <debug_printf>
	if(length > BUF_MAX_SIZE) {
 8006c18:	6823      	ldr	r3, [r4, #0]
		if(src_buf[i] != dst_buf[i]) {
 8006c1a:	f8df e058 	ldr.w	lr, [pc, #88]	; 8006c74 <DMA1_Test+0xe0>
	if(length > BUF_MAX_SIZE) {
 8006c1e:	2b80      	cmp	r3, #128	; 0x80
		length = 16;
 8006c20:	bfc4      	itt	gt
 8006c22:	2310      	movgt	r3, #16
 8006c24:	6023      	strgt	r3, [r4, #0]
	int result = 0;
 8006c26:	2200      	movs	r2, #0
	for(i = 0; i < length; i++) {
 8006c28:	6821      	ldr	r1, [r4, #0]
 8006c2a:	4613      	mov	r3, r2
 8006c2c:	428b      	cmp	r3, r1
 8006c2e:	db0f      	blt.n	8006c50 <DMA1_Test+0xbc>
			result++;
		}
	}

	if(result) {
 8006c30:	b1ba      	cbz	r2, 8006c62 <DMA1_Test+0xce>
		debug_print("FAIL\r\n");
 8006c32:	4816      	ldr	r0, [pc, #88]	; (8006c8c <DMA1_Test+0xf8>)
	}
	else {
		debug_print("PASS\r\n");
 8006c34:	f7ff fa46 	bl	80060c4 <debug_print>
	}

	startVal += 1;
 8006c38:	682b      	ldr	r3, [r5, #0]
 8006c3a:	3301      	adds	r3, #1
 8006c3c:	602b      	str	r3, [r5, #0]
	length += 16;
 8006c3e:	6823      	ldr	r3, [r4, #0]
 8006c40:	3310      	adds	r3, #16
 8006c42:	6023      	str	r3, [r4, #0]
 8006c44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		src_buf[i] = startVal + i;
 8006c46:	18ce      	adds	r6, r1, r3
 8006c48:	f840 6023 	str.w	r6, [r0, r3, lsl #2]
	for(i = 0; i < length; i++) {
 8006c4c:	3301      	adds	r3, #1
 8006c4e:	e7bb      	b.n	8006bc8 <DMA1_Test+0x34>
		if(src_buf[i] != dst_buf[i]) {
 8006c50:	f85e 7023 	ldr.w	r7, [lr, r3, lsl #2]
 8006c54:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8006c58:	4287      	cmp	r7, r0
			result++;
 8006c5a:	bf18      	it	ne
 8006c5c:	3201      	addne	r2, #1
	for(i = 0; i < length; i++) {
 8006c5e:	3301      	adds	r3, #1
 8006c60:	e7e4      	b.n	8006c2c <DMA1_Test+0x98>
		debug_print("PASS\r\n");
 8006c62:	480b      	ldr	r0, [pc, #44]	; (8006c90 <DMA1_Test+0xfc>)
 8006c64:	e7e6      	b.n	8006c34 <DMA1_Test+0xa0>
 8006c66:	bf00      	nop
 8006c68:	08007b2f 	.word	0x08007b2f
 8006c6c:	20000124 	.word	0x20000124
 8006c70:	20000128 	.word	0x20000128
 8006c74:	20001ce4 	.word	0x20001ce4
 8006c78:	20001ae4 	.word	0x20001ae4
 8006c7c:	08007b3f 	.word	0x08007b3f
 8006c80:	20002228 	.word	0x20002228
 8006c84:	2000238c 	.word	0x2000238c
 8006c88:	08007b5a 	.word	0x08007b5a
 8006c8c:	08007b75 	.word	0x08007b75
 8006c90:	08007b7c 	.word	0x08007b7c

08006c94 <ADC2_Test>:

volatile int ADC2_Chan15_EOS = 0;
uint16_t val1, val2;
static uint16_t adc_val[2];
void ADC2_Test()
{
 8006c94:	b510      	push	{r4, lr}
#if ADC2_REGULAR_TEST

#if ADC2_INTR_MODE
	debug_print("Testing ADC (DMA)...");
 8006c96:	4816      	ldr	r0, [pc, #88]	; (8006cf0 <ADC2_Test+0x5c>)
	ADC2_Chan15_EOS = 0;
 8006c98:	4c16      	ldr	r4, [pc, #88]	; (8006cf4 <ADC2_Test+0x60>)
	debug_print("Testing ADC (DMA)...");
 8006c9a:	f7ff fa13 	bl	80060c4 <debug_print>
	ADC2_Chan15_EOS = 0;
 8006c9e:	2300      	movs	r3, #0
 8006ca0:	6023      	str	r3, [r4, #0]
	reset_timer();
 8006ca2:	f7ff f8b7 	bl	8005e14 <reset_timer>
	start_timer();
 8006ca6:	f7ff f8c9 	bl	8005e3c <start_timer>
	HAL_ADC_Start_DMA(&hadc2, (uint32_t*) &adc_val[0], 2);
 8006caa:	2202      	movs	r2, #2
 8006cac:	4912      	ldr	r1, [pc, #72]	; (8006cf8 <ADC2_Test+0x64>)
 8006cae:	4813      	ldr	r0, [pc, #76]	; (8006cfc <ADC2_Test+0x68>)
 8006cb0:	f7f9 fcc4 	bl	800063c <HAL_ADC_Start_DMA>
	while(ADC2_Chan15_EOS == 0) ;
 8006cb4:	6823      	ldr	r3, [r4, #0]
 8006cb6:	2b00      	cmp	r3, #0
 8006cb8:	d0fc      	beq.n	8006cb4 <ADC2_Test+0x20>
	stop_timer();
 8006cba:	f7ff f8c9 	bl	8005e50 <stop_timer>
	uint32_t cnt = getCycles();
 8006cbe:	f7ff f8cf 	bl	8005e60 <getCycles>

	val1 = adc_val[0];
 8006cc2:	4b0d      	ldr	r3, [pc, #52]	; (8006cf8 <ADC2_Test+0x64>)
 8006cc4:	4a0e      	ldr	r2, [pc, #56]	; (8006d00 <ADC2_Test+0x6c>)
 8006cc6:	8819      	ldrh	r1, [r3, #0]
 8006cc8:	8011      	strh	r1, [r2, #0]
	val2 = adc_val[1];
 8006cca:	885a      	ldrh	r2, [r3, #2]
 8006ccc:	4b0d      	ldr	r3, [pc, #52]	; (8006d04 <ADC2_Test+0x70>)
 8006cce:	801a      	strh	r2, [r3, #0]
	debug_printf("done\r\nVal1: %d, Val2: %d, (%d cycles)\r\n", val1, val2, cnt);
 8006cd0:	4603      	mov	r3, r0
 8006cd2:	480d      	ldr	r0, [pc, #52]	; (8006d08 <ADC2_Test+0x74>)
 8006cd4:	f7ff f9ff 	bl	80060d6 <debug_printf>

	myLCD_Clear();
 8006cd8:	f7ff fa5e 	bl	8006198 <myLCD_Clear>
	myLCD_GotoXY(1, 1);
 8006cdc:	2101      	movs	r1, #1
 8006cde:	4608      	mov	r0, r1
 8006ce0:	f7ff fa46 	bl	8006170 <myLCD_GotoXY>
	myLCD_PrintStr("ADC reg done");
 8006ce4:	4809      	ldr	r0, [pc, #36]	; (8006d0c <ADC2_Test+0x78>)
	myLCD_GotoXY(1, 1);
	myLCD_PrintStr("ADC inj done");
#endif

#endif
}
 8006ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	myLCD_PrintStr("ADC reg done");
 8006cea:	f7ff baa7 	b.w	800623c <myLCD_PrintStr>
 8006cee:	bf00      	nop
 8006cf0:	08007ae5 	.word	0x08007ae5
 8006cf4:	20001adc 	.word	0x20001adc
 8006cf8:	20001ae0 	.word	0x20001ae0
 8006cfc:	20002154 	.word	0x20002154
 8006d00:	200023a2 	.word	0x200023a2
 8006d04:	200023a0 	.word	0x200023a0
 8006d08:	08007afa 	.word	0x08007afa
 8006d0c:	08007b22 	.word	0x08007b22

08006d10 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8006d10:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8006d12:	4c09      	ldr	r4, [pc, #36]	; (8006d38 <MX_USB_DEVICE_Init+0x28>)
 8006d14:	4909      	ldr	r1, [pc, #36]	; (8006d3c <MX_USB_DEVICE_Init+0x2c>)
 8006d16:	2200      	movs	r2, #0
 8006d18:	4620      	mov	r0, r4
 8006d1a:	f7fc fe50 	bl	80039be <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8006d1e:	4908      	ldr	r1, [pc, #32]	; (8006d40 <MX_USB_DEVICE_Init+0x30>)
 8006d20:	4620      	mov	r0, r4
 8006d22:	f7fc fe61 	bl	80039e8 <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 8006d26:	4620      	mov	r0, r4
 8006d28:	4906      	ldr	r1, [pc, #24]	; (8006d44 <MX_USB_DEVICE_Init+0x34>)
 8006d2a:	f7fc fe20 	bl	800396e <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 8006d2e:	4620      	mov	r0, r4

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8006d30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_Start(&hUsbDeviceFS);
 8006d34:	f7fc be5f 	b.w	80039f6 <USBD_Start>
 8006d38:	200023a4 	.word	0x200023a4
 8006d3c:	2000013c 	.word	0x2000013c
 8006d40:	20000000 	.word	0x20000000
 8006d44:	2000012c 	.word	0x2000012c

08006d48 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
  /* USER CODE END 4 */
}
 8006d48:	2000      	movs	r0, #0
 8006d4a:	4770      	bx	lr

08006d4c <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 8006d4c:	2000      	movs	r0, #0
 8006d4e:	4770      	bx	lr

08006d50 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 8006d50:	b510      	push	{r4, lr}
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8006d52:	4c05      	ldr	r4, [pc, #20]	; (8006d68 <CDC_Receive_FS+0x18>)
 8006d54:	4601      	mov	r1, r0
 8006d56:	4620      	mov	r0, r4
 8006d58:	f7fc fe18 	bl	800398c <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 8006d5c:	4620      	mov	r0, r4
 8006d5e:	f7fc fe1b 	bl	8003998 <USBD_CDC_ReceivePacket>
  return (USBD_OK);
  /* USER CODE END 6 */
}
 8006d62:	2000      	movs	r0, #0
 8006d64:	bd10      	pop	{r4, pc}
 8006d66:	bf00      	nop
 8006d68:	200023a4 	.word	0x200023a4

08006d6c <CDC_Init_FS>:
{
 8006d6c:	b510      	push	{r4, lr}
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8006d6e:	4c06      	ldr	r4, [pc, #24]	; (8006d88 <CDC_Init_FS+0x1c>)
 8006d70:	4906      	ldr	r1, [pc, #24]	; (8006d8c <CDC_Init_FS+0x20>)
 8006d72:	2200      	movs	r2, #0
 8006d74:	4620      	mov	r0, r4
 8006d76:	f7fc fe01 	bl	800397c <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8006d7a:	4905      	ldr	r1, [pc, #20]	; (8006d90 <CDC_Init_FS+0x24>)
 8006d7c:	4620      	mov	r0, r4
 8006d7e:	f7fc fe05 	bl	800398c <USBD_CDC_SetRxBuffer>
}
 8006d82:	2000      	movs	r0, #0
 8006d84:	bd10      	pop	{r4, pc}
 8006d86:	bf00      	nop
 8006d88:	200023a4 	.word	0x200023a4
 8006d8c:	200029b0 	.word	0x200029b0
 8006d90:	200025c8 	.word	0x200025c8

08006d94 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8006d94:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB)
 8006d96:	6802      	ldr	r2, [r0, #0]
 8006d98:	4b13      	ldr	r3, [pc, #76]	; (8006de8 <HAL_PCD_MspInit+0x54>)
 8006d9a:	429a      	cmp	r2, r3
{
 8006d9c:	b086      	sub	sp, #24
  if(pcdHandle->Instance==USB)
 8006d9e:	d121      	bne.n	8006de4 <HAL_PCD_MspInit+0x50>
  
    /**USB GPIO Configuration    
    PA11     ------> USB_DM
    PA12     ------> USB_DP 
    */
    GPIO_InitStruct.Pin = DM_Pin|DP_Pin;
 8006da0:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8006da4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006da6:	2302      	movs	r3, #2
 8006da8:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8006daa:	2303      	movs	r3, #3
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006dac:	2400      	movs	r4, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8006dae:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF14_USB;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006db0:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF14_USB;
 8006db2:	230e      	movs	r3, #14
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006db4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF14_USB;
 8006db8:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006dba:	9403      	str	r4, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006dbc:	f7fa fa4e 	bl	800125c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 8006dc0:	4b0a      	ldr	r3, [pc, #40]	; (8006dec <HAL_PCD_MspInit+0x58>)
 8006dc2:	69d9      	ldr	r1, [r3, #28]
 8006dc4:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8006dc8:	61d9      	str	r1, [r3, #28]
 8006dca:	69db      	ldr	r3, [r3, #28]
 8006dcc:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8006dd0:	9300      	str	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_LP_CAN_RX0_IRQn, 5, 0);
 8006dd2:	2014      	movs	r0, #20
 8006dd4:	4622      	mov	r2, r4
 8006dd6:	2105      	movs	r1, #5
    __HAL_RCC_USB_CLK_ENABLE();
 8006dd8:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(USB_LP_CAN_RX0_IRQn, 5, 0);
 8006dda:	f7fa f885 	bl	8000ee8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN_RX0_IRQn);
 8006dde:	2014      	movs	r0, #20
 8006de0:	f7fa f8b6 	bl	8000f50 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8006de4:	b006      	add	sp, #24
 8006de6:	bd10      	pop	{r4, pc}
 8006de8:	40005c00 	.word	0x40005c00
 8006dec:	40021000 	.word	0x40021000

08006df0 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8006df0:	f500 715d 	add.w	r1, r0, #884	; 0x374
 8006df4:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006df8:	f7fc be14 	b.w	8003a24 <USBD_LL_SetupStage>

08006dfc <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8006dfc:	231c      	movs	r3, #28
 8006dfe:	fb03 0301 	mla	r3, r3, r1, r0
 8006e02:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e06:	f8d3 21dc 	ldr.w	r2, [r3, #476]	; 0x1dc
 8006e0a:	f7fc be38 	b.w	8003a7e <USBD_LL_DataOutStage>

08006e0e <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8006e0e:	231c      	movs	r3, #28
 8006e10:	fb03 0301 	mla	r3, r3, r1, r0
 8006e14:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e18:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006e1a:	f7fc be62 	b.w	8003ae2 <USBD_LL_DataInStage>

08006e1e <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8006e1e:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e22:	f7fc bede 	b.w	8003be2 <USBD_LL_SOF>

08006e26 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8006e26:	b510      	push	{r4, lr}
 8006e28:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8006e2a:	2101      	movs	r1, #1
 8006e2c:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e30:	f7fc fec5 	bl	8003bbe <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8006e34:	f8d4 03a4 	ldr.w	r0, [r4, #932]	; 0x3a4
}
 8006e38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8006e3c:	f7fc bea0 	b.w	8003b80 <USBD_LL_Reset>

08006e40 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 8006e40:	b510      	push	{r4, lr}
 8006e42:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8006e44:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e48:	f7fc febc 	bl	8003bc4 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8006e4c:	69a3      	ldr	r3, [r4, #24]
 8006e4e:	b123      	cbz	r3, 8006e5a <HAL_PCD_SuspendCallback+0x1a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8006e50:	4a02      	ldr	r2, [pc, #8]	; (8006e5c <HAL_PCD_SuspendCallback+0x1c>)
 8006e52:	6913      	ldr	r3, [r2, #16]
 8006e54:	f043 0306 	orr.w	r3, r3, #6
 8006e58:	6113      	str	r3, [r2, #16]
 8006e5a:	bd10      	pop	{r4, pc}
 8006e5c:	e000ed00 	.word	0xe000ed00

08006e60 <HAL_PCD_ResumeCallback>:
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8006e60:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8006e64:	f7fc beb7 	b.w	8003bd6 <USBD_LL_Resume>

08006e68 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8006e68:	b510      	push	{r4, lr}
  /* Link the driver to the stack. */
  hpcd_USB_FS.pData = pdev;
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8006e6a:	4a20      	ldr	r2, [pc, #128]	; (8006eec <USBD_LL_Init+0x84>)
{
 8006e6c:	4604      	mov	r4, r0
  hpcd_USB_FS.pData = pdev;
 8006e6e:	4820      	ldr	r0, [pc, #128]	; (8006ef0 <USBD_LL_Init+0x88>)
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8006e70:	2308      	movs	r3, #8
 8006e72:	e880 000c 	stmia.w	r0, {r2, r3}
  hpcd_USB_FS.pData = pdev;
 8006e76:	f8c0 43a4 	str.w	r4, [r0, #932]	; 0x3a4
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8006e7a:	2300      	movs	r3, #0
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8006e7c:	2202      	movs	r2, #2
  pdev->pData = &hpcd_USB_FS;
 8006e7e:	f8c4 0220 	str.w	r0, [r4, #544]	; 0x220
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8006e82:	6082      	str	r2, [r0, #8]
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8006e84:	60c3      	str	r3, [r0, #12]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8006e86:	6102      	str	r2, [r0, #16]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8006e88:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8006e8a:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8006e8c:	f7fa fe2f 	bl	8001aee <HAL_PCD_Init>
 8006e90:	b120      	cbz	r0, 8006e9c <USBD_LL_Init+0x34>
  {
    _Error_Handler(__FILE__, __LINE__);
 8006e92:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006e96:	4817      	ldr	r0, [pc, #92]	; (8006ef4 <USBD_LL_Init+0x8c>)
 8006e98:	f7ff fc14 	bl	80066c4 <_Error_Handler>
  }

  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8006e9c:	2200      	movs	r2, #0
 8006e9e:	4611      	mov	r1, r2
 8006ea0:	2318      	movs	r3, #24
 8006ea2:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 8006ea6:	f7fb fccc 	bl	8002842 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8006eaa:	2358      	movs	r3, #88	; 0x58
 8006eac:	2200      	movs	r2, #0
 8006eae:	2180      	movs	r1, #128	; 0x80
 8006eb0:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 8006eb4:	f7fb fcc5 	bl	8002842 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x81 , PCD_SNG_BUF, 0xC0);
 8006eb8:	23c0      	movs	r3, #192	; 0xc0
 8006eba:	2200      	movs	r2, #0
 8006ebc:	2181      	movs	r1, #129	; 0x81
 8006ebe:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 8006ec2:	f7fb fcbe 	bl	8002842 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x01 , PCD_SNG_BUF, 0x110);
 8006ec6:	f44f 7388 	mov.w	r3, #272	; 0x110
 8006eca:	2200      	movs	r2, #0
 8006ecc:	2101      	movs	r1, #1
 8006ece:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 8006ed2:	f7fb fcb6 	bl	8002842 <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x82 , PCD_SNG_BUF, 0x100);
 8006ed6:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006eda:	2200      	movs	r2, #0
 8006edc:	2182      	movs	r1, #130	; 0x82
 8006ede:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 8006ee2:	f7fb fcae 	bl	8002842 <HAL_PCDEx_PMAConfig>
  return USBD_OK;
}
 8006ee6:	2000      	movs	r0, #0
 8006ee8:	bd10      	pop	{r4, pc}
 8006eea:	bf00      	nop
 8006eec:	40005c00 	.word	0x40005c00
 8006ef0:	20002d98 	.word	0x20002d98
 8006ef4:	08007b87 	.word	0x08007b87

08006ef8 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8006ef8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8006efa:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006efe:	f7fa fe4a 	bl	8001b96 <HAL_PCD_Start>
 8006f02:	2803      	cmp	r0, #3
 8006f04:	bf9a      	itte	ls
 8006f06:	4b02      	ldrls	r3, [pc, #8]	; (8006f10 <USBD_LL_Start+0x18>)
 8006f08:	5c18      	ldrbls	r0, [r3, r0]
 8006f0a:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8006f0c:	bd08      	pop	{r3, pc}
 8006f0e:	bf00      	nop
 8006f10:	08007b83 	.word	0x08007b83

08006f14 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8006f14:	b510      	push	{r4, lr}
 8006f16:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8006f18:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006f1c:	4613      	mov	r3, r2
 8006f1e:	4622      	mov	r2, r4
 8006f20:	f7fa fe56 	bl	8001bd0 <HAL_PCD_EP_Open>
 8006f24:	2803      	cmp	r0, #3
 8006f26:	bf9a      	itte	ls
 8006f28:	4b01      	ldrls	r3, [pc, #4]	; (8006f30 <USBD_LL_OpenEP+0x1c>)
 8006f2a:	5c18      	ldrbls	r0, [r3, r0]
 8006f2c:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8006f2e:	bd10      	pop	{r4, pc}
 8006f30:	08007b83 	.word	0x08007b83

08006f34 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8006f34:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8006f36:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006f3a:	f7fa ffc7 	bl	8001ecc <HAL_PCD_EP_Close>
 8006f3e:	2803      	cmp	r0, #3
 8006f40:	bf9a      	itte	ls
 8006f42:	4b02      	ldrls	r3, [pc, #8]	; (8006f4c <USBD_LL_CloseEP+0x18>)
 8006f44:	5c18      	ldrbls	r0, [r3, r0]
 8006f46:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8006f48:	bd08      	pop	{r3, pc}
 8006f4a:	bf00      	nop
 8006f4c:	08007b83 	.word	0x08007b83

08006f50 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8006f50:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8006f52:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006f56:	f7fb fbc7 	bl	80026e8 <HAL_PCD_EP_SetStall>
 8006f5a:	2803      	cmp	r0, #3
 8006f5c:	bf9a      	itte	ls
 8006f5e:	4b02      	ldrls	r3, [pc, #8]	; (8006f68 <USBD_LL_StallEP+0x18>)
 8006f60:	5c18      	ldrbls	r0, [r3, r0]
 8006f62:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8006f64:	bd08      	pop	{r3, pc}
 8006f66:	bf00      	nop
 8006f68:	08007b83 	.word	0x08007b83

08006f6c <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8006f6c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8006f6e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006f72:	f7fb fc06 	bl	8002782 <HAL_PCD_EP_ClrStall>
 8006f76:	2803      	cmp	r0, #3
 8006f78:	bf9a      	itte	ls
 8006f7a:	4b02      	ldrls	r3, [pc, #8]	; (8006f84 <USBD_LL_ClearStallEP+0x18>)
 8006f7c:	5c18      	ldrbls	r0, [r3, r0]
 8006f7e:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8006f80:	bd08      	pop	{r3, pc}
 8006f82:	bf00      	nop
 8006f84:	08007b83 	.word	0x08007b83

08006f88 <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
 8006f88:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8006f8c:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
 8006f90:	f04f 021c 	mov.w	r2, #28
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8006f94:	bf1b      	ittet	ne
 8006f96:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 8006f9a:	fb02 3101 	mlane	r1, r2, r1, r3
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8006f9e:	fb02 3101 	mlaeq	r1, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8006fa2:	f891 002a 	ldrbne.w	r0, [r1, #42]	; 0x2a
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8006fa6:	bf08      	it	eq
 8006fa8:	f891 01ce 	ldrbeq.w	r0, [r1, #462]	; 0x1ce
  }
}
 8006fac:	4770      	bx	lr
	...

08006fb0 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8006fb0:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8006fb2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006fb6:	f7fa fdf4 	bl	8001ba2 <HAL_PCD_SetAddress>
 8006fba:	2803      	cmp	r0, #3
 8006fbc:	bf9a      	itte	ls
 8006fbe:	4b02      	ldrls	r3, [pc, #8]	; (8006fc8 <USBD_LL_SetUSBAddress+0x18>)
 8006fc0:	5c18      	ldrbls	r0, [r3, r0]
 8006fc2:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 8006fc4:	bd08      	pop	{r3, pc}
 8006fc6:	bf00      	nop
 8006fc8:	08007b83 	.word	0x08007b83

08006fcc <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8006fcc:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8006fce:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006fd2:	f7fb f8c9 	bl	8002168 <HAL_PCD_EP_Transmit>
 8006fd6:	2803      	cmp	r0, #3
 8006fd8:	bf9a      	itte	ls
 8006fda:	4b02      	ldrls	r3, [pc, #8]	; (8006fe4 <USBD_LL_Transmit+0x18>)
 8006fdc:	5c18      	ldrbls	r0, [r3, r0]
 8006fde:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;    
}
 8006fe0:	bd08      	pop	{r3, pc}
 8006fe2:	bf00      	nop
 8006fe4:	08007b83 	.word	0x08007b83

08006fe8 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8006fe8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8006fea:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8006fee:	f7fb f845 	bl	800207c <HAL_PCD_EP_Receive>
 8006ff2:	2803      	cmp	r0, #3
 8006ff4:	bf9a      	itte	ls
 8006ff6:	4b02      	ldrls	r3, [pc, #8]	; (8007000 <USBD_LL_PrepareReceive+0x18>)
 8006ff8:	5c18      	ldrbls	r0, [r3, r0]
 8006ffa:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8006ffc:	bd08      	pop	{r3, pc}
 8006ffe:	bf00      	nop
 8007000:	08007b83 	.word	0x08007b83

08007004 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007004:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8007006:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800700a:	f7fb f8a5 	bl	8002158 <HAL_PCD_EP_GetRxCount>
}
 800700e:	bd08      	pop	{r3, pc}

08007010 <USBD_static_malloc>:
  */
void *USBD_static_malloc(uint32_t size)
{
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
}
 8007010:	4800      	ldr	r0, [pc, #0]	; (8007014 <USBD_static_malloc+0x4>)
 8007012:	4770      	bx	lr
 8007014:	20001ee4 	.word	0x20001ee4

08007018 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 8007018:	4770      	bx	lr

0800701a <HAL_PCDEx_SetConnectionState>:
  * @param hpcd: PCD handle
  * @param state: Connection state (0: disconnected / 1: connected)
  * @retval None
  */
void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
{
 800701a:	4770      	bx	lr

0800701c <USBD_FS_DeviceDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 800701c:	2312      	movs	r3, #18
 800701e:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 8007020:	4800      	ldr	r0, [pc, #0]	; (8007024 <USBD_FS_DeviceDescriptor+0x8>)
 8007022:	4770      	bx	lr
 8007024:	20000158 	.word	0x20000158

08007028 <USBD_FS_LangIDStrDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 8007028:	2304      	movs	r3, #4
 800702a:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 800702c:	4800      	ldr	r0, [pc, #0]	; (8007030 <USBD_FS_LangIDStrDescriptor+0x8>)
 800702e:	4770      	bx	lr
 8007030:	2000016c 	.word	0x2000016c

08007034 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007034:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8007036:	4c04      	ldr	r4, [pc, #16]	; (8007048 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8007038:	4804      	ldr	r0, [pc, #16]	; (800704c <USBD_FS_ManufacturerStrDescriptor+0x18>)
 800703a:	460a      	mov	r2, r1
 800703c:	4621      	mov	r1, r4
 800703e:	f7fc ff70 	bl	8003f22 <USBD_GetString>
  return USBD_StrDesc;
}
 8007042:	4620      	mov	r0, r4
 8007044:	bd10      	pop	{r4, pc}
 8007046:	bf00      	nop
 8007048:	20003140 	.word	0x20003140
 800704c:	08007bb3 	.word	0x08007bb3

08007050 <USBD_FS_ProductStrDescriptor>:
{
 8007050:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8007052:	4c04      	ldr	r4, [pc, #16]	; (8007064 <USBD_FS_ProductStrDescriptor+0x14>)
 8007054:	4804      	ldr	r0, [pc, #16]	; (8007068 <USBD_FS_ProductStrDescriptor+0x18>)
 8007056:	460a      	mov	r2, r1
 8007058:	4621      	mov	r1, r4
 800705a:	f7fc ff62 	bl	8003f22 <USBD_GetString>
}
 800705e:	4620      	mov	r0, r4
 8007060:	bd10      	pop	{r4, pc}
 8007062:	bf00      	nop
 8007064:	20003140 	.word	0x20003140
 8007068:	08007bc6 	.word	0x08007bc6

0800706c <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 800706c:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 800706e:	4c04      	ldr	r4, [pc, #16]	; (8007080 <USBD_FS_SerialStrDescriptor+0x14>)
 8007070:	4804      	ldr	r0, [pc, #16]	; (8007084 <USBD_FS_SerialStrDescriptor+0x18>)
 8007072:	460a      	mov	r2, r1
 8007074:	4621      	mov	r1, r4
 8007076:	f7fc ff54 	bl	8003f22 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 800707a:	4620      	mov	r0, r4
 800707c:	bd10      	pop	{r4, pc}
 800707e:	bf00      	nop
 8007080:	20003140 	.word	0x20003140
 8007084:	08007bdc 	.word	0x08007bdc

08007088 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007088:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800708a:	4c04      	ldr	r4, [pc, #16]	; (800709c <USBD_FS_ConfigStrDescriptor+0x14>)
 800708c:	4804      	ldr	r0, [pc, #16]	; (80070a0 <USBD_FS_ConfigStrDescriptor+0x18>)
 800708e:	460a      	mov	r2, r1
 8007090:	4621      	mov	r1, r4
 8007092:	f7fc ff46 	bl	8003f22 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8007096:	4620      	mov	r0, r4
 8007098:	bd10      	pop	{r4, pc}
 800709a:	bf00      	nop
 800709c:	20003140 	.word	0x20003140
 80070a0:	08007b9a 	.word	0x08007b9a

080070a4 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80070a4:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80070a6:	4c04      	ldr	r4, [pc, #16]	; (80070b8 <USBD_FS_InterfaceStrDescriptor+0x14>)
 80070a8:	4804      	ldr	r0, [pc, #16]	; (80070bc <USBD_FS_InterfaceStrDescriptor+0x18>)
 80070aa:	460a      	mov	r2, r1
 80070ac:	4621      	mov	r1, r4
 80070ae:	f7fc ff38 	bl	8003f22 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 80070b2:	4620      	mov	r0, r4
 80070b4:	bd10      	pop	{r4, pc}
 80070b6:	bf00      	nop
 80070b8:	20003140 	.word	0x20003140
 80070bc:	08007ba5 	.word	0x08007ba5

080070c0 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80070c0:	f8df d034 	ldr.w	sp, [pc, #52]	; 80070f8 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80070c4:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80070c6:	e003      	b.n	80070d0 <LoopCopyDataInit>

080070c8 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80070c8:	4b0c      	ldr	r3, [pc, #48]	; (80070fc <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80070ca:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80070cc:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80070ce:	3104      	adds	r1, #4

080070d0 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80070d0:	480b      	ldr	r0, [pc, #44]	; (8007100 <LoopForever+0xa>)
	ldr	r3, =_edata
 80070d2:	4b0c      	ldr	r3, [pc, #48]	; (8007104 <LoopForever+0xe>)
	adds	r2, r0, r1
 80070d4:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80070d6:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80070d8:	d3f6      	bcc.n	80070c8 <CopyDataInit>
	ldr	r2, =_sbss
 80070da:	4a0b      	ldr	r2, [pc, #44]	; (8007108 <LoopForever+0x12>)
	b	LoopFillZerobss
 80070dc:	e002      	b.n	80070e4 <LoopFillZerobss>

080070de <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80070de:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80070e0:	f842 3b04 	str.w	r3, [r2], #4

080070e4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80070e4:	4b09      	ldr	r3, [pc, #36]	; (800710c <LoopForever+0x16>)
	cmp	r2, r3
 80070e6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80070e8:	d3f9      	bcc.n	80070de <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80070ea:	f7ff fc89 	bl	8006a00 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80070ee:	f000 f811 	bl	8007114 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80070f2:	f7ff f919 	bl	8006328 <main>

080070f6 <LoopForever>:

LoopForever:
    b LoopForever
 80070f6:	e7fe      	b.n	80070f6 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80070f8:	2000a000 	.word	0x2000a000
	ldr	r3, =_sidata
 80070fc:	08007c24 	.word	0x08007c24
	ldr	r0, =_sdata
 8007100:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8007104:	200001d4 	.word	0x200001d4
	ldr	r2, =_sbss
 8007108:	200001d4 	.word	0x200001d4
	ldr	r3, = _ebss
 800710c:	20003344 	.word	0x20003344

08007110 <ADC3_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8007110:	e7fe      	b.n	8007110 <ADC3_IRQHandler>
	...

08007114 <__libc_init_array>:
 8007114:	b570      	push	{r4, r5, r6, lr}
 8007116:	4e0d      	ldr	r6, [pc, #52]	; (800714c <__libc_init_array+0x38>)
 8007118:	4c0d      	ldr	r4, [pc, #52]	; (8007150 <__libc_init_array+0x3c>)
 800711a:	1ba4      	subs	r4, r4, r6
 800711c:	10a4      	asrs	r4, r4, #2
 800711e:	2500      	movs	r5, #0
 8007120:	42a5      	cmp	r5, r4
 8007122:	d109      	bne.n	8007138 <__libc_init_array+0x24>
 8007124:	4e0b      	ldr	r6, [pc, #44]	; (8007154 <__libc_init_array+0x40>)
 8007126:	4c0c      	ldr	r4, [pc, #48]	; (8007158 <__libc_init_array+0x44>)
 8007128:	f000 fc4c 	bl	80079c4 <_init>
 800712c:	1ba4      	subs	r4, r4, r6
 800712e:	10a4      	asrs	r4, r4, #2
 8007130:	2500      	movs	r5, #0
 8007132:	42a5      	cmp	r5, r4
 8007134:	d105      	bne.n	8007142 <__libc_init_array+0x2e>
 8007136:	bd70      	pop	{r4, r5, r6, pc}
 8007138:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800713c:	4798      	blx	r3
 800713e:	3501      	adds	r5, #1
 8007140:	e7ee      	b.n	8007120 <__libc_init_array+0xc>
 8007142:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8007146:	4798      	blx	r3
 8007148:	3501      	adds	r5, #1
 800714a:	e7f2      	b.n	8007132 <__libc_init_array+0x1e>
 800714c:	08007c1c 	.word	0x08007c1c
 8007150:	08007c1c 	.word	0x08007c1c
 8007154:	08007c1c 	.word	0x08007c1c
 8007158:	08007c20 	.word	0x08007c20

0800715c <memcpy>:
 800715c:	b510      	push	{r4, lr}
 800715e:	1e43      	subs	r3, r0, #1
 8007160:	440a      	add	r2, r1
 8007162:	4291      	cmp	r1, r2
 8007164:	d100      	bne.n	8007168 <memcpy+0xc>
 8007166:	bd10      	pop	{r4, pc}
 8007168:	f811 4b01 	ldrb.w	r4, [r1], #1
 800716c:	f803 4f01 	strb.w	r4, [r3, #1]!
 8007170:	e7f7      	b.n	8007162 <memcpy+0x6>

08007172 <memset>:
 8007172:	4402      	add	r2, r0
 8007174:	4603      	mov	r3, r0
 8007176:	4293      	cmp	r3, r2
 8007178:	d100      	bne.n	800717c <memset+0xa>
 800717a:	4770      	bx	lr
 800717c:	f803 1b01 	strb.w	r1, [r3], #1
 8007180:	e7f9      	b.n	8007176 <memset+0x4>
	...

08007184 <siprintf>:
 8007184:	b40e      	push	{r1, r2, r3}
 8007186:	b500      	push	{lr}
 8007188:	b09c      	sub	sp, #112	; 0x70
 800718a:	f44f 7102 	mov.w	r1, #520	; 0x208
 800718e:	ab1d      	add	r3, sp, #116	; 0x74
 8007190:	f8ad 1014 	strh.w	r1, [sp, #20]
 8007194:	9002      	str	r0, [sp, #8]
 8007196:	9006      	str	r0, [sp, #24]
 8007198:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800719c:	480a      	ldr	r0, [pc, #40]	; (80071c8 <siprintf+0x44>)
 800719e:	9104      	str	r1, [sp, #16]
 80071a0:	9107      	str	r1, [sp, #28]
 80071a2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80071a6:	f853 2b04 	ldr.w	r2, [r3], #4
 80071aa:	f8ad 1016 	strh.w	r1, [sp, #22]
 80071ae:	6800      	ldr	r0, [r0, #0]
 80071b0:	9301      	str	r3, [sp, #4]
 80071b2:	a902      	add	r1, sp, #8
 80071b4:	f000 f866 	bl	8007284 <_svfiprintf_r>
 80071b8:	9b02      	ldr	r3, [sp, #8]
 80071ba:	2200      	movs	r2, #0
 80071bc:	701a      	strb	r2, [r3, #0]
 80071be:	b01c      	add	sp, #112	; 0x70
 80071c0:	f85d eb04 	ldr.w	lr, [sp], #4
 80071c4:	b003      	add	sp, #12
 80071c6:	4770      	bx	lr
 80071c8:	20000170 	.word	0x20000170

080071cc <__ssputs_r>:
 80071cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80071d0:	688e      	ldr	r6, [r1, #8]
 80071d2:	429e      	cmp	r6, r3
 80071d4:	4682      	mov	sl, r0
 80071d6:	460c      	mov	r4, r1
 80071d8:	4691      	mov	r9, r2
 80071da:	4698      	mov	r8, r3
 80071dc:	d835      	bhi.n	800724a <__ssputs_r+0x7e>
 80071de:	898a      	ldrh	r2, [r1, #12]
 80071e0:	f412 6f90 	tst.w	r2, #1152	; 0x480
 80071e4:	d031      	beq.n	800724a <__ssputs_r+0x7e>
 80071e6:	6825      	ldr	r5, [r4, #0]
 80071e8:	6909      	ldr	r1, [r1, #16]
 80071ea:	1a6f      	subs	r7, r5, r1
 80071ec:	6965      	ldr	r5, [r4, #20]
 80071ee:	2302      	movs	r3, #2
 80071f0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80071f4:	fb95 f5f3 	sdiv	r5, r5, r3
 80071f8:	f108 0301 	add.w	r3, r8, #1
 80071fc:	443b      	add	r3, r7
 80071fe:	429d      	cmp	r5, r3
 8007200:	bf38      	it	cc
 8007202:	461d      	movcc	r5, r3
 8007204:	0553      	lsls	r3, r2, #21
 8007206:	d531      	bpl.n	800726c <__ssputs_r+0xa0>
 8007208:	4629      	mov	r1, r5
 800720a:	f000 fb2d 	bl	8007868 <_malloc_r>
 800720e:	4606      	mov	r6, r0
 8007210:	b950      	cbnz	r0, 8007228 <__ssputs_r+0x5c>
 8007212:	230c      	movs	r3, #12
 8007214:	f8ca 3000 	str.w	r3, [sl]
 8007218:	89a3      	ldrh	r3, [r4, #12]
 800721a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800721e:	81a3      	strh	r3, [r4, #12]
 8007220:	f04f 30ff 	mov.w	r0, #4294967295
 8007224:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007228:	463a      	mov	r2, r7
 800722a:	6921      	ldr	r1, [r4, #16]
 800722c:	f7ff ff96 	bl	800715c <memcpy>
 8007230:	89a3      	ldrh	r3, [r4, #12]
 8007232:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8007236:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800723a:	81a3      	strh	r3, [r4, #12]
 800723c:	6126      	str	r6, [r4, #16]
 800723e:	6165      	str	r5, [r4, #20]
 8007240:	443e      	add	r6, r7
 8007242:	1bed      	subs	r5, r5, r7
 8007244:	6026      	str	r6, [r4, #0]
 8007246:	60a5      	str	r5, [r4, #8]
 8007248:	4646      	mov	r6, r8
 800724a:	4546      	cmp	r6, r8
 800724c:	bf28      	it	cs
 800724e:	4646      	movcs	r6, r8
 8007250:	4632      	mov	r2, r6
 8007252:	4649      	mov	r1, r9
 8007254:	6820      	ldr	r0, [r4, #0]
 8007256:	f000 fa9f 	bl	8007798 <memmove>
 800725a:	68a3      	ldr	r3, [r4, #8]
 800725c:	1b9b      	subs	r3, r3, r6
 800725e:	60a3      	str	r3, [r4, #8]
 8007260:	6823      	ldr	r3, [r4, #0]
 8007262:	441e      	add	r6, r3
 8007264:	6026      	str	r6, [r4, #0]
 8007266:	2000      	movs	r0, #0
 8007268:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800726c:	462a      	mov	r2, r5
 800726e:	f000 fb59 	bl	8007924 <_realloc_r>
 8007272:	4606      	mov	r6, r0
 8007274:	2800      	cmp	r0, #0
 8007276:	d1e1      	bne.n	800723c <__ssputs_r+0x70>
 8007278:	6921      	ldr	r1, [r4, #16]
 800727a:	4650      	mov	r0, sl
 800727c:	f000 faa6 	bl	80077cc <_free_r>
 8007280:	e7c7      	b.n	8007212 <__ssputs_r+0x46>
	...

08007284 <_svfiprintf_r>:
 8007284:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007288:	b09d      	sub	sp, #116	; 0x74
 800728a:	4680      	mov	r8, r0
 800728c:	9303      	str	r3, [sp, #12]
 800728e:	898b      	ldrh	r3, [r1, #12]
 8007290:	061c      	lsls	r4, r3, #24
 8007292:	460d      	mov	r5, r1
 8007294:	4616      	mov	r6, r2
 8007296:	d50f      	bpl.n	80072b8 <_svfiprintf_r+0x34>
 8007298:	690b      	ldr	r3, [r1, #16]
 800729a:	b96b      	cbnz	r3, 80072b8 <_svfiprintf_r+0x34>
 800729c:	2140      	movs	r1, #64	; 0x40
 800729e:	f000 fae3 	bl	8007868 <_malloc_r>
 80072a2:	6028      	str	r0, [r5, #0]
 80072a4:	6128      	str	r0, [r5, #16]
 80072a6:	b928      	cbnz	r0, 80072b4 <_svfiprintf_r+0x30>
 80072a8:	230c      	movs	r3, #12
 80072aa:	f8c8 3000 	str.w	r3, [r8]
 80072ae:	f04f 30ff 	mov.w	r0, #4294967295
 80072b2:	e0c5      	b.n	8007440 <_svfiprintf_r+0x1bc>
 80072b4:	2340      	movs	r3, #64	; 0x40
 80072b6:	616b      	str	r3, [r5, #20]
 80072b8:	2300      	movs	r3, #0
 80072ba:	9309      	str	r3, [sp, #36]	; 0x24
 80072bc:	2320      	movs	r3, #32
 80072be:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80072c2:	2330      	movs	r3, #48	; 0x30
 80072c4:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80072c8:	f04f 0b01 	mov.w	fp, #1
 80072cc:	4637      	mov	r7, r6
 80072ce:	463c      	mov	r4, r7
 80072d0:	f814 3b01 	ldrb.w	r3, [r4], #1
 80072d4:	2b00      	cmp	r3, #0
 80072d6:	d13c      	bne.n	8007352 <_svfiprintf_r+0xce>
 80072d8:	ebb7 0a06 	subs.w	sl, r7, r6
 80072dc:	d00b      	beq.n	80072f6 <_svfiprintf_r+0x72>
 80072de:	4653      	mov	r3, sl
 80072e0:	4632      	mov	r2, r6
 80072e2:	4629      	mov	r1, r5
 80072e4:	4640      	mov	r0, r8
 80072e6:	f7ff ff71 	bl	80071cc <__ssputs_r>
 80072ea:	3001      	adds	r0, #1
 80072ec:	f000 80a3 	beq.w	8007436 <_svfiprintf_r+0x1b2>
 80072f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80072f2:	4453      	add	r3, sl
 80072f4:	9309      	str	r3, [sp, #36]	; 0x24
 80072f6:	783b      	ldrb	r3, [r7, #0]
 80072f8:	2b00      	cmp	r3, #0
 80072fa:	f000 809c 	beq.w	8007436 <_svfiprintf_r+0x1b2>
 80072fe:	2300      	movs	r3, #0
 8007300:	f04f 32ff 	mov.w	r2, #4294967295
 8007304:	9304      	str	r3, [sp, #16]
 8007306:	9307      	str	r3, [sp, #28]
 8007308:	9205      	str	r2, [sp, #20]
 800730a:	9306      	str	r3, [sp, #24]
 800730c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8007310:	931a      	str	r3, [sp, #104]	; 0x68
 8007312:	2205      	movs	r2, #5
 8007314:	7821      	ldrb	r1, [r4, #0]
 8007316:	4850      	ldr	r0, [pc, #320]	; (8007458 <_svfiprintf_r+0x1d4>)
 8007318:	f7f8 ff5a 	bl	80001d0 <memchr>
 800731c:	1c67      	adds	r7, r4, #1
 800731e:	9b04      	ldr	r3, [sp, #16]
 8007320:	b9d8      	cbnz	r0, 800735a <_svfiprintf_r+0xd6>
 8007322:	06d9      	lsls	r1, r3, #27
 8007324:	bf44      	itt	mi
 8007326:	2220      	movmi	r2, #32
 8007328:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800732c:	071a      	lsls	r2, r3, #28
 800732e:	bf44      	itt	mi
 8007330:	222b      	movmi	r2, #43	; 0x2b
 8007332:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8007336:	7822      	ldrb	r2, [r4, #0]
 8007338:	2a2a      	cmp	r2, #42	; 0x2a
 800733a:	d016      	beq.n	800736a <_svfiprintf_r+0xe6>
 800733c:	9a07      	ldr	r2, [sp, #28]
 800733e:	2100      	movs	r1, #0
 8007340:	200a      	movs	r0, #10
 8007342:	4627      	mov	r7, r4
 8007344:	3401      	adds	r4, #1
 8007346:	783b      	ldrb	r3, [r7, #0]
 8007348:	3b30      	subs	r3, #48	; 0x30
 800734a:	2b09      	cmp	r3, #9
 800734c:	d951      	bls.n	80073f2 <_svfiprintf_r+0x16e>
 800734e:	b1c9      	cbz	r1, 8007384 <_svfiprintf_r+0x100>
 8007350:	e011      	b.n	8007376 <_svfiprintf_r+0xf2>
 8007352:	2b25      	cmp	r3, #37	; 0x25
 8007354:	d0c0      	beq.n	80072d8 <_svfiprintf_r+0x54>
 8007356:	4627      	mov	r7, r4
 8007358:	e7b9      	b.n	80072ce <_svfiprintf_r+0x4a>
 800735a:	4a3f      	ldr	r2, [pc, #252]	; (8007458 <_svfiprintf_r+0x1d4>)
 800735c:	1a80      	subs	r0, r0, r2
 800735e:	fa0b f000 	lsl.w	r0, fp, r0
 8007362:	4318      	orrs	r0, r3
 8007364:	9004      	str	r0, [sp, #16]
 8007366:	463c      	mov	r4, r7
 8007368:	e7d3      	b.n	8007312 <_svfiprintf_r+0x8e>
 800736a:	9a03      	ldr	r2, [sp, #12]
 800736c:	1d11      	adds	r1, r2, #4
 800736e:	6812      	ldr	r2, [r2, #0]
 8007370:	9103      	str	r1, [sp, #12]
 8007372:	2a00      	cmp	r2, #0
 8007374:	db01      	blt.n	800737a <_svfiprintf_r+0xf6>
 8007376:	9207      	str	r2, [sp, #28]
 8007378:	e004      	b.n	8007384 <_svfiprintf_r+0x100>
 800737a:	4252      	negs	r2, r2
 800737c:	f043 0302 	orr.w	r3, r3, #2
 8007380:	9207      	str	r2, [sp, #28]
 8007382:	9304      	str	r3, [sp, #16]
 8007384:	783b      	ldrb	r3, [r7, #0]
 8007386:	2b2e      	cmp	r3, #46	; 0x2e
 8007388:	d10e      	bne.n	80073a8 <_svfiprintf_r+0x124>
 800738a:	787b      	ldrb	r3, [r7, #1]
 800738c:	2b2a      	cmp	r3, #42	; 0x2a
 800738e:	f107 0101 	add.w	r1, r7, #1
 8007392:	d132      	bne.n	80073fa <_svfiprintf_r+0x176>
 8007394:	9b03      	ldr	r3, [sp, #12]
 8007396:	1d1a      	adds	r2, r3, #4
 8007398:	681b      	ldr	r3, [r3, #0]
 800739a:	9203      	str	r2, [sp, #12]
 800739c:	2b00      	cmp	r3, #0
 800739e:	bfb8      	it	lt
 80073a0:	f04f 33ff 	movlt.w	r3, #4294967295
 80073a4:	3702      	adds	r7, #2
 80073a6:	9305      	str	r3, [sp, #20]
 80073a8:	4c2c      	ldr	r4, [pc, #176]	; (800745c <_svfiprintf_r+0x1d8>)
 80073aa:	7839      	ldrb	r1, [r7, #0]
 80073ac:	2203      	movs	r2, #3
 80073ae:	4620      	mov	r0, r4
 80073b0:	f7f8 ff0e 	bl	80001d0 <memchr>
 80073b4:	b138      	cbz	r0, 80073c6 <_svfiprintf_r+0x142>
 80073b6:	2340      	movs	r3, #64	; 0x40
 80073b8:	1b00      	subs	r0, r0, r4
 80073ba:	fa03 f000 	lsl.w	r0, r3, r0
 80073be:	9b04      	ldr	r3, [sp, #16]
 80073c0:	4303      	orrs	r3, r0
 80073c2:	9304      	str	r3, [sp, #16]
 80073c4:	3701      	adds	r7, #1
 80073c6:	7839      	ldrb	r1, [r7, #0]
 80073c8:	4825      	ldr	r0, [pc, #148]	; (8007460 <_svfiprintf_r+0x1dc>)
 80073ca:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80073ce:	2206      	movs	r2, #6
 80073d0:	1c7e      	adds	r6, r7, #1
 80073d2:	f7f8 fefd 	bl	80001d0 <memchr>
 80073d6:	2800      	cmp	r0, #0
 80073d8:	d035      	beq.n	8007446 <_svfiprintf_r+0x1c2>
 80073da:	4b22      	ldr	r3, [pc, #136]	; (8007464 <_svfiprintf_r+0x1e0>)
 80073dc:	b9fb      	cbnz	r3, 800741e <_svfiprintf_r+0x19a>
 80073de:	9b03      	ldr	r3, [sp, #12]
 80073e0:	3307      	adds	r3, #7
 80073e2:	f023 0307 	bic.w	r3, r3, #7
 80073e6:	3308      	adds	r3, #8
 80073e8:	9303      	str	r3, [sp, #12]
 80073ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80073ec:	444b      	add	r3, r9
 80073ee:	9309      	str	r3, [sp, #36]	; 0x24
 80073f0:	e76c      	b.n	80072cc <_svfiprintf_r+0x48>
 80073f2:	fb00 3202 	mla	r2, r0, r2, r3
 80073f6:	2101      	movs	r1, #1
 80073f8:	e7a3      	b.n	8007342 <_svfiprintf_r+0xbe>
 80073fa:	2300      	movs	r3, #0
 80073fc:	9305      	str	r3, [sp, #20]
 80073fe:	4618      	mov	r0, r3
 8007400:	240a      	movs	r4, #10
 8007402:	460f      	mov	r7, r1
 8007404:	3101      	adds	r1, #1
 8007406:	783a      	ldrb	r2, [r7, #0]
 8007408:	3a30      	subs	r2, #48	; 0x30
 800740a:	2a09      	cmp	r2, #9
 800740c:	d903      	bls.n	8007416 <_svfiprintf_r+0x192>
 800740e:	2b00      	cmp	r3, #0
 8007410:	d0ca      	beq.n	80073a8 <_svfiprintf_r+0x124>
 8007412:	9005      	str	r0, [sp, #20]
 8007414:	e7c8      	b.n	80073a8 <_svfiprintf_r+0x124>
 8007416:	fb04 2000 	mla	r0, r4, r0, r2
 800741a:	2301      	movs	r3, #1
 800741c:	e7f1      	b.n	8007402 <_svfiprintf_r+0x17e>
 800741e:	ab03      	add	r3, sp, #12
 8007420:	9300      	str	r3, [sp, #0]
 8007422:	462a      	mov	r2, r5
 8007424:	4b10      	ldr	r3, [pc, #64]	; (8007468 <_svfiprintf_r+0x1e4>)
 8007426:	a904      	add	r1, sp, #16
 8007428:	4640      	mov	r0, r8
 800742a:	f3af 8000 	nop.w
 800742e:	f1b0 3fff 	cmp.w	r0, #4294967295
 8007432:	4681      	mov	r9, r0
 8007434:	d1d9      	bne.n	80073ea <_svfiprintf_r+0x166>
 8007436:	89ab      	ldrh	r3, [r5, #12]
 8007438:	065b      	lsls	r3, r3, #25
 800743a:	f53f af38 	bmi.w	80072ae <_svfiprintf_r+0x2a>
 800743e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8007440:	b01d      	add	sp, #116	; 0x74
 8007442:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007446:	ab03      	add	r3, sp, #12
 8007448:	9300      	str	r3, [sp, #0]
 800744a:	462a      	mov	r2, r5
 800744c:	4b06      	ldr	r3, [pc, #24]	; (8007468 <_svfiprintf_r+0x1e4>)
 800744e:	a904      	add	r1, sp, #16
 8007450:	4640      	mov	r0, r8
 8007452:	f000 f881 	bl	8007558 <_printf_i>
 8007456:	e7ea      	b.n	800742e <_svfiprintf_r+0x1aa>
 8007458:	08007be9 	.word	0x08007be9
 800745c:	08007bef 	.word	0x08007bef
 8007460:	08007bf3 	.word	0x08007bf3
 8007464:	00000000 	.word	0x00000000
 8007468:	080071cd 	.word	0x080071cd

0800746c <_printf_common>:
 800746c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007470:	4691      	mov	r9, r2
 8007472:	461f      	mov	r7, r3
 8007474:	688a      	ldr	r2, [r1, #8]
 8007476:	690b      	ldr	r3, [r1, #16]
 8007478:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800747c:	4293      	cmp	r3, r2
 800747e:	bfb8      	it	lt
 8007480:	4613      	movlt	r3, r2
 8007482:	f8c9 3000 	str.w	r3, [r9]
 8007486:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800748a:	4606      	mov	r6, r0
 800748c:	460c      	mov	r4, r1
 800748e:	b112      	cbz	r2, 8007496 <_printf_common+0x2a>
 8007490:	3301      	adds	r3, #1
 8007492:	f8c9 3000 	str.w	r3, [r9]
 8007496:	6823      	ldr	r3, [r4, #0]
 8007498:	0699      	lsls	r1, r3, #26
 800749a:	bf42      	ittt	mi
 800749c:	f8d9 3000 	ldrmi.w	r3, [r9]
 80074a0:	3302      	addmi	r3, #2
 80074a2:	f8c9 3000 	strmi.w	r3, [r9]
 80074a6:	6825      	ldr	r5, [r4, #0]
 80074a8:	f015 0506 	ands.w	r5, r5, #6
 80074ac:	d107      	bne.n	80074be <_printf_common+0x52>
 80074ae:	f104 0a19 	add.w	sl, r4, #25
 80074b2:	68e3      	ldr	r3, [r4, #12]
 80074b4:	f8d9 2000 	ldr.w	r2, [r9]
 80074b8:	1a9b      	subs	r3, r3, r2
 80074ba:	429d      	cmp	r5, r3
 80074bc:	db29      	blt.n	8007512 <_printf_common+0xa6>
 80074be:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80074c2:	6822      	ldr	r2, [r4, #0]
 80074c4:	3300      	adds	r3, #0
 80074c6:	bf18      	it	ne
 80074c8:	2301      	movne	r3, #1
 80074ca:	0692      	lsls	r2, r2, #26
 80074cc:	d42e      	bmi.n	800752c <_printf_common+0xc0>
 80074ce:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80074d2:	4639      	mov	r1, r7
 80074d4:	4630      	mov	r0, r6
 80074d6:	47c0      	blx	r8
 80074d8:	3001      	adds	r0, #1
 80074da:	d021      	beq.n	8007520 <_printf_common+0xb4>
 80074dc:	6823      	ldr	r3, [r4, #0]
 80074de:	68e5      	ldr	r5, [r4, #12]
 80074e0:	f8d9 2000 	ldr.w	r2, [r9]
 80074e4:	f003 0306 	and.w	r3, r3, #6
 80074e8:	2b04      	cmp	r3, #4
 80074ea:	bf08      	it	eq
 80074ec:	1aad      	subeq	r5, r5, r2
 80074ee:	68a3      	ldr	r3, [r4, #8]
 80074f0:	6922      	ldr	r2, [r4, #16]
 80074f2:	bf0c      	ite	eq
 80074f4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80074f8:	2500      	movne	r5, #0
 80074fa:	4293      	cmp	r3, r2
 80074fc:	bfc4      	itt	gt
 80074fe:	1a9b      	subgt	r3, r3, r2
 8007500:	18ed      	addgt	r5, r5, r3
 8007502:	f04f 0900 	mov.w	r9, #0
 8007506:	341a      	adds	r4, #26
 8007508:	454d      	cmp	r5, r9
 800750a:	d11b      	bne.n	8007544 <_printf_common+0xd8>
 800750c:	2000      	movs	r0, #0
 800750e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007512:	2301      	movs	r3, #1
 8007514:	4652      	mov	r2, sl
 8007516:	4639      	mov	r1, r7
 8007518:	4630      	mov	r0, r6
 800751a:	47c0      	blx	r8
 800751c:	3001      	adds	r0, #1
 800751e:	d103      	bne.n	8007528 <_printf_common+0xbc>
 8007520:	f04f 30ff 	mov.w	r0, #4294967295
 8007524:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007528:	3501      	adds	r5, #1
 800752a:	e7c2      	b.n	80074b2 <_printf_common+0x46>
 800752c:	18e1      	adds	r1, r4, r3
 800752e:	1c5a      	adds	r2, r3, #1
 8007530:	2030      	movs	r0, #48	; 0x30
 8007532:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8007536:	4422      	add	r2, r4
 8007538:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800753c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8007540:	3302      	adds	r3, #2
 8007542:	e7c4      	b.n	80074ce <_printf_common+0x62>
 8007544:	2301      	movs	r3, #1
 8007546:	4622      	mov	r2, r4
 8007548:	4639      	mov	r1, r7
 800754a:	4630      	mov	r0, r6
 800754c:	47c0      	blx	r8
 800754e:	3001      	adds	r0, #1
 8007550:	d0e6      	beq.n	8007520 <_printf_common+0xb4>
 8007552:	f109 0901 	add.w	r9, r9, #1
 8007556:	e7d7      	b.n	8007508 <_printf_common+0x9c>

08007558 <_printf_i>:
 8007558:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800755c:	4617      	mov	r7, r2
 800755e:	7e0a      	ldrb	r2, [r1, #24]
 8007560:	b085      	sub	sp, #20
 8007562:	2a6e      	cmp	r2, #110	; 0x6e
 8007564:	4698      	mov	r8, r3
 8007566:	4606      	mov	r6, r0
 8007568:	460c      	mov	r4, r1
 800756a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800756c:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 8007570:	f000 80bc 	beq.w	80076ec <_printf_i+0x194>
 8007574:	d81a      	bhi.n	80075ac <_printf_i+0x54>
 8007576:	2a63      	cmp	r2, #99	; 0x63
 8007578:	d02e      	beq.n	80075d8 <_printf_i+0x80>
 800757a:	d80a      	bhi.n	8007592 <_printf_i+0x3a>
 800757c:	2a00      	cmp	r2, #0
 800757e:	f000 80c8 	beq.w	8007712 <_printf_i+0x1ba>
 8007582:	2a58      	cmp	r2, #88	; 0x58
 8007584:	f000 808a 	beq.w	800769c <_printf_i+0x144>
 8007588:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800758c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 8007590:	e02a      	b.n	80075e8 <_printf_i+0x90>
 8007592:	2a64      	cmp	r2, #100	; 0x64
 8007594:	d001      	beq.n	800759a <_printf_i+0x42>
 8007596:	2a69      	cmp	r2, #105	; 0x69
 8007598:	d1f6      	bne.n	8007588 <_printf_i+0x30>
 800759a:	6821      	ldr	r1, [r4, #0]
 800759c:	681a      	ldr	r2, [r3, #0]
 800759e:	f011 0f80 	tst.w	r1, #128	; 0x80
 80075a2:	d023      	beq.n	80075ec <_printf_i+0x94>
 80075a4:	1d11      	adds	r1, r2, #4
 80075a6:	6019      	str	r1, [r3, #0]
 80075a8:	6813      	ldr	r3, [r2, #0]
 80075aa:	e027      	b.n	80075fc <_printf_i+0xa4>
 80075ac:	2a73      	cmp	r2, #115	; 0x73
 80075ae:	f000 80b4 	beq.w	800771a <_printf_i+0x1c2>
 80075b2:	d808      	bhi.n	80075c6 <_printf_i+0x6e>
 80075b4:	2a6f      	cmp	r2, #111	; 0x6f
 80075b6:	d02a      	beq.n	800760e <_printf_i+0xb6>
 80075b8:	2a70      	cmp	r2, #112	; 0x70
 80075ba:	d1e5      	bne.n	8007588 <_printf_i+0x30>
 80075bc:	680a      	ldr	r2, [r1, #0]
 80075be:	f042 0220 	orr.w	r2, r2, #32
 80075c2:	600a      	str	r2, [r1, #0]
 80075c4:	e003      	b.n	80075ce <_printf_i+0x76>
 80075c6:	2a75      	cmp	r2, #117	; 0x75
 80075c8:	d021      	beq.n	800760e <_printf_i+0xb6>
 80075ca:	2a78      	cmp	r2, #120	; 0x78
 80075cc:	d1dc      	bne.n	8007588 <_printf_i+0x30>
 80075ce:	2278      	movs	r2, #120	; 0x78
 80075d0:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 80075d4:	496e      	ldr	r1, [pc, #440]	; (8007790 <_printf_i+0x238>)
 80075d6:	e064      	b.n	80076a2 <_printf_i+0x14a>
 80075d8:	681a      	ldr	r2, [r3, #0]
 80075da:	f101 0542 	add.w	r5, r1, #66	; 0x42
 80075de:	1d11      	adds	r1, r2, #4
 80075e0:	6019      	str	r1, [r3, #0]
 80075e2:	6813      	ldr	r3, [r2, #0]
 80075e4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80075e8:	2301      	movs	r3, #1
 80075ea:	e0a3      	b.n	8007734 <_printf_i+0x1dc>
 80075ec:	f011 0f40 	tst.w	r1, #64	; 0x40
 80075f0:	f102 0104 	add.w	r1, r2, #4
 80075f4:	6019      	str	r1, [r3, #0]
 80075f6:	d0d7      	beq.n	80075a8 <_printf_i+0x50>
 80075f8:	f9b2 3000 	ldrsh.w	r3, [r2]
 80075fc:	2b00      	cmp	r3, #0
 80075fe:	da03      	bge.n	8007608 <_printf_i+0xb0>
 8007600:	222d      	movs	r2, #45	; 0x2d
 8007602:	425b      	negs	r3, r3
 8007604:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8007608:	4962      	ldr	r1, [pc, #392]	; (8007794 <_printf_i+0x23c>)
 800760a:	220a      	movs	r2, #10
 800760c:	e017      	b.n	800763e <_printf_i+0xe6>
 800760e:	6820      	ldr	r0, [r4, #0]
 8007610:	6819      	ldr	r1, [r3, #0]
 8007612:	f010 0f80 	tst.w	r0, #128	; 0x80
 8007616:	d003      	beq.n	8007620 <_printf_i+0xc8>
 8007618:	1d08      	adds	r0, r1, #4
 800761a:	6018      	str	r0, [r3, #0]
 800761c:	680b      	ldr	r3, [r1, #0]
 800761e:	e006      	b.n	800762e <_printf_i+0xd6>
 8007620:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007624:	f101 0004 	add.w	r0, r1, #4
 8007628:	6018      	str	r0, [r3, #0]
 800762a:	d0f7      	beq.n	800761c <_printf_i+0xc4>
 800762c:	880b      	ldrh	r3, [r1, #0]
 800762e:	4959      	ldr	r1, [pc, #356]	; (8007794 <_printf_i+0x23c>)
 8007630:	2a6f      	cmp	r2, #111	; 0x6f
 8007632:	bf14      	ite	ne
 8007634:	220a      	movne	r2, #10
 8007636:	2208      	moveq	r2, #8
 8007638:	2000      	movs	r0, #0
 800763a:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 800763e:	6865      	ldr	r5, [r4, #4]
 8007640:	60a5      	str	r5, [r4, #8]
 8007642:	2d00      	cmp	r5, #0
 8007644:	f2c0 809c 	blt.w	8007780 <_printf_i+0x228>
 8007648:	6820      	ldr	r0, [r4, #0]
 800764a:	f020 0004 	bic.w	r0, r0, #4
 800764e:	6020      	str	r0, [r4, #0]
 8007650:	2b00      	cmp	r3, #0
 8007652:	d13f      	bne.n	80076d4 <_printf_i+0x17c>
 8007654:	2d00      	cmp	r5, #0
 8007656:	f040 8095 	bne.w	8007784 <_printf_i+0x22c>
 800765a:	4675      	mov	r5, lr
 800765c:	2a08      	cmp	r2, #8
 800765e:	d10b      	bne.n	8007678 <_printf_i+0x120>
 8007660:	6823      	ldr	r3, [r4, #0]
 8007662:	07da      	lsls	r2, r3, #31
 8007664:	d508      	bpl.n	8007678 <_printf_i+0x120>
 8007666:	6923      	ldr	r3, [r4, #16]
 8007668:	6862      	ldr	r2, [r4, #4]
 800766a:	429a      	cmp	r2, r3
 800766c:	bfde      	ittt	le
 800766e:	2330      	movle	r3, #48	; 0x30
 8007670:	f805 3c01 	strble.w	r3, [r5, #-1]
 8007674:	f105 35ff 	addle.w	r5, r5, #4294967295
 8007678:	ebae 0305 	sub.w	r3, lr, r5
 800767c:	6123      	str	r3, [r4, #16]
 800767e:	f8cd 8000 	str.w	r8, [sp]
 8007682:	463b      	mov	r3, r7
 8007684:	aa03      	add	r2, sp, #12
 8007686:	4621      	mov	r1, r4
 8007688:	4630      	mov	r0, r6
 800768a:	f7ff feef 	bl	800746c <_printf_common>
 800768e:	3001      	adds	r0, #1
 8007690:	d155      	bne.n	800773e <_printf_i+0x1e6>
 8007692:	f04f 30ff 	mov.w	r0, #4294967295
 8007696:	b005      	add	sp, #20
 8007698:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800769c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 80076a0:	493c      	ldr	r1, [pc, #240]	; (8007794 <_printf_i+0x23c>)
 80076a2:	6822      	ldr	r2, [r4, #0]
 80076a4:	6818      	ldr	r0, [r3, #0]
 80076a6:	f012 0f80 	tst.w	r2, #128	; 0x80
 80076aa:	f100 0504 	add.w	r5, r0, #4
 80076ae:	601d      	str	r5, [r3, #0]
 80076b0:	d001      	beq.n	80076b6 <_printf_i+0x15e>
 80076b2:	6803      	ldr	r3, [r0, #0]
 80076b4:	e002      	b.n	80076bc <_printf_i+0x164>
 80076b6:	0655      	lsls	r5, r2, #25
 80076b8:	d5fb      	bpl.n	80076b2 <_printf_i+0x15a>
 80076ba:	8803      	ldrh	r3, [r0, #0]
 80076bc:	07d0      	lsls	r0, r2, #31
 80076be:	bf44      	itt	mi
 80076c0:	f042 0220 	orrmi.w	r2, r2, #32
 80076c4:	6022      	strmi	r2, [r4, #0]
 80076c6:	b91b      	cbnz	r3, 80076d0 <_printf_i+0x178>
 80076c8:	6822      	ldr	r2, [r4, #0]
 80076ca:	f022 0220 	bic.w	r2, r2, #32
 80076ce:	6022      	str	r2, [r4, #0]
 80076d0:	2210      	movs	r2, #16
 80076d2:	e7b1      	b.n	8007638 <_printf_i+0xe0>
 80076d4:	4675      	mov	r5, lr
 80076d6:	fbb3 f0f2 	udiv	r0, r3, r2
 80076da:	fb02 3310 	mls	r3, r2, r0, r3
 80076de:	5ccb      	ldrb	r3, [r1, r3]
 80076e0:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80076e4:	4603      	mov	r3, r0
 80076e6:	2800      	cmp	r0, #0
 80076e8:	d1f5      	bne.n	80076d6 <_printf_i+0x17e>
 80076ea:	e7b7      	b.n	800765c <_printf_i+0x104>
 80076ec:	6808      	ldr	r0, [r1, #0]
 80076ee:	681a      	ldr	r2, [r3, #0]
 80076f0:	6949      	ldr	r1, [r1, #20]
 80076f2:	f010 0f80 	tst.w	r0, #128	; 0x80
 80076f6:	d004      	beq.n	8007702 <_printf_i+0x1aa>
 80076f8:	1d10      	adds	r0, r2, #4
 80076fa:	6018      	str	r0, [r3, #0]
 80076fc:	6813      	ldr	r3, [r2, #0]
 80076fe:	6019      	str	r1, [r3, #0]
 8007700:	e007      	b.n	8007712 <_printf_i+0x1ba>
 8007702:	f010 0f40 	tst.w	r0, #64	; 0x40
 8007706:	f102 0004 	add.w	r0, r2, #4
 800770a:	6018      	str	r0, [r3, #0]
 800770c:	6813      	ldr	r3, [r2, #0]
 800770e:	d0f6      	beq.n	80076fe <_printf_i+0x1a6>
 8007710:	8019      	strh	r1, [r3, #0]
 8007712:	2300      	movs	r3, #0
 8007714:	6123      	str	r3, [r4, #16]
 8007716:	4675      	mov	r5, lr
 8007718:	e7b1      	b.n	800767e <_printf_i+0x126>
 800771a:	681a      	ldr	r2, [r3, #0]
 800771c:	1d11      	adds	r1, r2, #4
 800771e:	6019      	str	r1, [r3, #0]
 8007720:	6815      	ldr	r5, [r2, #0]
 8007722:	6862      	ldr	r2, [r4, #4]
 8007724:	2100      	movs	r1, #0
 8007726:	4628      	mov	r0, r5
 8007728:	f7f8 fd52 	bl	80001d0 <memchr>
 800772c:	b108      	cbz	r0, 8007732 <_printf_i+0x1da>
 800772e:	1b40      	subs	r0, r0, r5
 8007730:	6060      	str	r0, [r4, #4]
 8007732:	6863      	ldr	r3, [r4, #4]
 8007734:	6123      	str	r3, [r4, #16]
 8007736:	2300      	movs	r3, #0
 8007738:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800773c:	e79f      	b.n	800767e <_printf_i+0x126>
 800773e:	6923      	ldr	r3, [r4, #16]
 8007740:	462a      	mov	r2, r5
 8007742:	4639      	mov	r1, r7
 8007744:	4630      	mov	r0, r6
 8007746:	47c0      	blx	r8
 8007748:	3001      	adds	r0, #1
 800774a:	d0a2      	beq.n	8007692 <_printf_i+0x13a>
 800774c:	6823      	ldr	r3, [r4, #0]
 800774e:	079b      	lsls	r3, r3, #30
 8007750:	d507      	bpl.n	8007762 <_printf_i+0x20a>
 8007752:	2500      	movs	r5, #0
 8007754:	f104 0919 	add.w	r9, r4, #25
 8007758:	68e3      	ldr	r3, [r4, #12]
 800775a:	9a03      	ldr	r2, [sp, #12]
 800775c:	1a9b      	subs	r3, r3, r2
 800775e:	429d      	cmp	r5, r3
 8007760:	db05      	blt.n	800776e <_printf_i+0x216>
 8007762:	68e0      	ldr	r0, [r4, #12]
 8007764:	9b03      	ldr	r3, [sp, #12]
 8007766:	4298      	cmp	r0, r3
 8007768:	bfb8      	it	lt
 800776a:	4618      	movlt	r0, r3
 800776c:	e793      	b.n	8007696 <_printf_i+0x13e>
 800776e:	2301      	movs	r3, #1
 8007770:	464a      	mov	r2, r9
 8007772:	4639      	mov	r1, r7
 8007774:	4630      	mov	r0, r6
 8007776:	47c0      	blx	r8
 8007778:	3001      	adds	r0, #1
 800777a:	d08a      	beq.n	8007692 <_printf_i+0x13a>
 800777c:	3501      	adds	r5, #1
 800777e:	e7eb      	b.n	8007758 <_printf_i+0x200>
 8007780:	2b00      	cmp	r3, #0
 8007782:	d1a7      	bne.n	80076d4 <_printf_i+0x17c>
 8007784:	780b      	ldrb	r3, [r1, #0]
 8007786:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800778a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800778e:	e765      	b.n	800765c <_printf_i+0x104>
 8007790:	08007c0b 	.word	0x08007c0b
 8007794:	08007bfa 	.word	0x08007bfa

08007798 <memmove>:
 8007798:	4288      	cmp	r0, r1
 800779a:	b510      	push	{r4, lr}
 800779c:	eb01 0302 	add.w	r3, r1, r2
 80077a0:	d803      	bhi.n	80077aa <memmove+0x12>
 80077a2:	1e42      	subs	r2, r0, #1
 80077a4:	4299      	cmp	r1, r3
 80077a6:	d10c      	bne.n	80077c2 <memmove+0x2a>
 80077a8:	bd10      	pop	{r4, pc}
 80077aa:	4298      	cmp	r0, r3
 80077ac:	d2f9      	bcs.n	80077a2 <memmove+0xa>
 80077ae:	1881      	adds	r1, r0, r2
 80077b0:	1ad2      	subs	r2, r2, r3
 80077b2:	42d3      	cmn	r3, r2
 80077b4:	d100      	bne.n	80077b8 <memmove+0x20>
 80077b6:	bd10      	pop	{r4, pc}
 80077b8:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80077bc:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80077c0:	e7f7      	b.n	80077b2 <memmove+0x1a>
 80077c2:	f811 4b01 	ldrb.w	r4, [r1], #1
 80077c6:	f802 4f01 	strb.w	r4, [r2, #1]!
 80077ca:	e7eb      	b.n	80077a4 <memmove+0xc>

080077cc <_free_r>:
 80077cc:	b538      	push	{r3, r4, r5, lr}
 80077ce:	4605      	mov	r5, r0
 80077d0:	2900      	cmp	r1, #0
 80077d2:	d045      	beq.n	8007860 <_free_r+0x94>
 80077d4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80077d8:	1f0c      	subs	r4, r1, #4
 80077da:	2b00      	cmp	r3, #0
 80077dc:	bfb8      	it	lt
 80077de:	18e4      	addlt	r4, r4, r3
 80077e0:	f000 f8d6 	bl	8007990 <__malloc_lock>
 80077e4:	4a1f      	ldr	r2, [pc, #124]	; (8007864 <_free_r+0x98>)
 80077e6:	6813      	ldr	r3, [r2, #0]
 80077e8:	4610      	mov	r0, r2
 80077ea:	b933      	cbnz	r3, 80077fa <_free_r+0x2e>
 80077ec:	6063      	str	r3, [r4, #4]
 80077ee:	6014      	str	r4, [r2, #0]
 80077f0:	4628      	mov	r0, r5
 80077f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80077f6:	f000 b8cc 	b.w	8007992 <__malloc_unlock>
 80077fa:	42a3      	cmp	r3, r4
 80077fc:	d90c      	bls.n	8007818 <_free_r+0x4c>
 80077fe:	6821      	ldr	r1, [r4, #0]
 8007800:	1862      	adds	r2, r4, r1
 8007802:	4293      	cmp	r3, r2
 8007804:	bf04      	itt	eq
 8007806:	681a      	ldreq	r2, [r3, #0]
 8007808:	685b      	ldreq	r3, [r3, #4]
 800780a:	6063      	str	r3, [r4, #4]
 800780c:	bf04      	itt	eq
 800780e:	1852      	addeq	r2, r2, r1
 8007810:	6022      	streq	r2, [r4, #0]
 8007812:	6004      	str	r4, [r0, #0]
 8007814:	e7ec      	b.n	80077f0 <_free_r+0x24>
 8007816:	4613      	mov	r3, r2
 8007818:	685a      	ldr	r2, [r3, #4]
 800781a:	b10a      	cbz	r2, 8007820 <_free_r+0x54>
 800781c:	42a2      	cmp	r2, r4
 800781e:	d9fa      	bls.n	8007816 <_free_r+0x4a>
 8007820:	6819      	ldr	r1, [r3, #0]
 8007822:	1858      	adds	r0, r3, r1
 8007824:	42a0      	cmp	r0, r4
 8007826:	d10b      	bne.n	8007840 <_free_r+0x74>
 8007828:	6820      	ldr	r0, [r4, #0]
 800782a:	4401      	add	r1, r0
 800782c:	1858      	adds	r0, r3, r1
 800782e:	4282      	cmp	r2, r0
 8007830:	6019      	str	r1, [r3, #0]
 8007832:	d1dd      	bne.n	80077f0 <_free_r+0x24>
 8007834:	6810      	ldr	r0, [r2, #0]
 8007836:	6852      	ldr	r2, [r2, #4]
 8007838:	605a      	str	r2, [r3, #4]
 800783a:	4401      	add	r1, r0
 800783c:	6019      	str	r1, [r3, #0]
 800783e:	e7d7      	b.n	80077f0 <_free_r+0x24>
 8007840:	d902      	bls.n	8007848 <_free_r+0x7c>
 8007842:	230c      	movs	r3, #12
 8007844:	602b      	str	r3, [r5, #0]
 8007846:	e7d3      	b.n	80077f0 <_free_r+0x24>
 8007848:	6820      	ldr	r0, [r4, #0]
 800784a:	1821      	adds	r1, r4, r0
 800784c:	428a      	cmp	r2, r1
 800784e:	bf04      	itt	eq
 8007850:	6811      	ldreq	r1, [r2, #0]
 8007852:	6852      	ldreq	r2, [r2, #4]
 8007854:	6062      	str	r2, [r4, #4]
 8007856:	bf04      	itt	eq
 8007858:	1809      	addeq	r1, r1, r0
 800785a:	6021      	streq	r1, [r4, #0]
 800785c:	605c      	str	r4, [r3, #4]
 800785e:	e7c7      	b.n	80077f0 <_free_r+0x24>
 8007860:	bd38      	pop	{r3, r4, r5, pc}
 8007862:	bf00      	nop
 8007864:	20002104 	.word	0x20002104

08007868 <_malloc_r>:
 8007868:	b570      	push	{r4, r5, r6, lr}
 800786a:	1ccd      	adds	r5, r1, #3
 800786c:	f025 0503 	bic.w	r5, r5, #3
 8007870:	3508      	adds	r5, #8
 8007872:	2d0c      	cmp	r5, #12
 8007874:	bf38      	it	cc
 8007876:	250c      	movcc	r5, #12
 8007878:	2d00      	cmp	r5, #0
 800787a:	4606      	mov	r6, r0
 800787c:	db01      	blt.n	8007882 <_malloc_r+0x1a>
 800787e:	42a9      	cmp	r1, r5
 8007880:	d903      	bls.n	800788a <_malloc_r+0x22>
 8007882:	230c      	movs	r3, #12
 8007884:	6033      	str	r3, [r6, #0]
 8007886:	2000      	movs	r0, #0
 8007888:	bd70      	pop	{r4, r5, r6, pc}
 800788a:	f000 f881 	bl	8007990 <__malloc_lock>
 800788e:	4a23      	ldr	r2, [pc, #140]	; (800791c <_malloc_r+0xb4>)
 8007890:	6814      	ldr	r4, [r2, #0]
 8007892:	4621      	mov	r1, r4
 8007894:	b991      	cbnz	r1, 80078bc <_malloc_r+0x54>
 8007896:	4c22      	ldr	r4, [pc, #136]	; (8007920 <_malloc_r+0xb8>)
 8007898:	6823      	ldr	r3, [r4, #0]
 800789a:	b91b      	cbnz	r3, 80078a4 <_malloc_r+0x3c>
 800789c:	4630      	mov	r0, r6
 800789e:	f000 f867 	bl	8007970 <_sbrk_r>
 80078a2:	6020      	str	r0, [r4, #0]
 80078a4:	4629      	mov	r1, r5
 80078a6:	4630      	mov	r0, r6
 80078a8:	f000 f862 	bl	8007970 <_sbrk_r>
 80078ac:	1c43      	adds	r3, r0, #1
 80078ae:	d126      	bne.n	80078fe <_malloc_r+0x96>
 80078b0:	230c      	movs	r3, #12
 80078b2:	6033      	str	r3, [r6, #0]
 80078b4:	4630      	mov	r0, r6
 80078b6:	f000 f86c 	bl	8007992 <__malloc_unlock>
 80078ba:	e7e4      	b.n	8007886 <_malloc_r+0x1e>
 80078bc:	680b      	ldr	r3, [r1, #0]
 80078be:	1b5b      	subs	r3, r3, r5
 80078c0:	d41a      	bmi.n	80078f8 <_malloc_r+0x90>
 80078c2:	2b0b      	cmp	r3, #11
 80078c4:	d90f      	bls.n	80078e6 <_malloc_r+0x7e>
 80078c6:	600b      	str	r3, [r1, #0]
 80078c8:	50cd      	str	r5, [r1, r3]
 80078ca:	18cc      	adds	r4, r1, r3
 80078cc:	4630      	mov	r0, r6
 80078ce:	f000 f860 	bl	8007992 <__malloc_unlock>
 80078d2:	f104 000b 	add.w	r0, r4, #11
 80078d6:	1d23      	adds	r3, r4, #4
 80078d8:	f020 0007 	bic.w	r0, r0, #7
 80078dc:	1ac3      	subs	r3, r0, r3
 80078de:	d01b      	beq.n	8007918 <_malloc_r+0xb0>
 80078e0:	425a      	negs	r2, r3
 80078e2:	50e2      	str	r2, [r4, r3]
 80078e4:	bd70      	pop	{r4, r5, r6, pc}
 80078e6:	428c      	cmp	r4, r1
 80078e8:	bf0d      	iteet	eq
 80078ea:	6863      	ldreq	r3, [r4, #4]
 80078ec:	684b      	ldrne	r3, [r1, #4]
 80078ee:	6063      	strne	r3, [r4, #4]
 80078f0:	6013      	streq	r3, [r2, #0]
 80078f2:	bf18      	it	ne
 80078f4:	460c      	movne	r4, r1
 80078f6:	e7e9      	b.n	80078cc <_malloc_r+0x64>
 80078f8:	460c      	mov	r4, r1
 80078fa:	6849      	ldr	r1, [r1, #4]
 80078fc:	e7ca      	b.n	8007894 <_malloc_r+0x2c>
 80078fe:	1cc4      	adds	r4, r0, #3
 8007900:	f024 0403 	bic.w	r4, r4, #3
 8007904:	42a0      	cmp	r0, r4
 8007906:	d005      	beq.n	8007914 <_malloc_r+0xac>
 8007908:	1a21      	subs	r1, r4, r0
 800790a:	4630      	mov	r0, r6
 800790c:	f000 f830 	bl	8007970 <_sbrk_r>
 8007910:	3001      	adds	r0, #1
 8007912:	d0cd      	beq.n	80078b0 <_malloc_r+0x48>
 8007914:	6025      	str	r5, [r4, #0]
 8007916:	e7d9      	b.n	80078cc <_malloc_r+0x64>
 8007918:	bd70      	pop	{r4, r5, r6, pc}
 800791a:	bf00      	nop
 800791c:	20002104 	.word	0x20002104
 8007920:	20002108 	.word	0x20002108

08007924 <_realloc_r>:
 8007924:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007926:	4607      	mov	r7, r0
 8007928:	4614      	mov	r4, r2
 800792a:	460e      	mov	r6, r1
 800792c:	b921      	cbnz	r1, 8007938 <_realloc_r+0x14>
 800792e:	4611      	mov	r1, r2
 8007930:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8007934:	f7ff bf98 	b.w	8007868 <_malloc_r>
 8007938:	b922      	cbnz	r2, 8007944 <_realloc_r+0x20>
 800793a:	f7ff ff47 	bl	80077cc <_free_r>
 800793e:	4625      	mov	r5, r4
 8007940:	4628      	mov	r0, r5
 8007942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007944:	f000 f826 	bl	8007994 <_malloc_usable_size_r>
 8007948:	4284      	cmp	r4, r0
 800794a:	d90f      	bls.n	800796c <_realloc_r+0x48>
 800794c:	4621      	mov	r1, r4
 800794e:	4638      	mov	r0, r7
 8007950:	f7ff ff8a 	bl	8007868 <_malloc_r>
 8007954:	4605      	mov	r5, r0
 8007956:	2800      	cmp	r0, #0
 8007958:	d0f2      	beq.n	8007940 <_realloc_r+0x1c>
 800795a:	4631      	mov	r1, r6
 800795c:	4622      	mov	r2, r4
 800795e:	f7ff fbfd 	bl	800715c <memcpy>
 8007962:	4631      	mov	r1, r6
 8007964:	4638      	mov	r0, r7
 8007966:	f7ff ff31 	bl	80077cc <_free_r>
 800796a:	e7e9      	b.n	8007940 <_realloc_r+0x1c>
 800796c:	4635      	mov	r5, r6
 800796e:	e7e7      	b.n	8007940 <_realloc_r+0x1c>

08007970 <_sbrk_r>:
 8007970:	b538      	push	{r3, r4, r5, lr}
 8007972:	4c06      	ldr	r4, [pc, #24]	; (800798c <_sbrk_r+0x1c>)
 8007974:	2300      	movs	r3, #0
 8007976:	4605      	mov	r5, r0
 8007978:	4608      	mov	r0, r1
 800797a:	6023      	str	r3, [r4, #0]
 800797c:	f000 f814 	bl	80079a8 <_sbrk>
 8007980:	1c43      	adds	r3, r0, #1
 8007982:	d102      	bne.n	800798a <_sbrk_r+0x1a>
 8007984:	6823      	ldr	r3, [r4, #0]
 8007986:	b103      	cbz	r3, 800798a <_sbrk_r+0x1a>
 8007988:	602b      	str	r3, [r5, #0]
 800798a:	bd38      	pop	{r3, r4, r5, pc}
 800798c:	20003340 	.word	0x20003340

08007990 <__malloc_lock>:
 8007990:	4770      	bx	lr

08007992 <__malloc_unlock>:
 8007992:	4770      	bx	lr

08007994 <_malloc_usable_size_r>:
 8007994:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8007998:	2800      	cmp	r0, #0
 800799a:	f1a0 0004 	sub.w	r0, r0, #4
 800799e:	bfbc      	itt	lt
 80079a0:	580b      	ldrlt	r3, [r1, r0]
 80079a2:	18c0      	addlt	r0, r0, r3
 80079a4:	4770      	bx	lr
	...

080079a8 <_sbrk>:
 80079a8:	4b04      	ldr	r3, [pc, #16]	; (80079bc <_sbrk+0x14>)
 80079aa:	6819      	ldr	r1, [r3, #0]
 80079ac:	4602      	mov	r2, r0
 80079ae:	b909      	cbnz	r1, 80079b4 <_sbrk+0xc>
 80079b0:	4903      	ldr	r1, [pc, #12]	; (80079c0 <_sbrk+0x18>)
 80079b2:	6019      	str	r1, [r3, #0]
 80079b4:	6818      	ldr	r0, [r3, #0]
 80079b6:	4402      	add	r2, r0
 80079b8:	601a      	str	r2, [r3, #0]
 80079ba:	4770      	bx	lr
 80079bc:	2000210c 	.word	0x2000210c
 80079c0:	20003344 	.word	0x20003344

080079c4 <_init>:
 80079c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80079c6:	bf00      	nop
 80079c8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80079ca:	bc08      	pop	{r3}
 80079cc:	469e      	mov	lr, r3
 80079ce:	4770      	bx	lr

080079d0 <_fini>:
 80079d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80079d2:	bf00      	nop
 80079d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80079d6:	bc08      	pop	{r3}
 80079d8:	469e      	mov	lr, r3
 80079da:	4770      	bx	lr
